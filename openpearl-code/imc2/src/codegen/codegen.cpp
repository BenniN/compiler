#include <iostream>
#include <algorithm>
#include <functional>

#include "imc.hpp"
#include "logger.hpp"
#include "codegen/codegen.hpp"
#include "types/system.hpp"
#include "util.hpp"

template<typename T>
using optional                = ::std::experimental::optional<T>;
using UserName                = imc::types::system::UserName;
using Platform                = imc::types::platform::Platform;
using PlatformType            = imc::types::platform::PlatformType;

optional<imc::codegen::Type> find_type(const Platform& platform, const UserName& username) noexcept {
    bool type_found = false; // Helper to check not all objects
    auto has_username_sysname = [&](const PlatformType& pl) {
        return pl.get_name() == username.get_system_name();
    };

    /* if (!type_found) */ {
        auto& ds = platform.get_configurations();
        if (std::any_of(ds.begin(), ds.end(), has_username_sysname)) {
            return imc::codegen::Type::Configuration;
        }
    }

    if (!type_found) {
        auto& ds = platform.get_connections();
        if (std::any_of(ds.begin(), ds.end(), has_username_sysname)) {
            return imc::codegen::Type::Connection;
        }
    }

    if (!type_found) {
        auto& ds = platform.get_dations();
        if (std::any_of(ds.begin(), ds.end(), has_username_sysname)) {
            return imc::codegen::Type::Dation;
        }
    }

    if (!type_found) {
        auto& ds = platform.get_interrupts();
        if (std::any_of(ds.begin(), ds.end(), has_username_sysname)) {
            return imc::codegen::Type::Interrupt;
        }
    }

    if (!type_found) {
        auto& ds = platform.get_signals();
        if (std::any_of(ds.begin(), ds.end(), has_username_sysname)) {
            return imc::codegen::Type::Signal;
        }
    }

    ::imc::logger::log::error()
        << "Couldn't deduce type of username: " << username.get_name()
        << std::endl;
    return {};
}

namespace imc {
    namespace codegen {

        optional<ForwardDeclaration> ForwardDeclaration::mk(
                const UserName& username,
                const Platform& platform)
            noexcept
        {
            auto type = find_type(platform, username);
            if (!type) {
                return {};
            }
            return ForwardDeclaration(username, *type);
        }


        optional<InitializationCodeSnippet> InitializationCodeSnippet::mk(
                const UserName& username,
                const Platform& platform)
            noexcept
        {
            auto type = find_type(platform, username);
            if (!type) {
                return {};
            }
            return InitializationCodeSnippet(username, *type);
        }

        bool Codegen::write_out(void) noexcept {
            *this
                << "/* DO NOT CHANGE */" << std::endl
                << "/* generated by inter module checker (IMC) version "
                << VERSION_MAJOR << "." << VERSION_MINOR
                << "*/" << std::endl

                << std::endl
                << std::endl
                << "namespace pearlrt {" << std::endl
                << Indentation(1) << "int createSystemElements();" << std::endl
                << "}" << std::endl
                << "// ensure that the static (parametrized) objects are instanciated first" << std::endl
                << "static int dummy = pearlrt::createSystemElements();" << std::endl
                << std::endl
                << "/* Forward declarations */" << std::endl
                << std::endl
                ;

            // forward declarations
            for (auto& module: this->modules) {
                for (auto& systempart : module.system_parts) {
                    for (auto& username: systempart.usernames) {
                        optional<const ForwardDeclaration> fd = ForwardDeclaration::mk(username, this->platform);
                        if (!fd) {
                            ::imc::logger::log::error()
                                << "Failed to initialize forward declaration in code generator for: "
                                << "'" << username << "'."
                                << std::endl
                                << "This is an internal error. Please report to the compiler vendor! "
                                << std::endl
                                << "Cannot continue."
                                << std::endl;
                            return false;
                        }
                        *this << *fd;
                    }
                }
            }

            *this
                << std::endl
                << std::endl
                << "namespace pearlrt {" << std::endl
                << Indentation(1) << "int createSystemElements() {" << std::endl;


            // Function body
            for (auto& module: this->modules) {
                for (auto& systempart : module.system_parts) {
                    unsigned int number = 0;
                    for (auto& username: systempart.usernames) {
                        auto ics = InitializationCodeSnippet::mk(username, this->platform);
                        if (!ics) {
                            ::imc::logger::log::error()
                                << "Failed to initialize code definition in code generator for: "
                                << "'" << username << "'."
                                << std::endl
                                << "This is an internal error. Please report to the compiler vendor! "
                                << std::endl
                                << "Cannot continue."
                                << std::endl;
                            return false;
                        }
                        number = ics->generate_item_number(number);
                        *this << *ics;
                    }
                }
            }

            *this
                << Indentation(2) << "return 0;" << std::endl
                << Indentation(1) << "}" << std::endl
                << "}" << std::endl;

            return true;
        }

        imc::codegen::Codegen& Codegen::operator<<(const std::string& s) noexcept {
            this->out << s;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(char s)     noexcept {
            this->out << s;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(int i) noexcept {
            this->out << i;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(unsigned int u) noexcept {
            this->out << u;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const char* s)     noexcept {
            this->out << s;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(std::ostream& (*os)(std::ostream&)) noexcept {
            this->out << os;
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const Indentation& ind) noexcept {
            this->out << ind.to_str();
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const ForwardDeclaration& fd) noexcept {
            switch (fd.type) {
                case Type::Signal:
                    this->out
                        << "static pearlrt::" << fd.sysname << " _" << fd.name << ";" << std::endl
                        << "pearlrt::Signal* generalized_" << fd.name << " = &_" << fd.name << ";"
                        << std::endl
                        << std::endl;
                    break;

                case Type::Dation:
                    this->out
                        << "pearlrt::Device* d_" << fd.name << ";" << std::endl;

                    break;

                case Type::Interrupt:
                    this->out
                        << "pearlrt::Interrupt* _" << fd.name << ";" << std::endl;
                    break;

                case Type::Connection:
                    // nothing in original IMC
                    break;

                case Type::Configuration:
                    // nothing in original IMC
                    break;

                default:
                    ::imc::logger::log::error()
                        << "Internal compiler error: Unexpected ForwardDeclaration Type"
                        << std::endl
                        << "This is most likely a BUG."
                        << std::endl;
                    break;
            }

            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const InitializationCodeSnippet& ics) noexcept {
            switch (ics.type) {
                case Type::Signal:
                    // nothing in original IMC
                    break;

                case Type::Dation:
                    *this << Indentation(2)
                        << "static pearlrt::" << ics.sysname << " s_" << ics.name;

                    if (not ics.params.empty()) {
                        *this << "(" << ics.params << ")";
                    }

                    *this
                        << ";" << std::endl
                        << Indentation(2)
                        << "d_" << ics.name << " = &s_" << ics.name << ";" << std::endl;

                    break;

                case Type::Interrupt:
                    *this << Indentation(2)
                        << "static pearlrt::" << ics.sysname << " sys_" << ics.name;

                    if (not ics.params.empty()) {
                        *this << "(" << ics.params << ")";
                    }

                    *this
                        << ";" << std::endl
                        << Indentation(2)
                        << "_" << ics.name << " = (pearlrt::Interrupt*)& sys_" << ics.name << ";" << std::endl
                        << Indentation(2)
                        << "_" << "pearlrt::Interrupt* _" << ics.name << ";" << std::endl;

                    break;

                case Type::Connection:
                    *this
                        << Indentation(2)
                        << "static pearlrt::" << ics.sysname << " s_" << ics.name;

                    if (not ics.params.empty()) {
                        *this << "(" << ics.params << ")";
                    }

                    *this << ";" << std::endl;

                    break;

                case Type::Configuration:
                    *this
                        << Indentation(2)
                        << "static pearlrt::" << ics.sysname << " config" << ics.item_number;

                    if (not ics.params.empty()) {
                        *this << "(" << ics.params << ")";
                    }

                    *this << ";" << std::endl;

                    break;

                default:
                    ::imc::logger::log::error()
                        << "Internal compiler error: Unexpected ForwardDeclaration Type"
                        << std::endl
                        << "This is most likely a BUG."
                        << std::endl;
                    break;
            }

            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const std::vector<ParameterInstance>& vec) noexcept {
            if (vec.size() > 0) {
                for (auto e = vec.begin(); e != (vec.end() - 1); ++e) {
                    *this << *e << ", ";
                }
                *this << vec.back();
            }
            return *this;
        }

        imc::codegen::Codegen& Codegen::operator<<(const ParameterInstance& pi) noexcept {
            switch (pi.get_type()) {
                case ParameterType::Fixed:
                    this->out << pi.get_value();
                    break;

                case ParameterType::Char:
                    // TODO: No sanity checking on pi.value yet
                    this->out << "(char*) \"" << pi.get_value() << "\"";
                    break;

                case ParameterType::Bit: {
                    auto        pi_len = pi.get_computed_length();
                    const int   shift = pi_len - ((pi_len - 1) / 8 + 1) * 8;
                    int         val = 0;

                    auto o_val = util::postfixed_to_int(pi.get_value());
                    if (o_val) {
                        val = *o_val;
                    } else {
                        // TODO
                    }

                    val <<= shift;
                    this->out << (std::string("0x") + util::toHexString(val));
                    break;
                }
            }

            return *this;
        }


    } // codegen
} // imc

