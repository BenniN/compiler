\section{System Overview}
FreeRTOS is used as scheduler. This system was selected, because
\begin{itemize}
\item it provides preemtive priority scheduling
\item it is avaliable on nearly every micro controller system
\item it is available in source code
\end{itemize}

PEARL tasks are mapped on FreeRTOS tasks. The required macros
are provided by \texttt{GenericTask.h}.

The FreeRTOS system has the following disadvantages:
\begin{enumerate}
\item task control blocks and task stack are allocated on the system
   heap on task creation. This may lead to memory fragmentation
\item ... and more ?? ... 
\end{enumerate}


\section{System Architecture}
There are some problems with the linker and \texttt{weak} symbols.
The effect is that \texttt{weak} symbols are not overwritten, if
a corresponding strong symbol resides in a library.
\texttt{weak} symbols are usually used in the interrupt vector table.
This leads to
\begin{enumerate}
\item an object file which contains the interrupt service handlers like
   reset-handler, timer and other device service routines
\item a runtime library with the remaining object files
\end{enumerate}

\subsection{System Initialization}
The system initialization is described in the target specific part.

\subsection{Linkage}
The gcc linker option LTO is used to remove unused functions and data. 
The individual test and application programs are linked together with 
the static library.

\section{Unit Tests}
The linux trunk of the project, which is the main trunk, uses the
goole test framework to run unit tests on nearly all internal classes.
The complete gtest framework is too large to be run on the microcontroller.

A simple test framework, which supports the same syntax as gtest is provided
to run the unit tests on the target system.
The implementation resides in the files\footnote{ugtest stands for $\mu$gtest}

 \verb|ugtests/simpleTests.h| and 
 \verb|ugtests/simpleTests.cc| 

The following elements of gtest are provided:
\begin{description}
\item[TEST] defines a unit test
\item[EXPECT\_EQ] tests, whether the two given parameters are equal, 
   assuming an operator== exists.
\item[EXPECT\_STREQ] tests, whether the two given parameters are equal c string 
\item[EXPECT\_TRUE] tests, whether the  given parameter is non zero. 
\item[EXPECT\_FALSE] tests, whether the  given parameter is zero. 
\item[EXPECT\_THROW] tests, whether the first given expression throws
   an exception of the type as given as  second parameter.
\item[ASSERT\_...] is defined for all listed EXPECT-versions. 
\end{description}

\section{Time Base}
The presence of a real time clock (RTC) is not guaranteed on a
microprocessor system.
This is no big problem for most PEARL applications, since they works 
in many cases with relative times.

FreeRTOS provides a tick based system time. The resolution is specified
in the file \texttt{FreeRTOSConfig.h} --- 
set in OpenPEARL to $1 ms$.

Some applications many require absolute times and more precise timing.
That's the reason why the FreeRTOS provided timers are not used. 
There is an implemtation of the \texttt{itimer} system. This 
implementation allows the specification of a time source.
This system was introduced  by Jonas Meyer in his thesis.

\subsection{class FreeRTOSClock}
The class TaskTimer provides the FreeRTOS tick as
base for itimers.
The absolute time is set to 1.1.2016 0:0:0 at system startup.

Other time sources are plattform specific and described there.

\section{Modification in FreeRTOS}
FreeRTOS was modified in the following points:
\begin{description}
\item[static tcb and stack:]  Normally FreeRTOS places task control blocks (tcb)
   and task stack in the heap storage. This may procude memory fragmentation,
   when application tasks are deleted and restarted in a random sequence.

   A new configuration item in \texttt{FreeRTOSConfig.h}  changes this
   behavior. If \texttt{configUSE\_STATIC\_STACK\_AND\_TCB} is set to 1
   the function \texttt{xTaskCreate} assumes a pointer to a struct with
   pointers to the previous applications parameters and two new pointers
   to the tasks control block (with type \texttt{TCB\_t}) and tasks stack
   (type \texttt{StackEntry\_t *}). The application is expected to be
   responsible to pass valid pointers.
\item[getTaskCurrentFreeStack] is a new function which returns the number
   of free stack element (of size 32 bit) on the current active tasks stack.
   This feature is enabled by the option
    \texttt{INCLUDE\_xTaskGetCurrentFreeStack}
\end{description}

\section{Stack Checking}
The gcc tool chain provides the possibility of code instrumentation
for tracing. The option \texttt{-finstrument-functions} additional
function call at each function entry and exit of the compilation unit.
The corresponding functions must be supplied by the application program.

The signature of the functions is:
\begin{verbatim}
extern "C" {
void __cyg_profile_func_enter(void*this_fn, void* call_site)
     __attribute__((no_instrument_function));

void __cyg_profile_func_exit(void*this_fn, void* call_site)
     __attribute__((no_instrument_function));
};
\end{verbatim}

The configuration option \texttt{CONFIG\_LPC1768\_CHECK\_STACK\_OVERFLOW}
controls the usage of the compiler option and inclusion of the
module \texttt{FreeRTOS/addOns/checkStackOverflow.cc}.


In case of the remaining stack of less than 100 elements (400 bytes), or a
remaining unused size of less than 100 elements wil cause the raising
of the StackOverflowSignal. This signal is intended to be non catchable
by the application program.

\section{Stack Size and Allocation Control}
The build proces checks whether there is a file named \texttt{stacksize.h}
in the current working directory. If this file does not exist it is created
with default settings.
This default file should be modified by the application engineer
to set the desired stack size and location for the PEARL tasks.

To define a PEARL tasks stack size, a C macro must be provided.
If there is no specific macro, the default styk size of the port will be used.
The naming scheme is:
\verb|#define STACK_<taskname> size|, where \texttt{taskname}
must be substutuded by the exact application tasks name. The size
defines the number of steck elements for this task. This size must be larger
than the minimum stack size.
E.g. for the application task \texttt{DisplaySeriel} should have
a stack size of 1000 elements (4kB) the definition would look
like \verb|#define STACK_DisplaySeriel 1000|.

\section{Added Features to FreeRTOS and glib-c}
There are some additional functions in \texttt{FreeRTOS/addOns},
 which supply the toolchain
with UNIX-like time functions like gettimeofday.
\begin{description}
\item[clock.c]provides gettimeofday and some more
\item[timer.c] provides the itimers
\end{description}

Implementation of FreeRTOS Hooks:
\begin{description}
\item[assert.c] provides the implementation of the function
  \texttt{assert()}, which is used in FreeRTOS to verify
  proper operation
\item[FreeRTOSHooks.c] provides some error hooks for stack and head overflow.
\end{description}

\section{Task Mapping}

The task mapping is described in the thesis of
 Florian Mahlecke in detail.

In short:
\begin{itemize}
\item GenericTask.h defines C-macros for task declararion and specification
\item Each PEARL task is derived from the class {\em Task} (\verb|Task.cc|).
      The tasking methods are implemented in \verb|Task.cc|.
\item Each PEARL task implements the method \verb|task(TaskCommon*me)| 
    with the C++ code generated by the compiler.
\item {
  \begin{description}
  \item[class Task] provides the required plattform specific implementation
     of the tasking methods
  \item[class TaskTimer] provides the time related stuff for the tasking
     methods. This class is working on base of the itimer extension 
     in \texttt{FreeRTOS/addOns}
  \item[class PrioMapper] provides a 1:1 mapping of PEARL to FreeRTOS
      priorities
  \end{description}
}
\end{itemize}



\subsection{To be done}
  \begin{itemize}
  \item provide aute restart at task termination
  \item provide device drivers for the standard devices (UART, SD, Ethernet)

  \end{itemize}


