\section{Tasking}


\subsection{Introduction}
The tasking elements of PEARL are mapped on the Posix thread library 
(\verb|pthread|) as far as possible. 
The pthread-library suffers in Linux from the absence of a \verb|suspend|-call.
Usually this is solved by doing a blocking systemcall in a signal handler and
invoke the corresponding signal.
This solutions works fine as long as no \verb|TERMINATE|-request is
issued to a suspended task. This will cause an abnormal program
termination --- terminating all threads. 


\subsection{Task Control Block}
The task control block is represented by the attributes of the 
task-object. 
The task control block contains a Posix-semaphore to realize atomistic
operations on the tasks state variables.
A mutex appeared not to be sufficient, since
Posix mutex do no implicit reschedule in case of blocking and unblocking.
This would disturb the preemptive priority  paradigma of PEARL.

\subsection{TERMINATE suspended Task}
The task state diagram in  fig. \ref{taskStatesOpenPEARL} indicates the states
{\em suspendPending} and {\em termonatePending}.
Suspend and terminate request from other tasks lead to these
 intermediate states.
During the requested tasks progress it calls the method \verb|DO_PENDING| which
finishes the request. This action is performed in the method 
\verb|setLocation(...)|, which is invoked at the beginning of each source line
and at other synchronisation points.


\subsection{SUSPEND behavior}
A task may suspend itself or becomes suspended by another task.

The self suspening is solved by a blocking \verb|read| on a pipe.
When the task should become continued,
 any other task may send the character 'c' onto the pipe.

If the task should become suspended by another task, 
the situation is treated according the current task state.
\begin{description}
\item[RUNNING] the \verb|SUSPEND_PENDING| bit is set and the caller
   is blocked until this bit is recognized by the adressed task.
   The targeted task will be executed with best priority to avoid
   priority inversion.
\item[BLOCKED on Semaphore, Bolt or IOWaitQueue]
   the adressed task is removed from the
   wait queue until it becomes continued. In this case the task is reinserted
   in the according queue.
\item[BLOCKED on I/O] the adressed task is interrupted by a 
   UNIX-signal (\verb|SIG_CANCEL_IO|). This causes the system
   call to become interrupted. This error condition EINTR must 
   be detected by the system device driver, which must invoke the method
   \verb|treatCancelIO()| of the current task. This method suspends 
   the task.
   The targeted task will be executed with best priority for this 
   action to avoid
   priority inversion.
\end{description}

\subsection{TERMINATE behavior}
A task may terminate itself or becomes terminated by another task.

The self termination is just a \verb|pthread_exit()|.
If other task are waiting for a tasking method to finish (e.g. SUSPEND),
they are informed that this is done.

If the task should become suspended by another task, 
the situation is treated according the current task state.
\begin{description}
\item[RUNNING] the \verb|TERMINATE_PENDING| bit is set and the caller
   is blocked until this bit is recognized by the adressed task.
   The targeted task will be executed with best priority to avoid
   priority inversion.
\item[BLOCKED on Semaphore, Bolt or IOWaitQueue]
   the \verb|TERMINATE_PENDING| bit is set,
   the adressed task is removed from the
   wait queue and the task becomes unlocked. 
   The semaphore/bolt/io implementation checks the \verb|TERMINATE_PENDING|
   bit and terminates itself.
\item[BLOCKED on I/O] the adressed task is interrupted by a 
   UNIX-signal (\verb|SIG_CANCEL_IO|). This causes the system
   call to become interrupted. This error condition EINTR must 
   be detected by the device driver, which must invoke the method
   \verb|treatCancelIO()| of the current task. This method emits the 
   exception \verb|TerminationRequestSignal|. This signal must be caught
   the device driver if cleanup actions are required. After cleanup,
   the signal must be emitted again to inform superior layers.
   The targeted task will be executed with best priority to avoid
   priority inversion. 
   The i/o-action finally catches the exception and terminates the task.
\end{description}



\subsection{Scheduled Operations (class TaskTimer)}
The scheduled operations like \verb|AFTER ... ACTIVATE| are realized with
Linux timers and realtime signals. 
The timers provide a start delay and repetition rate. This fits ideal to
the \verb|AFTER ... ALL ...| semantics.
The element \verb|AT| ist translated into \verb|AFTER| with respect of the current
time (\verb|NOW|).
The elements \verb|DURING| and \verb|until| are translated into a repetition 
counter. Each time the timer elapses a realtime signal is emitted.
The signal handler is treated inside the timer thread.
The handler decrements the counter.
When the counter reached 0, the timer will be stopped.

The real-time signals have the advantage that the reception is guaranteed.

There are independent timers for \verb|ACTIVATE|, \verb|CONTINUE| 
and \verb|RESUME|.

\paragraph{Remark:} Subsequent modification of the systems date and time 
will not affect the scheduled operation using \verb|AT| or \verb|UNTIL|.


\subsection{PrioMapper}
The Linux-scheduler {\em SCHED\_RR} supports 100 priorites. PEARL requieres 
256 different priorities.
The module {\em PrioMapper} maps PEARL-priorities to system priorities as good
as possible. The strategy is to map the best priorities in a 1:1 manner and the
worst priority to 99. 
Request with PEARL-priorities, which are not mappable result in a PEARL
signal raising.

The lowest and best priority is needed by the runtime system, thus 98 
priorities are avaiable for the OpenPEARL application.

If a different behavior is desired this module can be replaced or modified.


