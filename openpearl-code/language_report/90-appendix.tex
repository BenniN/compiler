\chapter{Appendix}

% --------
% enable hypertargets for syntax elements
\renewcommand{\htgt}{\htgtOn}

\section{Data Types and their usability}    % A1

The following overview shows for each of the available data types, whether
objects of this type may

\begin{itemize}
\item be summarised to arrays,
\item occur as structure components,
\item be formal procedure parameters,
\item be results of a function procedure,
\item be values of a reference variable,
\item be transmitted to or from data stations,
\item be provided with allocation protection,
\item be global, or
\item be provided with the initialisation attribute.
\end{itemize}

\begin{table}[htb]
\begin{tabular}{lccccccccc}
{\bf type}     & \multicolumn{9}{c}{{\bf usage}} \\ 
               & array & struct. & para- & result & ref.  & dation & INV & GLOBAL & INIT \\ 
               &       &         & meter & type   & value & class  &     &        &      \\ \hline
FIXED          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
FLOAT          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
BIT            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CHAR           & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CLOCK          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
DUR            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
SEMA           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
BOLT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
IRPT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
SIGNAL         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
DATION         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
array          & --    &  x      & x     &  --    &  x    &   --   &  x  &    x   &  x   \\
STRUCT         & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
new type       & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
REF            & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
procedure      & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
TASK           & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
FORMAT         & --    &  --     & --    &  --    &  --   &   --   &  -- &    --  &  --  \\
REF CHAR ( )   & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF PROC       & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF TASK       & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
REF STRUCT [ ] & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
\end{tabular}
\end{table}
                                                                                 
Objects of type SEMA, BOLT, IRPT, SIGNAL, DATION or array may only be 
passed on by means of identification (IDENT) as procedure parameters.

\newpage
\section{Predefined Functions}   % A 2

This appendix describes the functions known to the PEARL compiler. They
can be used in the single modules without specifying them before. If one
of the functions is specified in a module, no object may exist with the
functions' name at module level.

\begin{tobedone}
\subsection{The Function NOW}    % A 2.1

The function procedure NOW passes back the actual time or system time, resp., 
as value of type CLOCK. A specification of the function looks like this:\\

{\bf SPC} NOW {\bf PROC RETURNS ( CLOCK ) GLOBAL} ; 


\subsection{The Function DATE}    % A 2.2

The actual date can be received by invoking the function procedure DATE.
The function result is a character string constant of length 10, containing
the date in the form ``year--month--day''. Here an example for December 5,
1991: ``1991--12-05''. The function can be specified like this:\\

{\bf SPC} DATE {\bf PROC RETURNS ( CHAR(10) ) GLOBAL} ;
\end{tobedone}

\begin{added}
\section{CPP-Insertions}
The language translation is done in two steps.
Step 1 translates PEARL into C++.
Step 2 translates C++ into the plattform specific machine code.

It is possible to insert C++ statements into the generated C++ 
code. The position of the insertion is
\begin{itemize}
\item in system part: {\em not defined yet}
\item on module level in the problem part 
   it is not clearly defined, since the first compilation
   steps adds some information for administration is between.
\item in tasks and procedures just between the output of the surrounding
generated output
\end{itemize}

The syntax is.

CPP\_insertion ::=\\
\x {\bf \_\_cpp\_\_} ( CharacterStringConstant ... );

The CharacterStringConstants are expected in PEARL notation.
Some characters must be marked with the switch symbol as shown in the table
below:

\begin{tabular}{l|l}
C & PEARL \\
\hline
\verb|\| & \verb|\\| \\
\verb|'| & \verb|\'|  \\
\end{tabular}
\end{added}

\newpage
\section{Syntax}    % A 3

Following meta characters are used in the syntax description:\\ 

\begin{tabular}{ll}
meta character & meaning \\ \hline
::=            & introduction of a Name (nonterminal symbol) for a language form\\
$[\ ]$         & bracketing of optional parts of a language form \\ 
$\mid$         & separation of alternative parts of a language form\\
\{ \}          & putting together several elements to a new element\\
$^{...}$       & one or multiple repetition of the preceding element\\
               & (or of several elements bracketed by \{ \} or [ ] ) \\
$\S $          & separates an explaining comment from a language form Name\\
$/^*$ $^*/$    & comment brackets: 
                 includes an explaining text, possibly explaining the\\
               & language form in detail instead of a formal description\\
\end{tabular}

All other elements occurring in the syntax rules are either Names of language
forms or terminal symbols. Examples for terminal symbols are the PEARL
keywords (printed boldly) or the characters semicolon ``;'', opening round
bracket ``('' and closing round bracket ``)'', 
% Klammer auf und zu ???
or the apostrophe `` ' ''; the terminal symbols opening square bracket ``[''
and closing square bracket ``]'' are printed boldly to distinguish them
from the meta symbols for optional parts. Attention: the round brackets are
no meta characters and have thus no grouping effect!\\

The symbol PEARL-Program is the initial symbol of the following syntax
description.

\subsection{Program}    % A 3.1

PEARL-Program ::=\\
\x Module $^{...}$\\

Module ::=\\
\x {\bf MODULE} [ [ ( ] \hlink{Identifier}$\S $OfTheModule [ ) ] ] ;\\
\x \{ \hlink{SystemPart} [ \hlink{ProblemPart} ] 
	$\mid$ \hlink{ProblemPart} \} \\
\x {\bf MODEND} ;

\subsection{System Part}   % A 3.2

\input{SystemPart.bnf}

\input{UserNameDeclaration.bnf}
\input{ConfigurationElement.bnf}
\input{ListOfConstants.bnf}
\input{ConstantParameter.bnf}

\begin{removed}
nngz ::= \\
\x IntegerWithoutPrecision$\S $NonNegative
\end{removed}


\subsection{Basic Elements}    % A 3.3 

\htgt{Digit} ::=\\
\x 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9\\

\htgt{Letter} ::= \\
\x A $\mid$ B $\mid$ C $\mid$ ... $\mid$ Z $\mid$ a $\mid$ b $\mid$ c $\mid$ ... $\mid$ z\\

\htgt{Identifier} ::=\\
\x \hlink{Letter} [ \hlink{Letter} $\mid$ \hlink{Digit} $\mid$ \_ ] $^{...}$\\

\begin{tabbing}
\x $\mid$ \= BitStringConstant \= $\mid$ \= \kill
\htgt{Constant} ::= \> \> \> \\
          \> \hlink{Integer}   \> $\mid$ \> \hlink{FloatingPointNumber}\\
\x $\mid$ \> \hlink{BitStringConstant} \> $\mid$ \> \hlink{CharacterStringConstant}\\
\x $\mid$ \> \hlink{TimeConstant} \> $\mid$ \> \hlink{DurationConstant}\\
\x $\mid$ {\bf NIL} \\

\end{tabbing}

\htgt{Integer} ::=\\
\x \hlink{IntegerWithoutPrecision} [ ( \hlink{Precision} ) ]\\

\htgt{IntegerWithoutPrecision} ::=\\
\x \hlink{Digit} $^{...}$ $\mid$ \{ 0 $\mid$ 1 \} $^{...}$ {\bf B}\\

\htgt{Precision} ::=\\
\x \hlink{IntegerWithoutPrecision}\\

\htgt{FloatingPointNumber} ::=\\
\x \hlink{FloatingPointNumberWithoutPrecision} [ ( \hlink{Precision} ) ]\\

\htgt{FloatingPointNumberWithoutPrecision} ::=\\
\x \{ \hlink{Digit} $^{...}$ . [ \hlink{Digit} $^{...}$ ] $\mid$ . \hlink{Digit} $^{...}$ \} [ \hlink{Exponent} ]\\
\x $\mid$ \hlink{Digit} $^{...}$ \hlink{Exponent}\\

\htgt{Exponent} ::=\\
\x E [ + $\mid$ - ] \hlink{Digit} $^{...}$\\

\htgt{BitStringConstant} ::=\\
\x ' \hlink{B1-Digit} $^{...}$ ' \{ {\bf B} $\mid$ {\bf B}1 \} $\mid$ ' \hlink{B2-Digit} $^{...}$ ' {\bf B}2 $\mid$ ' \hlink{B3-Digit} $^{...}$ ' {\bf B}3 $\mid$ ' \hlink{B4-Digit}$^{...}$ ' {\bf B4}\\

\htgt{B1-Digit} ::= 0 $\mid$ 1\\

\htgt{B2-Digit} ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3\\

\htgt{B3-Digit} ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7\\

\htgt{B4-Digit} ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9 $\mid$ A $\mid$ B $\mid$ C $\mid$ D $\mid$ E $\mid$ F\\

\htgt{CharacterStringConstant} ::=\\
\x ' \{ \hlink{CharacterBesidesApostrophe} $\mid$ '' $\mid$ \hlink{ControlCharacterSequence} \} $^{...}$ '\\

\htgt{CharacterBesidesApostrophe} ::=\\
\x \hlink{Digit} $\mid$ \hlink{Letter} $\mid$ \x $\mid$ \_ $\mid$ + $\mid$ - $\mid$ $^*$ $\mid$ / $\mid$ $\backslash$ $\mid$ ( $\mid$ ) $\mid$ {\bf [} $\mid$ {\bf ]} $\mid$ : $\mid$ . $\mid$ ; $\mid$ , $\mid$ = $\mid$ $<$ $\mid$ $>$ $\mid$ !\\
\x $\mid$ $/^*$ more printable characters of the machine character set $*/$ \\

\htgt{ControlCharacterSequence} ::= \\
\x '$\backslash$ \{ \hlink{B4-Digit} \hlink{B4-Digit} \} $^{...}$ $\backslash$'\\

\htgt{TimeConstant} ::=\\
\x \hlink{Digit} $^{...}$ : \hlink{Digit} $^{...}$ : \hlink{Digit} $^{...}$ [ . \hlink{Digit} $^{...}$ ] \\

\htgt{DurationConstant} ::=\\
\x \hlink{Hours} [ \hlink{Minutes} ] [ \hlink{Seconds} ]\\
\x $\mid$ \hlink{Minutes} [ \hlink{Seconds} ]\\
\x $\mid$ \hlink{Seconds}\\

\htgt{Hours} ::=\\
\x \hlink{IntegerWithoutPrecision} {\bf HRS}\\

\htgt{Minutes} ::=\\
\x \hlink{IntegerWithoutPrecision} {\bf MIN}\\

\htgt{Seconds} ::=\\
\x \{ \hlink{IntegerWithoutPrecision} 
	$\mid$ \hlink{FloatingPointNumberWithoutPrecision} \} {\bf SEC}

\htgt{ConstantExpression} ::=\\
\{ + $\mid$ - \}  \hlink{FloatingPointNumber}\\
\x $\mid$ \{ + $\mid$ - \} \hlink{DurationConstant}\\
\x $\mid$ \hlink{Constant-FIXED-Expression}\\

\htgt{Constant-FIXED-Expression} ::=\\
\x \hlink{Term} [ \{ + $\mid$ - \} \hlink{Term} ] $^{...}$\\
        
\htgt{Term} ::= \\
\x \hlink{Factor} [ \{ $^*$ $\mid$ // $\mid$ {\bf REM} \} \hlink{Factor} ] $^{...}$\\

\htgt{Factor} ::= \\
\x [ + $\mid$ - ] \\
\x \{ \hlink{Integer}\\
\x \x $\mid$ ( \hlink{Constant-FIXED-Expression} )\\
\x \x $\mid$ {\bf TOFIXED} \{ \hlink{CharacterStringConstant}$\S $OfLength1 
	$\mid$ \hlink{BitStringConstant} \}\\
\x \x $\mid$ \hlink{Identifier}$\S $Named-FIXED-Constant\\
\x \} \\
\x [ {\bf FIT} \hlink{Constant-FIXED-Expression} ]

\subsection{Problem Part}   % A 3.4

\htgt{ProblemPart} ::=\\
\x {\bf PROBLEM}; [\{ Declaration $\mid$ Specification $\mid$ Identification \} $^{...}$ ]\\

\subsubsection{Declaration}    % A 3.4.1

\htgt{Declaration} ::=\\
\x \hlink{LengthDefinition} \\
\x $\mid$ \hlink{TypeDefinition}\\
\x $\mid$ \hlink{VariableDeclaration}\\
\x $\mid$ \hlink{FormatDeclaration}\\
\x $\mid$ \hlink{ProcedureDeclaration}\\
\x $\mid$ \hlink{TaskDeclaration}\\
\begin{removed}
\x $\mid$ OperatorDefinition\\
\x $\mid$ PredenceDefinition\\
\end{removed}


\htgt{LengthDefinition} ::=\\
\x {\bf LENGTH} \{ {\bf FIXED $\mid$ FLOAT
                    $\mid$ BIT $\mid$ CHARACTER $\mid$ CHAR} \}
                ( \hlink{Precision} ) ;\\

\htgt{TypeDefinition} ::=\\
\x {\bf TYPE} \hlink{Identifier}$\S $ForType \{ \hlink{SimpleType} $\mid$ \hlink{TypeStructure} \} ;\\

\htgt{VariableDeclaration} ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} \hlink{DeclareSentence} [ , \hlink{DeclareSentence} ] $^{...}$ ;\\
% wie ist "Satz" hier gemeint ???

\htgt{DeclareSentence} ::=\\
\x \hlink{OneIdentifierOrList} [ \hlink{DimensionAttribute} ]\\
\x \{ \hlink{ProblemDataAttribute} $\mid$ \hlink{SemaAttribute} $\mid$ \hlink{BoltAttribute} $\mid$ \hlink{DationAttribute} \}\\ 

\htgt{OneIdentifierOrList} ::= \\
\x \hlink{Identifier} $\mid$ ( \hlink{Identifier} [ , \hlink{Identifier} ] $^{...}$ ) \\

\htgt{DimensionAttribute} ::=\\
\x ( \hlink{DimensionBoundaries} [ , \hlink{DimensionBoundaries} ] $^{...}$ )\\

\htgt{DimensionBoundaries} ::=\\
\x [ \hlink{Constant-FIXED-Expression}$\S $ForLowerBoundary : ]\\
\x \hlink{Constant-FIXED-Expression}$\S $ForUpperBoundary\\
        
\htgt{ProblemDataAttribute} ::=\\
\x [ {\bf INV} ] \{ \hlink{SimpleType} $\mid$ \hlink{StructuredType} 
	$\mid$ \hlink{TypeReference} \}\\
\x [ \hlink{GlobalAttribute} ] [ \hlink{InitialisationAttribute} ]\\

\htgt{SimpleType} ::=\\
\x \{ {\bf FIXED $\mid$ FLOAT $\mid$ BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\
\x \x [ ( \hlink{Constant-FIXED-Expression}$\S $PrecisionResp.Length ) ]\\
\x $\mid$ {\bf CLOCK}\\
\x $\mid$ \{ {\bf DUR $\mid$ DURATION} \}\\

\htgt{StructuredType} ::=\\
\x \hlink{TypeStructure} $\mid$ \hlink{Identifier}$\S $ForNewDefinedType\\

\htgt{TypeStructure} ::=\\
\x {\bf STRUCT [} \hlink{StructureComponent} 
	[ , \hlink{StructureComponent} ] $^{...}$ {\bf ]} \\

\htgt{StructureComponent} ::=\\
\x \hlink{OneIdentifierOrList}$\S $ForStructureComponent 
	[ \hlink{DimensionAttribute} ]\\
\x \hlink{TypeAttributeInStructureComponent}\\

\htgt{TypeAttributeInStructureComponent} ::=\\
\x [ {\bf INV} ] \{ \hlink{SimpleType} $\mid$ 
	\hlink{StructuredType} $\mid$ \hlink{TypeReference} \}\\

\htgt{TypeReference} ::=\\
\x {\bf REF} \\
\x \{ [ \hlink{VirtualDimensionList} ] [ {\bf INV} ] 
	\{ \hlink{SimpleType} $\mid$ \hlink{StructuredType} \}\\
\x \x $\mid$ [ \hlink{VirtualDimensionList} ] 
	\{ \hlink{TypeDation} $\mid$ {\bf SEMA $\mid$ BOLT} \}\\
\x \x $\mid$ \hlink{TypeProcedure} $\mid$ 
	{\bf TASK $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL}\\
\x \x $\mid$ \hlink{Type-VOID} $\mid$ {\bf CHAR}( )\\
\x \}\\

\htgt{VirtualDimensionList} ::=\\
\x ( [ , $^{...}$ ] )\\

\htgt{Type-VOID} ::=\\
\x {\bf STRUCT [ ]} \x $/^*$ only allowed in combination with REF $*/$\\

\htgt{SemaAttribute} ::=\\
\x {\bf SEMA} [ \hlink{GlobalAttribute} ]\\
\x [ {\bf PRESET} ( \hlink{Constant-FIXED-Expression}
	[ , \hlink{Constant-FIXED-Expression} ] $^{...}$ ) ]\\

\htgt{BoltAttribute} ::=\\
\x {\bf BOLT} [ \hlink{GlobalAttribute} ]\\

\htgt{GlobalAttribute} ::=\\
\x {\bf GLOBAL} [ ( \hlink{Indicator}$\S $Module ) ]\\

\htgt{InitialisationAttribute} ::=\\
\x \{ {\bf INITIAL $\mid$ INIT} \} ( \hlink{InitElement} 
	[ , \hlink{InitElement} ] $^{...}$ )\\

\htgt{InitElement} ::=\\
\x \hlink{Constant}\\
\x $\mid$ \hlink{Identifier}$\S $NamedConstant\\
\x $\mid$ \hlink{ConstantExpression}\\

\htgt{DationAttribute} ::=\\
\x \hlink{TypeDation}\\
\x [ \hlink{GlobalAttribute} ]\\
\x {\bf CREATED} ( \hlink{Indicator}$\S $UserNameForSytemDation )\\

\htgt{TypeDation} ::=\\
\x {\bf DATION} \hlink{SourceSinkAttribute}  \hlink{ClassAttribute}\\
\x [ \hlink{Topology} ] [ \hlink{AccessAttribute} ]\\

\htgt{SourceSinkAttribute} ::=\\
\x {\bf IN $\mid$ OUT $\mid$ INOUT}\\

\begin{removed}
ClassAttribute ::= \\
\x {\bf ALPHIC $\mid$ BASIC} $\mid$ TypeOfTransmissionData\\
\end{removed}
\begin{added}
\htgt{ClassAttribute} ::= \\
\x [ {\bf SYSTEM} ]                     /* system dation */\\
\x \x {\bf ALPHIC} $\mid$                  /* PUT/GET */ \\ 
\x \x {\bf BASIC}  \hlink{TypeOfTransmissionData} $\mid$  /* TAKE/SEND */\\
\x \x  \hlink{TypeOfTransmissionData}               /* READ/WRITE */ \\
\end{added}

\htgt{TypeOfTransmissionData} ::=\\
\x {\bf ALL} $\mid$ \hlink{SimpleType} $\mid$ \hlink{Indicator}$\S $ForRedeclaredType $\mid$ \hlink{TypeStructure}\\
\x $/^*$ A Structure as transfer type may not contain any reference variable $*/$\\

\htgt{Topology} ::=\\
\x {\bf DIM} ( \{ $^*$ $\mid$ \hlink{Constant-FIXED-Expression} \}\\
\x \x [ , \{ $^*$ $\mid$ \hlink{Constant-FIXED-Expression} \}\\
\x \x \x [ , \{ $^*$ $\mid$ \hlink{Constant-FIXED-Expression} \} ] ] ) 
\removedtext{[ {\bf TFU} [ {\bf MAX} ] ]}\\
\x $\mid$ {\bf DIM} ( [ , [ , ] ] ) $/^*$ Virtual dimension declaration only permitted for SPC $*/$\\

\htgt{AccessAttribute} ::=\\
\x \{ {\bf DIRECT $\mid$ FORWARD \removedtext{$\mid$ FORBACK}} \}\\
\x [ {\bf NOCYCL $\mid$ CYCLIC} ]\\
\x [ {\bf STREAM $\mid$ NOSTREAM} ]\\

\htgt{FormatDeclaration} ::= \\
\x \hlink{Identifier} : {\bf FORMAT} ( \hlink{FormatOrPosition} [ , \hlink{FormatOrPosition} ] $^{...}$ ) ;\\

\htgt{ProcedureDeclaration} ::=\\
\x \hlink{Identifier} : \{ {\bf PROC $\mid$ PROCEDURE} \} [ \hlink{ListOfFormalParameters} ] \\
\x [ \hlink{ResultAttribute} ] [ \hlink{GlobalAttribute} ] ;\\
\x \x \hlink{ProcedureBody}\\
\x {\bf END};\\

\htgt{ProcedureBody} ::=\\
\x [\{ \hlink{Declaration} $\mid$ \hlink{Identification} \} $^{...}$ ] [ \hlink{Statement} $^{...}$ ] \\

\htgt{ListOfFormalParameters} ::=\\
\x ( \hlink{FormalParameter} [ , \hlink{FormalParameter} ] $^{...}$ )\\
        
\htgt{FormalParameter} ::=\\
\x \hlink{OneIdentifierOrList} [ \hlink{VirtualDimensionList} ]\\
\x \x \hlink{ParameterType} [ {\bf IDENT $\mid$ IDENTICAL} ]\\

\htgt{ParameterType} ::=\\
\x [ {\bf INV} ] \{ \hlink{SimpleType} $\mid$ \hlink{StructuredType} $\mid$ \hlink{TypeReference} \} $\mid$\\   
\x \x \hlink{TypeRealTimeObject} $\mid$ \hlink{TypeDation}\\

\htgt{TypeRealTimeObject} ::=\\   
\x {\bf SEMA $\mid$ BOLT} $\mid$ \{ {\bf INTERRUPT $\mid$ IRPT} \} $\mid$ {\bf SIGNAL}\\   

\htgt{ResultAttribute} ::=\\
\x {\bf RETURNS} ( \hlink{ResultType} )\\

\htgt{ResultType} ::=\\
\x \hlink{SimpleType} $\mid$ \hlink{StructuredType} $\mid$ \hlink{TypeReference}\\

\htgt{TaskDeclaration} ::=\\
\x \hlink{Identifier} : {\bf TASK} [ \hlink{PriorityAttribute} ] [ {\bf MAIN} ]\\
\x [ \hlink{GlobalAttribute} ]  ;\\
\x \x \hlink{TaskBody}\\
\x {\bf END} ;\\

\htgt{TaskBody} ::=\\
\x [\{ \hlink{Declaration} $\mid$ \hlink{Identification} \}$^{...}$] [\hlink{Statement}$^{...}$]
        
\htgt{PriorityAttribute} ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} \hlink{Constant-FIXED-Expression}$\S $GreaterZero\\

\begin{removed}
OperatorDefinition ::= \\
\x {\bf OPERATOR} OpName ( OpParameter [ , OpParameter ] ) \hlink{ResultAttribute} ;\\
\x \x \hlink{ProcedureBody}\\
\x {\bf END} ; \\

OpName ::=\\
\x \hlink{Identifier} $\mid + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid == \mid /= \mid <= \mid >= \mid < \mid > \mid <> \mid ><$\\

OpParameter ::=\\
\x \hlink{Identifier} [ \hlink{VirtualDimensionList} ] \hlink{ParameterType} [ {\bf IDENT $\mid$ IDENTICAL} ] \\

PrecedenceDefinition ::= \\
\x {\bf PRECEDENCE} OpName ( \{ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 \} ) ;
\end{removed}

\subsection{Specification and Identification}    % A 3.4.2

\htgt{Specification} ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY} \} \hlink{SpecificationDefinition} [ , \hlink{SpecificationDefinition} ] $^{...}$ ;\\

\htgt{SpecificationDefinition} ::=\\
\x \hlink{OneIdentifierOrList}\\
\x \{ \hlink{SpecificationAttribute} $\mid$ \hlink{ProcedureUsageAttribute} $\mid$ \hlink{TaskUsageAttribute} \}\\

\htgt{SpecificationAttribute} ::=\\
\x [ \hlink{VirtualDimensionList} ] \\
\x \{ [ {\bf INV} ] \{ \hlink{SimpleType} $\mid$ 
	\hlink{StructuredType} $\mid$
	\hlink{TypeReference} \} \\
\x \x $\mid$ {\bf SEMA $\mid$ BOLT $\mid$ 
	INTERRUPT $\mid$ IRPT $\mid$ SIGNAL} 
	$\mid$ \hlink{TypeDation}\\
\x \}\\
\x [ \hlink{GlobalAttribute} ]\\

\htgt{ProcedureUsageAttribute} ::=\\
\x \{ {\bf ENTRY} $\mid$ [ : ] {\bf PROC} \} [ 
	\hlink{ParameterListFor-SPC} ] [ \hlink{ResultAttribute} ] \\
\x \x \hlink{GlobalAttribute}\\

\htgt{ParameterListFor-SPC} ::=\\
\x ( \hlink{FormalParameterFor-SPC} 
	[ , \hlink{FormalParameterFor-SPC} ] $^{...}$ )\\
        
\htgt{FormalParameterFor-SPC} ::=\\
\x [ \hlink{Identifier}$\S $OnlyForDocumentation ] 
	[ \hlink{VirtualDimensionList} ]\\
\x \hlink{ParameterType} [ {\bf IDENTICAL $\mid$ IDENT} ]\\

\htgt{TypeProcedure} ::=\\
\x {\bf PROC} [ \hlink{ParameterListFor-SPC} ]
	 [ \hlink{ResultAttribute} ] $/^*$ for REF PROC $*/$\\

\htgt{TaskUsageAttribute} ::=\\
\x {\bf TASK} \hlink{GlobalAttribute}\\

\htgt{Identification} ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY}\} \hlink{Identifier} 
	[ {\bf INV} ] \hlink{Type} \hlink{IdentificationAttribute} ;\\

\begin{tobedone}
Type must become defined 
\end{tobedone}

\htgt{IdentificationAttribute} ::= \\
\x {\bf IDENT} ( \hlink{Name}$\S $Object )\\

\subsection{Expressions}    % A 3.4.3

\htgt{Expression} ::=\\
\x [ \hlink{MonadicOperator} ] \hlink{Operand} [ \hlink{DyadicOperator}   \hlink{Expression} ] $^{...}$\\

\htgt{MonadicOperator} ::=\\
\x + $\mid$ - $\mid$ \hlink{Identifier}$\S $MonadicOperator\\

\htgt{DyadicOperator} ::=\\
\x $ + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid < \mid > \mid <= \mid >= \mid == \mid /= \mid >< \mid <> \mid$\\
\x \hlink{Identifier}$\S $DyadicOperator\\

\htgt{Operand} ::= \\
\x \hlink{Constant} $\mid$ \hlink{Name} $\mid$ \hlink{FunctionCall} $\mid$ \hlink{ConditionalExpression}\\
\x $\mid$ \hlink{Dereferentiation} $\mid$ \hlink{StringSelection} $\mid$ ( \hlink{Expression} ) $\mid$ ( \hlink{Assignment} ) \\
\x $\mid$ {\bf PRIO} [ ( \hlink{Name}$\S $Task ) ] $\mid$ {\bf TASK} [ ( \hlink{Name}$\S $Task ) ] $\mid$ {\bf TRY} \hlink{Name}$\S $Sema\\

\htgt{Name} ::=\\
\x \hlink{Identifier} [ ( \hlink{Index} [ , \hlink{Index} ] $^{...}$ ) ] [ . \hlink{Name} ]\\

\htgt{Index} ::=\\
\x \hlink{Expression}$\S $WithIntegerAsValue\\

\htgt{FunctionCall} ::=\\
\x \hlink{Identifier}$\S $FunctionProcedure [ \hlink{ListOfActualParameters} ]\\

\htgt{ListOfActualParameters} ::= \\
\x ( \hlink{Expression} [ , \hlink{Expression} ] $^{...}$ )\\

\htgt{ConditionalExpression} ::=\\
\x {\bf IF} \hlink{Expression}$\S $OfType-BIT(1) {\bf THEN} \hlink{Expression} {\bf ELSE} \hlink{Expression} {\bf FIN}\\

\htgt{Dereferentiation} ::=\\
\x {\bf CONT} \{ \hlink{Name}$\S $Reference $\mid$ \hlink{FunctionCall} \}\\

\htgt{StringSelection} ::=\\
\x \hlink{Name}$\S $String . \{ {\bf BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\ 
\x ( \{ \hlink{Constant-FIXED-Expression} [ : \hlink{Constant-FIXED-Expression} ]\\
\x \x $\mid$ \hlink{Expression} [ : \hlink{Expression} + \hlink{Constant-FIXED-Expression} ]\\
\x \x $\mid$ \hlink{Expression} [ : \hlink{Expression} ] \} )\\

\subsection{Statements}    % A 3.4.4

\htgt{Statement} ::=\\
\x [ \hlink{Identifier}$\S $Label : ] $^{...}$ \hlink{UnlabelledStatement}\\

\htgt{UnlabelledStatement} ::=\\
\x \hlink{EmptyStatement} $\mid$ \hlink{Assignment} $\mid$ \hlink{Block} $\mid$ \hlink{SequentialControlStatement}\\
\x $\mid$ \hlink{RealTimeStatement} $\mid$ \hlink{ConvertStatement} $\mid$ \hlink{I/O-Statement}\\

\htgt{EmptyStatement} ::=\\
\x ;\\

\htgt{Assignment} ::=\\
\x \{ \{ \hlink{Name}$\S $Variable $\mid$ \hlink{Dereferentiation} $\mid$ \hlink{StringSelection} $\mid$ 
\hlink{Name}$\S $Structure \}\\   
\x \{ := $\mid$ = \} \} $^{...}$ \hlink{Expression} ;\\

\htgt{Block} ::= \\
\x {\bf BEGIN}\\
\x \x [\{ \hlink{Declaration} $\mid$ \hlink{Identification} \}$^{...}$ ]\\ 
\x \x [ \hlink{Statement} $^{...}$ ] \\
\x {\bf END} [ \hlink{Identifier}$\S $Block ] ;\\

\htgt{SequentialControlStatement} ::=\\
\x \hlink{IfStatement} $\mid$ \hlink{CaseStatement} $\mid$ \hlink{LoopStatement} $\mid$ \hlink{ExitStatement}\\
\x $\mid$ \hlink{ProcedureCall} $\mid$ \hlink{ReturnStatement} $\mid$ \hlink{GoToStatement}\\

\htgt{IfStatement} ::=\\
\x {\bf IF} \hlink{Expression}$\S $OfType-BIT(1)\\
\x \x {\bf THEN} [ \hlink{Statement} $^{...}$ ]\\ 
\x \x [ {\bf ELSE} [ \hlink{Statement} $^{...}$ ] ]\\
\x {\bf FIN} ;\\

\htgt{CaseStatement} ::=\\
\x \hlink{CaseStatement1} $\mid$ \hlink{CaseStatement2}\\

\htgt{CaseStatement1} ::=\\
\x {\bf CASE} \hlink{Expression}$\S $WithIntegerAsValue\\
\x \x \{ {\bf ALT} [ \hlink{Statement} $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ \hlink{Statement} $^{...}$ ] ]\\
\x {\bf FIN} ;\\

\htgt{CaseStatement2} ::=\\
\x {\bf CASE} \hlink{CaseIndex}\\
\x \x \{ {\bf ALT} ( \hlink{CaseList} ) [ \hlink{Statement} $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ \hlink{Statement} $^{...}$ ] ]\\
\x {\bf FIN} ;\\

\htgt{CaseIndex} ::=\\
\x \hlink{Expression}$\S $WithValueOfType-FIXED-Or-CHAR(1)\\

\htgt{CaseList} ::=\\
\x \hlink{IndexSection} [ , \hlink{IndexSection} ] $^{...}$\\

\htgt{IndexSection}::=\\
\x \hlink{Constant-FIXED-Expression} [ : \hlink{Constant-FIXED-Expression} ]\\
\x $\mid$ \hlink{CharacterStringConstant}$\S $OfLength1 [ : \hlink{CharacterStringConstant}$\S $OfLength1 ]\\

\htgt{LoopStatement} ::=\\
\x [ {\bf FOR} \hlink{Indicator}$\S $ControlVariable ]\\
\x [ {\bf FROM} \hlink{Expression}$\S $InitialValue ]\\
\x [ {\bf BY} \hlink{Expression}$\S $StepLength ]\\
\x [ {\bf TO} \hlink{Expression}$\S $EndValue ]\\
\x [ {\bf WHILE} \hlink{Expression}$\S $Condition ]\\
\x {\bf REPEAT}\\
\x \x [\{ \hlink{Declaration} $\mid$ \hlink{Identification} \}$^{...}$ ]\\ 
\x \x [ \hlink{Statement} $^{...}$ ] \\
\x {\bf END} [ \hlink{Identifier}$\S $Loop ] ;\\
        
\htgt{ExitStatement} ::=\\
\x {\bf EXIT} [ \hlink{Identifier}$\S $BlockOrLoop ] ;\\

\htgt{ProcedureCall} ::= \\
\x [ {\bf CALL} ] \hlink{Name}$\S $SubprogramProcedure [ \hlink{ListOfActualParameters} ] ;\\

\htgt{ReturnStatement} ::= \\
\x {\bf RETURN} [ ( \hlink{Expression} ) ] ;\\

\htgt{GoToStatement} ::= \\
\x {\bf GOTO} \hlink{Identifier}$\S $Label ; \\

\htgt{RealTimeStatement} ::=\\
\x \hlink{TaskControlStatement} $\mid$ \hlink{TaskCoordinationStatement}\\
\x $\mid$ \hlink{InterruptStatement} $\mid$ \hlink{SignalStatement}\\

\htgt{TaskControlStatement} ::=\\
\x \hlink{TaskStarting} $\mid$ \hlink{TaskTerminating}\\             
\x $\mid$ \hlink{TaskSuspending} $\mid$ \hlink{TaskContinuing}\\   
\x $\mid$ \hlink{TaskResuming} $\mid$ \hlink{TaskPreventing}\\

\htgt{TaskStarting} ::=\\
\x [ \hlink{StartCondition} ] {\bf ACTIVATE} \hlink{Name}$\S $Task [ \hlink{PriorityExpression} ] ;\\

\htgt{PriorityExpression} ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} \hlink{Expression}$\S $PositiveInteger\\

\htgt{StartCondition} ::=\\
\x {\bf AT} \hlink{Expression}$\S $Time [ \hlink{Frequency} ]\\
\x $\mid$ {\bf AFTER} \hlink{Expression}$\S $Duration [ \hlink{Frequency} ]\\
\x $\mid$ {\bf WHEN} \hlink{Name}$\S $Interrupt [ {\bf AFTER} \hlink{Expression}$\S $Duration ] [ \hlink{Frequency} ] \\
\x $\mid$ \hlink{Frequency}\\

\htgt{Frequency} ::=\\
\x {\bf ALL} \hlink{Expression}$\S $Duration\\
\x [ \{ {\bf UNTIL} \hlink{Expression}$\S $Time \} $\mid$ \{ {\bf DURING} \hlink{Expression}$\S $Duration \} ]\\

\htgt{TaskTerminating} ::=\\
\x {\bf TERMINATE} [ \hlink{Name}$\S $Task ] ; \\

\htgt{TaskSuspending} ::=\\
\x {\bf SUSPEND} [ \hlink{Name}$\S $Task ] ;\\

\htgt{TaskContinuing} ::=\\
\x [ {\bf AT} \hlink{Expression}$\S $Time $\mid$ {\bf AFTER} \hlink{Expression}$\S $Duration $\mid$ {\bf WHEN} \hlink{Name}$\S $Interrupt ]\\
\x {\bf CONTINUE} [ \hlink{Name}$\S $Task ] [ \hlink{PriorityAttribute} ] ;\\

\htgt{TaskResuming} ::=\\
\x \{ {\bf AT} \hlink{Expression}$\S $Time $\mid$ {\bf AFTER} \hlink{Expression}$\S $Duration $\mid$ {\bf WHEN} \hlink{Name}$\S $Interrupt \}\\
\x {\bf RESUME;}\\        

\htgt{TaskPreventing} ::=\\
\x {\bf PREVENT} [ \hlink{Name}$\S $Task ] ;\\

\htgt{TaskCoordinationStatement} ::=\\
\x \{ {\bf REQUEST $\mid$ RELEASE}\} \hlink{Name}$\S $Sema [ , \hlink{Name}$\S $Sema ] $^{...}$ ;\\
\x $\mid$ \{ {\bf RESERVE $\mid$ FREE $\mid$ ENTER $\mid$ LEAVE} \} \hlink{Name}$\S $Bolt [ , \hlink{Name}$\S $Bolt ] $^{...}$ ;\\


\htgt{InterruptStatement} ::=\\
\x \{ {\bf ENABLE $\mid$ DISABLE $\mid$ TRIGGER} \} \hlink{Name}$\S $Interrupt ;\\

\begin{removed}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal \{ [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction $\mid$ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) \};\\

SignalReaction::= UnlabeledStatement\\

InduceStatement ::=\\
\x {\bf INDUCE} Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber-FIXED ) ] ;\\
\end{removed}

\begin{added}
\htgt{SignalStatement} ::=\\
\x {\bf ON} \hlink{Name}$\S $Signal [ {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED ) ] :\\
\x \x \hlink{SignalReaction} ;

\htgt{SignalFinalStatement} ::= \\
\x \hlink{ReturnStatement} $\mid$ \\
\x \hlink{GoToStatement} $\mid$ \\
\x \hlink{InduceStatement} $\mid$ \\
\x {\bf TERMINATE} ;

\htgt{SignalReaction} ::=\\
\x \hlink{SignalFinalStatement} $\mid$ \\
\x \hlink{Block}$\S $terminatedWithSignalFinalStatement ;

\htgt{InduceStatement} ::=\\
\x {\bf INDUCE} [ \hlink{Name}$\S $Signal [ {\bf RST} ( \hlink{Expression}$\S $ErrorNumber-FIXED ) ] ] ;\\
\end{added}

\htgt{ConvertStatement} ::=\\
\x \hlink{ConvertToStatement} $\mid$ \hlink{ConvertFromStatement}\\

\htgt{ConvertToStatement} ::= \\
\x {\bf CONVERT} \hlink{Expression} [ , \hlink{Expression} ] $^{...}$ {\bf TO} \hlink{Name}$\S $CharacterStringVariable\\
\x [ {\bf BY} \hlink{FormatOrPositionConvert} [ , \hlink{FormatOrPositionConvert} ] $^{...}$ ] ;\\

\htgt{ConvertFromStatement} ::=\\
\x {\bf CONVERT} \hlink{Name}$\S $Variable [ , \hlink{Name}$\S $Variable ] $^{...}$ {\bf FROM} \hlink{Expression}$\S $CharacterString\\
\x [ {\bf BY} \hlink{FormatOrPositionConvert} [ , \hlink{FormatOrPositionConvert} ] $^{...}$ ] ;\\

\htgt{FormatOrPositionConvert} ::= \\
\x [ \hlink{FormatFactor} ] \{ \hlink{Format} $\mid$ \hlink{PositionConvert} \}\\
\x $\mid$ \hlink{FormatFactor} ( \hlink{FormatOrPositionConvert} [ , \hlink{FormatOrPositionConvert} ] $^{...}$ )\\

\htgt{PositionConvert} ::= \\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf X} [ ( \hlink{Expression} ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( \hlink{Expression} )\\
\x $\mid$ {\bf SOP} ( \hlink{Name}$\S $PositionVariable-FIXED )\\

\htgt{I/O-Statement} ::=\\
\x \hlink{OpenStatement} $\mid$ \hlink{CloseStatement}\\
\x $\mid$ \hlink{PutStatement} $\mid$ \hlink{GetStatement}\\
\x $\mid$ \hlink{WriteStatement} $\mid$ \hlink{ReadStatement}\\
\x $\mid$ \hlink{SendStatement} $\mid$ \hlink{TakeStatement}\\
         
\htgt{OpenStatement} ::=\\
\x {\bf OPEN} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{OpenParameter} [ , \hlink{OpenParameter} ] $^{...}$ ] ;\\

\htgt{OpenParameter} ::=\\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf IDF} ( \{ \hlink{Name}$\S $CharacterStringVariable $\mid$ \hlink{CharacterStringConstant} \} )\\
\x $\mid$ \{ {\bf OLD $\mid$ NEW $\mid$ ANY} \}\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

\htgt{CloseStatement} ::=\\ 
\x {\bf CLOSE} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{CloseParameter} [ , \hlink{CloseParameter} ] $^{...}$ ] ;\\

\htgt{CloseParameter} ::=\\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

\htgt{PutStatement} ::=\\
\x {\bf PUT} [ \{ \hlink{Expression} $\mid$ \hlink{Slice} \} [ , \{ \hlink{Expression} $\mid$ \hlink{Slice} \} ] $^{...}$ ]\\
\x {\bf TO} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{FormatOrPosition} [ , \hlink{FormatOrPosition} ] $^{...}$ ] ;\\

\htgt{GetStatement} ::=\\
\x {\bf GET} [ \{ \hlink{Name} $\mid$ \hlink{Slice} \} [ , \{ \hlink{Name} $\mid$ \hlink{Slice} \} ] $^{...}$ ]\\
\x {\bf FROM} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{FormatOrPosition} [ , \hlink{FormatOrPosition} ] $^{...}$ ] ;\\

\htgt{WriteStatement} ::=\\
\x {\bf WRITE} [ \{ \hlink{Expression} $\mid$ \hlink{Slice} \} [ , \{ \hlink{Expression} $\mid$ \hlink{Slice} \} ] $^{...}$ ]\\
\x {\bf TO} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{Position} [ , \hlink{Position} ] $^{...}$ ] ; \\
        
\htgt{ReadStatement} ::=\\
\x {\bf READ} [ \{ \hlink{Name} $\mid$ \hlink{Slice} \} [ , \{ \hlink{Name} $\mid$ \hlink{Slice} \} ] $^{...}$ ]\\
\x {\bf FROM} \hlink{Name}$\S $Dation [ {\bf BY} \hlink{Position} [ , \hlink{Position} ] $^{...}$ ] ;\\
        
\begin{removed}
SendStatement ::=\\
\x {\bf SEND} [ \hlink{Expression} ] {\bf TO} \hlink{Name}$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

TakeStatement ::=\\
\x {\bf TAKE} [ \hlink{Name} ] {\bf FROM} \hlink{Name}$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

RST-S-CTRL-Format ::=\\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf S} ( \hlink{Name}$\S $Variable-FIXED )\\
\x $\mid$ {\bf CONTROL} ( \hlink{Expression} [ , \hlink{Expression} [ , \hlink{Expression} ] ] )\\
\end{removed}

\begin{added}
\htgt{SendStatement} ::=\\
\x {\bf SEND} [ \hlink{Expression} ] {\bf TO} \hlink{Name}$\S $Dation\\
\x [ {\bf BY} \hlink{RST-Format} ] ;\\

\htgt{TakeStatement} ::=\\
\x {\bf TAKE} [ \hlink{Name} ] {\bf FROM} \hlink{Name}$\S $Dation\\
\x [ {\bf BY} \hlink{RST-Format} ] ;\\

\htgt{RST-Format} ::=\\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\end{added}

\htgt{Slice} ::=\\
\x \hlink{Name}$\S $Array ( [ \hlink{Index} , ] $^{...}$ \hlink{Index} : \hlink{Index} )\\
\x $/^*$ Instead of the last array-index an index-slice is given to address 
the respective one-dimensional array-slice which is processed by the I/O 
in bottom-up order. $*/$\\

\htgt{FormatOrPosition} ::=\\
\x [ \hlink{FormatFactor} ] \{ \hlink{Format} $\mid$ \hlink{Position} \}\\
\x $\mid$ \hlink{FormatFactor} ( \hlink{FormatOrPosition} [ , \hlink{FormatOrPosition} ] $^{...}$ )\\
      
\begin{removed}  
Factor ::=\\
\x ( \hlink{Expression}$\S $IntegerGreaterZero ) $\mid$ \hlink{IntegerWithoutPrecision}$\S $GreaterZero\\

.. and sustituted Factor by FormatFactor in Convert and Put/GET statements
\end{removed}  
\begin{added}  
\htgt{FormatFactor} ::=\\
\x ( \hlink{Expression}$\S $IntegerGreaterZero ) $\mid$ \hlink{IntegerWithoutPrecision}$\S $GreaterZero\\
\end{added}  

\htgt{Format} ::=\\
\x \{ {\bf F $\mid$ E \addedtext{$\mid$ E3 }\} ( \hlink{Expression} [ , \hlink{Expression} [ , \hlink{Expression} ] ] ) \\
\x $\mid$ \{ {\bf B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4 $\mid$ A} \} [ ( \hlink{Expression} ) ]\\
\x $\mid$ \{ {\bf T $\mid$ D} \} ( \hlink{Expression} [ , \hlink{Expression} ] )\\
\x $\mid$ {\bf LIST}\\
\x $\mid$ {\bf R} ( \hlink{Identifier}$\S $Format )\\
\begin{removed}
\x $\mid$ {\bf S} ( \hlink{Name}$\S $LengthVariable-FIXED )\\
\end{removed}

\htgt{Position} ::=\\
\x {\bf RST} ( \hlink{Name}$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf X $\mid$ SKIP $\mid$ PAGE} \} [ ( \hlink{Expression} ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( \hlink{Expression} [ , \hlink{Expression} [ , \hlink{Expression} ] ] )\\
\x $\mid$ \{ {\bf COL $\mid$ LINE} \} ( \hlink{Expression} )\\
\x $\mid$ {\bf SOP} ( \hlink{Name} [ , \hlink{Name} [ , \hlink{Name} ] ]  $/^*$ PositionVariables-FIXED $^*/$ )\\

\twocolumn[\section{List of Keywords with Shortforms}   % A 4

The denotation behind the keyword refers to the paragraph where it
is introduced.\\]

{
{\bf ACTIVATE} 9.2.2\\
{\bf AFTER} 9.2.1\\
{\bf ALL} 9.2.1\\
{\bf ALPHIC} \ref{sec_dation_problem_part}\\
{\bf ALT} 7.2\\
{\bf AT} 9.2.1\\

{\bf BASIC} \ref{sec_dation_problem_part}\\
{\bf BEGIN} 4.4 \\
{\bf BIT} 5.4\\
{\bf BOLT} 9.3.2\\
{\bf BY} 7.3, \ref{sec_open_close}\\

{\bf CALL} 8.2\\
{\bf CASE} 7.2\\
{\bf CHARACTER}, {\bf CHAR} 5.5\\
{\bf CLOCK} 5.7\\
{\bf CLOSE} \ref{sec_open_close}\\
{\bf CONT} 5.9\\
{\bf CONTINUE} 9.2.5\\
{\bf CONTROL} \ref{sec_dation_problem_part}\\
{\bf CONVERT} \ref{sec_dation_problem_part}\\
{\bf CREATED} \ref{sec_dation_problem_part}\\
{\bf CYCLIC} \ref{sec_dation_problem_part}\\
 
{\bf DATION} \ref{sec_dation_problem_part}\\
{\bf DECLARE}, {\bf DCL} 4.1\\
{\bf DIM} \ref{sec_dation_problem_part}\\
{\bf DIRECT} \ref{sec_dation_problem_part}\\
{\bf DISABLE} 9.4.2\\
{\bf DURATION}, {\bf DUR} 5.8\\
{\bf DURING} 9.2.1\\

{\bf ELSE} 7.1\\
{\bf ENABLE} 9.4.2\\
{\bf END} 4.4, 8.1, 9.1\\
{\bf ENTER} 9.3.2\\
{\bf ENTRY} 8.1\\
{\bf EXIT} 7.5\\

{\bf FIN} 7.1\\
{\bf FIXED} 5.2\\
{\bf FLOAT} 5.3\\
{\bf FOR} 7.3\\
{\bf FORBACK} \ref{sec_dation_problem_part}\\
{\bf FORMAT} 10.5.8\\
{\bf FORWARD} \ref{sec_dation_problem_part}\\
{\bf FREE} 9.3.2\\
{\bf FROM} 7.3, \ref{sec_read_write}\\
 
{\bf GET} \ref{sec_get_put}\\
{\bf GLOBAL} 4.1\\
{\bf GOTO} 7.4\\
 
{\bf HRS} 5.8\\
 
{\bf IDENTICAL}, {\bf IDENT} 4.1, 8.1\\
{\bf IF} 7.1\\                           
{\bf IN} \ref{sec_dation_problem_part}\\
{\bf INDUCE} 11\\
{\bf INITIAL}, {\bf INIT} 5.14\\
{\bf INOUT} \ref{sec_dation_problem_part}\\
{\bf INTERRUPT}, {\bf IRPT} 9.4.1\\
{\bf INV} 5.15\\
 
{\bf LEAVE} 9.3.2\\
{\bf LENGTH} 5.6\\
 
{\bf MAIN} 9.1\\
{\bf MAX} \ref{sec_dation_problem_part}\\
{\bf MIN} 5.8\\
{\bf MODEND} 4.1\\
{\bf MODULE} 4.1\\
 
{\bf NIL} 5.9\\
{\bf NOCYCL} \ref{sec_dation_problem_part}\\
{\bf NOSTREAM} \ref{sec_dation_problem_part}\\

{\bf ON} 11\\
{\bf OPEN} 10.3\\
{\bf OPERATOR} 6.2\\
{\bf OUT} 7.2, \ref{sec_dation_problem_part}\\
 
{\bf PRECEDENCE} 7.2\\
{\bf PRESET} 9.3.1\\
{\bf PREVENT} 9.2.7\\
{\bf PRIORITY}, {\bf PRIO} 9.1\\
{\bf PROBLEM} 4.3\\
{\bf PROCEDURE}, {\bf PROC} 8.1\\
{\bf PUT} \ref{sec_get_put}\\

{\bf READ} \ref{sec_dation_read_write}\\
{\bf REF} 5.9\\
{\bf RELEASE} 9.3.1\\
{\bf REPEAT} 7.3\\
{\bf REQUEST} 9.3.1\\
{\bf RESERVE} 9.3.2\\
{\bf RESUME} 9.2.6\\
{\bf RETURN} 8.2\\
{\bf RETURNS} 8.1\\
 
{\bf SEC} 5.8\\
{\bf SEMA} 9.3.1\\
{\bf SEND} \ref{sec_dation_take_send}\\
{\bf SIGNAL} 11\\
{\bf SPECIFY}, {\bf SPC} 4.1\\
{\bf STREAM} \ref{sec_dation_problem_part}\\
{\bf STRUCT} 5.11\\
{\bf SUSPEND} 9.2.4\\
{\bf SYSTEM} 4.2\\
 
{\bf TAKE} \ref{sec_dation_take_send}\\
{\bf TASK} 9.1\\
{\bf TERMINATE} 9.2.3\\
{\bf TFU} \ref{sec_dation_problem_part}\\
{\bf THEN} 7.1\\
{\bf TO} 7.3, \ref{sec_dation_read_write}\\
{\bf TRIGGER} 9.4.2\\
{\bf TYPE} 5.12\\
 
{\bf UNTIL} 9.2.1\\
 
{\bf WHEN} 9.2.1\\
{\bf WHILE} 7.3\\
{\bf WRITE} \ref{sec_dation_read_write}\\
}
\onecolumn

\twocolumn[\section{Other Word Symbols in PEARL}    % A 5

The denotation behind the word symbol refers to the paragraph where it
is introduced.\\]

{
{\bf A} \ref{sec_dation_a_format}\\
{\bf ABS} 6.1.1\\
{\bf ADV} \ref{sec_dation_read_write}\\
{\bf AND} 6.1.2\\
{\bf ANY} \ref{sec_dation_open_close}\\
{\bf ATAN} 6.1.1\\

{\bf B} \ref{sec_dation_b_format}\\
{\bf B1} \ref{sec_dation_b_format}\\
{\bf B2} \ref{sec_dation_b_format}\\
{\bf B3} \ref{sec_dation_b_format}\\
{\bf B4} \ref{sec_dation_b_format}\\

{\bf CAN} \ref{sec_dation_open_close}\\
{\bf CAT} 6.1.2\\
{\bf COL} \ref{sed_dation_read_write}\\
{\bf CONT} 5.9\\
{\bf COS} 6.1.1\\
{\bf CSHIFT} 6.1.2\\
 
{\bf D} \ref{sec_dation_d_format}\\
{\bf DATE} A2.2\\
 
{\bf E} \ref{sec_dation_e_format}\\
{\bf ENTIER} 6.1.1\\
{\bf EQ} 6.1.2\\
{\bf EXOR} 6.1.2\\
{\bf EXP} 6.1.1\\
 
{\bf F} \ref{sec_dation_f_format}\\
{\bf FIT} 6.1.2\\
 
{\bf GE} 6.1.2\\
{\bf GT} 6.1.2\\
 
{\bf IDF} \ref{sec_dation_open_close}\\
{\bf IS} 5.9\\
{\bf ISNT} 5.9\\

 
{\bf LE} 6.1.2\\
{\bf LINE} \ref{sec_dation_read_write}\\
{\bf LIST} \ref{sec_dation_listformat}\\
{\bf LN} 6.1.1\\
{\bf LT} 6.1.2\\
{\bf LWB} 6.1.1, 6.1.2\\
 
{\bf NE} 6.1.2\\
{\bf NEW} \ref{sec_dation_open_close}\\
{\bf NOT} 6.1.1\\
{\bf NOW} A2.1\\
 
{\bf OLD} 10.3\\
{\bf OR} 6.1.2\\
 
{\bf PAGE} \ref{sec_dation_read_write}\\
{\bf POS} \ref{sec_dation_read_write}\\
{\bf PRM} \ref{sec_dation_open_close}\\
 
{\bf R} \ref{sec_dation_r_format}\\
{\bf REM} 6.1.2\\
{\bf ROUND} 6.1.1\\
{\bf RST} \ref{sec_dation_open_close}, \ref{sec_dation_rst} \\
 
{\bf S} \ref{sec_dation_a_format}\\
{\bf SHIFT} 6.1\\
{\bf SIGN} 6.1.1\\
{\bf SIN} 6.1.1\\
{\bf SIZEOF} 6.1\\
{\bf SKIP} \ref{sec_dation_read_write} \\
{\bf SOP}  \ref{sec_dation_read_write}\\
{\bf SQRT} 6.1.1\\
 
{\bf T} \ref{sec_dation_t_format}\\
{\bf TAN} 6.1.1\\
{\bf TANH} 6.1.1\\
{\bf TOBIT} 6.1.1\\
{\bf TOCHAR} 6.1.1\\
{\bf TOFIXED} 6.1.1\\
{\bf TOFLOAT} 6.1.1\\
{\bf TRY} 9.3.1\\
 
{\bf UPB} 6.1.1, 6.1.2\\

{\bf X} \ref{sec_dation_read_write}
}

