\documentclass{book}
\usepackage{geometry}  % paper size
\geometry{a4paper}     % -"-
\usepackage[color]{changebar} % use side change bars
%\usepackage{color}  % use color marks
% note: tcolorbox is required in the version from 2014
%       the usual tex packages from the linux distributions
%       are known to be too old (r. mueller: 28-dec-2014)
\usepackage[skins,breakable]{tcolorbox}  
\tcbuselibrary{breakable}

\usepackage[pdftex]{hyperref}

%\textwidth16cm
%\textheight24cm
%\oddsidemargin1cm
%\evensidemargin1cm
% \topmargin1cm
% DIN-A4: 29,6 cm Hoehe: 29,6-24=5,6 = 2,8 oeb + 2,8 unten
% => topmargin = 2,54 + 0,26
%\topmargin 0,26cm 
\parindent0pt
\parskip\baselineskip

\newcommand{\x}{\hspace*{1cm}}

\def\tekst #1,#2;{\parbox{#1}{\tiny\
                  \begin{center}#2\end{center}}}
\begingroup\makeatletter\ifx\SetFigFont\undefined
% extract first six characters in \fmtname
\def\x#1#2#3#4#5#6#7\relax{\def\x{#1#2#3#4#5#6}}%
\expandafter\x\fmtname xxxxxx\relax \def\y{splain}%
\ifx\x\y   % LaTeX or SliTeX?
\gdef\SetFigFont#1#2#3{%
  \ifnum #1<17\tiny\else \ifnum #1<20\small\else
  \ifnum #1<24\normalsize\else \ifnum #1<29\large\else
  \ifnum #1<34\Large\else \ifnum #1<41\LARGE\else
     \huge\fi\fi\fi\fi\fi\fi
  \csname #3\endcsname}%
\else
\gdef\SetFigFont#1#2#3{\begingroup
  \count@#1\relax \ifnum 25<\count@\count@25\fi
  \def\x{\endgroup\@setsize\SetFigFont{#2pt}}%
  \expandafter\x
    \csname \romannumeral\the\count@ pt\expandafter\endcsname
    \csname @\romannumeral\the\count@ pt\endcsname
  \csname #3\endcsname}%
\fi
\fi\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage[normalem]{ulem}
\usepackage{soul}
\def\OpenPEARL{{\it OpenPEARL}}
\colorlet{color-added}{yellow!55!} %{RGB}{0,127,127}
\definecolor{color-removed}{RGB}{128,128,128}
\colorlet{color-tobedone}{blue!5!}  %{RGB}{0,0, 15}
\definecolor{color-modified}{RGB}{128,128,0}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{tobedone}%
{\begin{tcolorbox}[breakable,colback=blue!5!white,colframe=blue!75!black,title=TO BE DONE]
\parskip\baselineskip
}
{\end{tcolorbox}}

\newenvironment{removed}%
{\begin{tcolorbox}[colback=black!50!white,colframe=black!75!black,title=REMOVED]
\parskip\baselineskip
}
{\end{tcolorbox}}

\newenvironment{added}%
{\begin{tcolorbox}[colback=yellow!55!white,colframe=yellow!75!black,title=ADDED]
\parskip\baselineskip
}
{\end{tcolorbox}}

\newenvironment{modified}%
{\begin{tcolorbox}[colback=orange!15!white,colframe=orange!75!black,title=MODIFIED]
\parskip\baselineskip
}
{\end{tcolorbox}}



\newcommand{\tobedoneblock}[1]{\cbcolor{color-tobedone}
\cbstart 
#1
\cbend
}
\newcommand{\removedblock}[1]{
\cbstart 
\cbcolor{color-removed}
\color{color-removed}
#1
\cbend
\cbcolor{black}
\color{black}
}
\newcommand{\addedblock}[1]{
\cbstart 
\cbcolor{color-added}
#1
\cbend
\cbcolor{black}
\color{black}
}

\newcommand{\tobedonetext}[1]{
\cbstart
\cbcolor{color-tobedone}
\color{black}
\sethlcolor{color-tobedone}
\hl{\mbox{#1}}
\cbend
\cbcolor{black}
\color{black}
}

\newcommand{\removedtext}[1]{
\cbstart
\cbcolor{color-removed}
\color{black}
\sethlcolor{color-removed}
\hl{\mbox{#1}}
\cbend
\cbcolor{black}
\color{black}
}

\newcommand{\addedtext}[1]{
\cbstart
\cbcolor{color-added}
%\color{color-added}
\color{black}
\sethlcolor{color-added}
\hl{\mbox{#1}}
\cbend
\cbcolor{black}
\color{black}
}

%\newcommand{\tobedoneblock}[1]{\cbstart 
%\colorbox{color-tobedone}{\begin{minipage}{\textwidth}
%\parskip\baselineskip
%#1
%\end{minipage}
%}
%\cbend}

%\newcommand{\tobedonetext}[1]{\cbstart
%\sethlcolor{color-tobedone}
%\hl{\mbox{#1}}
%\cbend}

%\newcommand{\removedblock}[1]{\cbstart 
%\color{yellow}
%\colorbox{color-deleted}{\begin{minipage}{\textwidth}
%\parskip\baselineskip
%#1
%\end{minipage}}
%\color{black}
%\cbend}

%\newcommand{\removedtext}[1]{\cbstart
%\color{yellow}
%\sethlcolor{color-deleted}
%\hl{\mbox{#1}}
%\color{black}
%\cbend}

%\newcommand{\addedblock}[1]{\cbstart 
%\colorbox{color-new}{\begin{minipage}{\textwidth}
%\parskip\baselineskip
%#1
%\end{minipage}
%}
%\cbend}

%\newcommand{\addedtext}[1]{\cbstart
%\sethlcolor{color-new}
%\hl{\mbox{#1}}
%\cbend}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
\sethlcolor{yellow}

\begin{center}
{\Huge \OpenPEARL} \\
\vspace{1cm}
Implementation Description \\
\vspace{5cm}
2014-Oct-23\\
\vspace{10cm}
\tobedonetext{???? GI FG 4.4.2 ????}
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}   % 1

\begin{added}
This document is derived from the PEARL language report V2.2(?)
Title page and table of contents were added and the page format 
is set be the new styles. Documentclass is used instead of documentstyle.

Modified text elements are marked with the new LaTeX commands
\verb+\addedtext{new text}+ or \verb+\begin{added}new text block\end{added}+.
Text elements, which are indented to be removed are marked with
\verb+\removedtext+ or \verb+\begin{removed}...\end{removed}+ respectively.
Text elements which are not implemeted yet are marked with \verb|tobedone| respectively.

The used version respository supports nothing like the \verb|$ID| in svn.
Thus the version date must be set manually until an aumatice generation 
in introduced.
\end{added}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PEARL stands for {\bf P}rocess and {\bf E}xperiment {\bf A}utomation
{\bf R}ealtime {\bf L}anguage; it is a higher programming language that
allows a comfortable, safe and to a large extent computer-independent
programming of multitasking and real-time tasks. PEARL was standardised 
by DIN in different extension steps:

\begin{itemize}
\item DIN 66253, part 1, Basic PEARL, 1981 (subset of Full PEARL)
\item DIN 66253, part 2, Full PEARL, 1982
\item DIN 66253, part 3, Distributed System PEARL, 1988
\end{itemize}

Based on the experiences from hundreds of PEARL projects, a gremium of
PEARL users and implementators worked out a definition of PEARL 90 in
1989 and 1990 (cf. Stieger, K.: ``PEARL 90 --- Die Weiterentwicklung von
PEARL'', in: {\em Informatik-Fachberichte 231}, PEARL '89 Workshop
\"uber Realzeitsysteme, Springer 1989).

PEARL 90 corresponds to Full PEARL, though some language elements not
needed in practice are omitted. On the other hand, PEARL 90 contains
some progressive extensions.

\begin{removed}
The language report presented here describes the language extent of
PEARL 90, first outlining the fundamental characteristics of PEARL 90.
In the following, the language elements will be defined exactly.
\end{removed}

\begin{added}
This report defines the concrete implementation of the PEARL 90
language in the \OpenPEARL{} environment. Some language elements of 
PEARL 90  are not supported, others are described more detailed.
\end{added}

The appendix contains a list of all data types and their possible
applications, a description of the available predefined functions, a
complete description of the syntax, because for didactical reasons not
all syntactic possibilities are described in the respective sections, as
well as a list of all keywords.

\chapter{Fundamental Features of PEARL}   % 2

\section{Multitasking Characteristics} % 2.1


A data processing program for on-line control or on-line analysis of a
technical process must be able to react as soon as possible to
spontaneous requests of the process or temporal events. Thus, in most
cases it is not sufficient to arrange and to carry out the individual
programming steps sequentially, i.e. in temporally unchangeable order.
The more or less complex automation problem has rather to be split up into
problem related parts with varying urgency, and the program
structure has to be adapted to this problem structure. Upon this,
independent program components for problem parts are created that can be
worked on sequentially within other components (e.g. procedures);
but also independent program components for problem parts arise that
have immediately to be executed in parallel to all other components because
of a temporally not necessarily fixed stimulus (e.g. a fault indication
from the process). Such a program component is called
task; in order to fix their urgency, tasks can be provided with
priorities.

For the declaration and the working together of tasks with each other and
with the technical process, PEARL offers the following possibilities:

\begin{itemize}
\item declaration of tasks, e.g.\\
      \begin{tabbing}
      supplies: \= {\bf TASK PRIORITY} 2;\\
  \> task object (declarations, statements)\\
  \> {\bf END};\\
      \end{tabbing}
\item starting (activation), e.g.\\
      {\bf ACTIVATE} supplies;
\item terminating, e.g.\\
      {\bf TERMINATE} printing;
\item suspending, e.g.\\
      {\bf SUSPEND} statistics;
\item continuing, e.g.\\
      {\bf CONTINUE} statistics;
\item resuming, e.g.\\
      {\bf AFTER} 5 SEC {\bf RESUME};
\end{itemize}

According to the requests of automation tasks, some of these
statements can be scheduled for (repeated) execution, e.g. if a time,
the end of a duration, or a message arrives:

{\bf WHEN} ready {\bf ACTIVATE} supplies;\\
(meaning: every time when the interrupt ready occurs, the task supplies
has to be activated)

A temporal periodical start can also be scheduled:

{\bf AT} 12:0:0 {\bf ALL} 1 SEC {\bf UNTIL} 12:15:0 {\bf ACTIVATE} measuring;

Different tasks execute their statements independently of one another,
provided relevant measures do not prevent that. However, sometimes a
synchronisation of two or more tasks is necessary, e.g. if a task
produces data and stores them into a buffer. Here the producer must not
work faster than the consumer. More complex synchronisation problems
occur, if e.g. a task has to access to a file exclusively (because
writing), whereas others can access simultaneously (because reading). In
order to solve these synchronisation problems, PEARL contains the data
\removedtext{types SEMA and BOLT} \addedtext{type SEMA} 
with corresponding statements, such as

\begin{itemize}
\item {\bf REQUEST} conveyor-belt;
\item {\bf RELEASE} communication-buffer;
\end{itemize}

\begin{removed}
It is fundamental that these multitasking statements are {\it computer
independent}, i.e. PEARL programs can run on iRMX, OS/2, UNIX or VAX/VMS
systems without any changes.
\end{removed}

\begin{added}
It is fundamental that these multitasking statements are {\it computer 
plattform independent}, i.e. \OpenPEARL{} programs can run on Linux and 
Microcontrollers enhanced with FreeRTOS without any changes.
\end{added}

In addition to this, there is the great advantage that the PEARL
programmer can program his multitasking statements in a {\it problem
oriented way} with high comfort without becoming deeply involved in the
peculiarities of the various operating systems --- e.g. in the handling
of fork and message queue mechanisms of Unix. The conversion of problem
oriented multitasking statements of PEARL into the mechanisms of
multitasking operating systems is taken over by the PEARL compiler.

\section{Possibilities of Input and Output}   % 2.2

The transmission of data to or from devices of the standard peripherals (printer, hard disk etc.) 
or process peripherals (sensors, 
actuators, etc.), respectively, as well as the control of files take place in PEARL with 
the help of computer independent statements.

Devices and files are summarised by the term data station. Two kinds of
data transmission are distinguished essentially:

\begin{itemize}
\item The transmission of data without format control, i.e. without
      conversion into an external representation:

      This kind of data transmission is used for file communication that
      allows for sequential and direct access as well as for the transmission
      of process data.

      Examples:

      {\bf READ} record {\bf FROM} file {\bf BY} POS (10);\\
      {\bf WRITE} data-set {\bf TO} logbook;\\
      {\bf TAKE} measured-value {\bf FROM} TemperatureSensor;\\
      {\bf SEND} on {\bf TO} motor;

\item The transmission of data with format control, i.e. with conversion
      between internal format and external representation with those
      possibilities available at the data station:

      This means e.g. the representation in the characters of a character set
      of the data station.

      Examples:

      {\bf PUT} event {\bf TO} printer {\bf BY} F(5);\\
      {\bf GET} receipt {\bf FROM} terminal;
\end{itemize}

The names of the data stations can be chosen freely. This is reached by the
partitioning of a PEARL program into computer dependent and mostly
computer independent parts.

In order to address special devices, the compiler offers a driver
interface, to which the PEARL programmer himself can connect device
drivers.

\section{Program Structure}   % 2.3

Program systems for the solution of complex automation tasks should be
structured in a modular way. PEARL meets this requirement, because a
PEARL program consists of one or several separately compilable
modules.

Connections between modules are possible by means of so-called global
objects (e.g. variables, procedures, tasks).

In order to be able to program the statements for data transmission
and to schedule the reactions to the events from the technical process
(interrupts) or of the computer hardware (signals) computer
independently, a module is usually structured into a system part and a
problem part.

In the system part, the used hardware configuration is described.
Particularly freely chosen names can here be assigned to the devices and
their connections, the interrupts and signals. 

\begin{removed}
Thus, the following
example means that a valve is connected to the connector 3 of a digital
output unit called by the computer specific system name DIGOUT (1). The
valve, i.e. connector 3, is to be called by the freely selectable
computer independent user name ``valve'':

valve: DIGOUT (1) * 3;
\end{removed}

\begin{added}
Thus, the following
example means that a valve is connected to the connector 3
 of a digital
output unit called by the computer specific system name DIGOUT.
The valve needs only 1 bit, other devices need more bits to be controlled
efficiently.
The valve, i.e. connector 3, is to be called by the freely selectable
computer independent user name ``valve'':

valve: DIGOUT(3,1);
\end{added}

Using the user name introduced in the system part, the actual algorithm
for the solution of the automation task is programmed computer
independently in the problem part, e.g.:

{\bf SEND} on {\bf TO} valve;

In order to structure the algorithms, (named) blocks, procedures and
tasks (parallel activities) are available.

\section{Data Types}   % 2.4

The following data types are available in PEARL:

\begin{itemize}
\item {\bf FIXED} and {\bf FLOAT} with specifyable precision
\item {\bf BIT} and {\bf CHARACTER} strings with specifyable length
\item {\bf CLOCK} and {\bf DURATION} for times and durations
\item references {\bf (REF)} for indirect addressing
\item devices and files {\bf (DATION)} for standard and process input and
      output
\item \removedtext{interrupts {\bf (INTERRUPT)} for external interrupts}
\item \removedtext{signals {\bf (SIGNAL)} for internal exceptional situations}
\item semaphores {\bf (SEMA)} \removedtext{and bolt variables {\bf (BOLT)}} for
      coordinating the access of tasks to shared object
\end{itemize}

From this, the user himself can build up more complex data structures
like arrays, hierarchical structures (STRUCT) and lists; with the help
of the TYPE definition, they can be declared as new, problem oriented
data types as well. Furthermore, PEARL allows the introduction of new,
problem oriented operators for any data structures with the help of the
OPERATOR definition.

\begin{tobedone}
\section{Control Structures}   % 2.5

The following control structures are available:

\begin{itemize}
\item conditional statement\\

      {\bf IF} expression\\
      {\bf THEN} statement$^{...}$\\
      {\bf ELSE} statement$^{...}$\\
      {\bf FIN};

\item statement selection\_1\\

      {\bf CASE} expression\\
      {\bf ALT} (alternative 1) statement$^{...}$\\
      {\bf ALT} (alternative 2) statement$^{...}$\\
      ...\\
      {\bf OUT} statement${...}$\\
      {\bf FIN};

\item statement selection\_2\\

      {\bf CASE} Case\_Index\\
      {\bf ALT} (Case\_List) statement$^{...}$\\
      {\bf ALT} (Case\_List) statement$^{...}$\\
      ...\\
      {\bf OUT} statement${...}$\\
      {\bf FIN};

\item loops\\

      {\bf FOR} ControlVariable {\bf FROM} start {\bf BY} StepLength {\bf TO} end\\
      {\bf REPEAT}\\
      statement$^{...}$\\
      {\bf END};\\

      {\bf WHILE} condition\\
      {\bf REPEAT}\\
      statement$^{...}$\\
      {\bf END};

\item exit statement\\

      {\bf EXIT} block;
\end{itemize}
\end{tobedone}

\chapter{Rules for the Construction of PEARL Language Forms}   % 3

A PEARL program can be written free of format; particularly, it is not
necessary to pay attention to the fact that a statement starts in a
certain column.

All elements of a PEARL program are produced from characters of the
following character set. Certainly, character string constants and
comments may contain any character that is allowed by ISO 646 and
national variants of ISO 646.

\section{Character Set}   % 3.1

The character set of PEARL is a partial set of the ISO 7 bit character
set (ISO 646). It contains

\begin{itemize}
\item the upper-case letters A to Z
\item the lower-case letters a to z
\item the digits 0 to 9, and
\item the special characters
      \begin{tabbing}
      \x \=   \kill
      \_ \> underline\\
  \> space (for better clearness sometimes, underline \_ is used)\\
      !  \> exclamation mark (start of the line comment)\\
      '  \> apostrophe\\
      (  \> open round parenthesis\\
      )  \> close round parenthesis\\
      ,  \> comma\\
      .  \> full stop\\
      ;  \> semicolon\\
      :  \> colon\\
      +  \> plus sign (e.g. for addition, algebraic sign)\\
      -  \> minus sign (e.g. for subtraction, algebraic sign)\\
      $\ast$  \> asterisk (e.g. for multiplication)\\
      /  \> oblique stroke (e.g. for division)\\
      =  \> equals sign (e.g. for assignment)\\
      $<$  \> less sign\\
      $>$  \> greater sign\\
      $[$  \> square bracket\\
      $]$  \> square bracket\\
      $\backslash$ \> backslash (for control signs in character strings)
      \end{tabbing}
\end{itemize}

The following character combinations are interpreted as an entity (a
compound symbol):

\begin{tabbing}
== \= exponentiation symbol \kill

:=    \> assignment symbol\\ \relax
**    \> exponentiation symbol\\
/*    \> start comment\\ \relax
*/    \> end comment\\
//    \> symbol for integer division\\
==    \> equals symbol\\
/=    \> not equals symbol\\
$<=$  \> greater or equal symbol\\
$>=$  \> less or equal symbol\\
$<>$  \> cyclic-shift symbol\\
$><$  \> concatenation symbol\\
$'\backslash$ \> start of a control character sequence in character string constants\\
$\backslash'$ \> end of a control character sequence in character string constants
\end{tabbing}

If not all symbols required for program notation are available on a
device, the following character sequences can be used alternatively:

\begin{tabbing}
CSHIFT \= for $<>$ \kill

LT     \> for $<$\\
GT     \> for $>$\\
EQ     \> for ==\\
NE     \> for /=\\
LE     \> for $<=$\\
GE     \> for $>=$\\
CSHIFT \> for $<>$\\
CAT    \> for $><$\\
(/     \> for $[$\\
/)     \> for $]$\\
\end{tabbing}

\section{Basic Elements}    % 3.2

A PEARL program is built up from the following basic elements:

\begin{itemize}
\item identifiers
\item constants
\item delimiters (meaning special characters and compound symbols), and
\item comments
\end{itemize}

Character sequences for identifiers and constants must be followed by
delimiters or comments.

\subsection{Identifiers}   % 3.2.1

Identifiers are used for constructing names of objects (e.g. numerical
variables, procedures). They consist of a sequence of letters
(upper-case or lower-case), the underline and/or numerals; this sequence
has to start with a letter. For identifiers, PEARL distinguishes between
upper-case and lower-case letters, i.e., valve, VALVE and Valve denote
different objects.

Examples: counter\_1, DISPO, wait

Some words have a specific meaning at prescribed positions in the PEARL
program; these words are called keywords. E.g., the words BIT or GOTO
are such keywords. The appendix contains a list of all keywords. They
must not be used as identifiers and have always to be written with
upper-case letters.

\subsection{Constants}   % 3.2.2

Constants are integer numbers, floating point numbers, bit strings,
character strings, times and durations. They are described in Chapter 5
together with the corresponding variables.

\subsection{Comments}    % 3.2.3

Comments are used to explain the program and are of no importance for
running of the program. There are two kinds of comments: One kind may
cover several lines and is put in brackets by the compound symbols ``/*''
and ``*/''. Within these brackets, any characters may occur except the
compound symbol ``*/'' for the end of the comment.

The other kind, the line of comment, starts with an exclamation
mark ``!'' and is terminated by the end of the line.

Comments may be inserted wherever spaces are allowed.

Examples:

/* This comment is not ended\\
\x by the end of the line */\\
! This comment is limited to 1 line

\section{Construction of Language Forms}  % 3.3

In the following chapters, the language forms allowed in PEARL are
described.  In order to make these descriptions exact and as compact as
possible, some formal possibilities are needed apart from the verbal
formulation:

Each language form has a name, by which it is defined with the help of
the (meta) symbol ``::='' :

NameOfTheLanguageForm ::=\\
\x DefinitionOfTheLanguageForm

Example:

UpperCaseLetter ::=\\
\x A or B or ... or Z

Digit ::=\\
\x 0 or 1 or ... or 9

As this example shows, the definition of a language form may contain
elements that are given alternatively when constructing the language
form. To shorten that, in the following the alternatively possible
elements are divided by the symbol ``$\mid$'':

Example:

Letter ::=\\
\x A $\mid$ B $\mid$ ... $\mid$ Z $\mid$ a $\mid$ b $\mid$ ... $\mid$ z

Digit ::=\\
\x 0 $\mid$ 1 $\mid$ 2 $\mid$ ... $\mid$ 9

If one element shall occur on different occasions, but at least once, it
is to be provided with three superscribed dots.

Example:

SimpleInteger ::=\\
\x Digit $^{...}$

To express that an element may be missing while constructing the
language form, it is given in square brackets ``['' ... ``]'' (in case
of doubt, the square brackets are printed boldly).

Example:

Identifier ::=\\
\x Letter [ \{ Letter $\mid$ Digit $\mid$ \_ \} $^{...}$ ]

Here, already two further rules were used: The definition of a language
form may again contain names of language forms; furthermore the braces
and square brackets are also used to put together elements to new
elements. Thus, the last example is equivalent to the following:

Example:

Identifier ::=\\
\x Letter [ Letter $\mid$ Digit $\mid$ \_ ] $^{...}$

For the description of lists whose elements are separated by a certain
symbol, the list element and the delimiter are given in the form

ListElement [ Delimiter ListElement ] $^{...}$

to define the corresponding language form.

Example:

IdentifierList ::=\\
\x Identifier [ , Identifier ] $^{...}$

For a better understanding or a more exact description of the definition
of a language form, elements are often provided with an explanatory or
restricting comment that is separated from the element by the symbol
\S .

Example:

DeviceList ::=\\
\x Identifier\S  Device [ , Identifier\S Device ] $^{...}$

\chapter{Program Structure}   % 4

\section{Modules}  % 4.1

A PEARL program is constructed of one or several parts, so-called
modules, which are translated independently. Each module consists of a
system part and/or a problem part.

The general form of a PEARL program reads as follows:

PEARL program ::=\\
\x Module $^{...}$

Module ::=\\
\x {\bf MODULE} [ (Identifier\S  OfTheModule) ];\\
\x \x \{ SystemPart [ ProblemPart ] \} $\mid$ ProblemPart\\
\x {\bf MODEND};

SystemPart ::=\\
\x {\bf SYSTEM}; [ UserNameDeclaration $^{...}$ ]

ProblemPart::=\\
\x {\bf PROBLEM}; [\{ Declaration $\mid$ Specification $\mid$ Identification\} $^{...}$ ]

In the system part, the connections of the projected computer are
described with the elements of the technical process (sensors,
actuators, etc.) and the standard peripherals (keyboard, monitor,
printer, disks, tapes, etc.). The programmer can assign freely
selectable names to the entries of the interrupt controller and the
peripherals addressed in the I/O statements (in the problem part) to
refer to these (computer independent) names in the problem part.

In the problem part, the algorithm for solving the given automation
problem is described. For this, the programmer declares the following
objects:

\begin{itemize}
\item variables and constants for integers, floating point numbers, bit
strings, character strings, durations, times, references
\item labels
\item procedures for frequently occurring partial evaluations
\item tasks for the temporarily parallel execution of tasks
\item blocks for structuring procedures and tasks
\item interrupts
\item signals
\item synchronisation variables (Sema and Bolt variables) as well as
\item data stations and formats for input/output
\end{itemize}

The required statements are given in the procedures and tasks,
together with other ``local'' declarations which are only needed there.
In general, objects may not be used (in statements) until they are
declared.

Example:

{\bf MODULE};

{\bf SYSTEM};\\
\x description of the connections and introduction of names for the
peripherals

{\bf PROBLEM};\\
\x declaration of constants and variables\\
\x declaration of interrupts\\
\x declaration of data stations

\x declaration of a task\\
\x \x declaration of local constants and variables\\
\x \x statements

\x declaration of a procedure\\
\x \x declaration of local constants and variables\\
\x \x declaration of local procedures\\
\x \x statements

...

{\bf MODEND};

Objects are declared at module level, i.e., outside procedures and
tasks, or in procedures and tasks. Objects declared at module level are
known in the entire module and can be used or, if needed, changed by
each task and procedure of the module, when mentioning the identifier.
A declared object in the task or procedure is only known in the
respective task or procedure and can only be used or, if needed,
changed there.

\section{Declarations and Specifications} %  4.2

Objects are introduced by {\it declaration} or {\it specification}.

\subsection{Declaration (DCL)}  % 4.2.1

The declaration serves to introduce an object and its name, i.e., when
evaluating the declaration, memory space for the object is allocated, and
up from now, it can be accessed under the name given in the
declaration.

At the module level or in a procedure or task, an object may be declared
only once. If an identifier X is declared as object both at module level
and in a procedure or task, two objects are introduced: In the
respective procedure or task, identifier X refers to the object
(locally) declared there, outside the procedure or task it refers to the
object declared at module level (cf. section 4.3, Block Structure).

Example:

\begin{tabbing}
P:~~ \= DECLARE x FLOAT xxx \=   \kill

{\bf PROBLEM}; \>            \> \\
   \> {\bf DECLARE x FLOAT}; \> ! 1st declaration at module level\\
   \> {\bf DECLARE x FIXED}; \> ! 2nd declaration at module level (wrong)\\
   \>                        \> \\
P: \> {\bf PROCEDURE};       \> \\
   \> {\bf DECLARE x FIXED}; \> ! declaration in procedure P (permitted)\\
   \> ...                    \> \\
   \> x := 3;                \> ! assignment to the local variable x\\
   \> ...                    \> \\
   \> {\bf END};             \> ! P \\
   \>                        \> \\
   \> x := 5;                \> ! assignment to variable x declared at module level\\
   \> ...                    \> \\
   \> {\bf END};             \> ! T \\
   \>                        \> \\
... \>                       \>
\end{tabbing}

The different declaration forms are treated with the various objects in
the subsequent chapters.

In procedures and tasks,
\begin{itemize}
\item tasks
\item interrupts
\item signals
\item synchronising variables
\item data stations, as well as
\item formats
\end{itemize}
must not be declared or specified.

Table~\ref{objekte} shows where which objects may be declared or
specified.

\begin{table}
\caption{Permissibility of declarations\label{objekte}}
\vspace{5mm}

\begin{tabular}{|l|c|c|c|c|}
\hline
                       & \multicolumn{4}{|c|}{declaration possible on} \\
object                 & module level & task level & procedure level & block level \\ \hline
variable, constant     & x            & x    & x         & x  \\
label                  & --           & x    & x         & x  \\
procedure              & x            & x    & x         & -- \\
task                   & x            & --   & --        & -- \\
block                  & --           & x    & x         & x  \\
Sema, Bolt variable    & x            & --   & --        & -- \\
data station, format   & x            & --   & --        & -- \\
type                   & x            & x    & x         & x \\
\hline
\end{tabular}
\end{table}

\subsection{Specification (SPC) and Identification (SPC IDENT)}  % 4.2.2

With a specification, an already declared object is
referred to.  This is meaningful for objects which are declared in a
module, and which shall be used in other modules (cf. 4.4, References
between Modules), but also for introducing additional names for already
declared objects in general.
\newpage

Example:

Object c of type FIXED (15) shall get xx as 2nd name --- or formulated
in a different way: Object x shall be {\it identified} with name xx:

{\bf PROBLEM};\\
\x ...\\
\x {\bf DECLARE x FIXED};\\
\x ...\\
\x {\bf SPECIFY xx FIXED IDENT} (x);\\
\x ...\\
\x xx := 7; \x ! assignment to object x

In general, the form of identification reads as follows:

Identification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier [ AllocationProtection ] Type IdentificationAttribute ;

IdentificationAttribute ::=\\
\x {\bf IDENT} (Name\S  Object)

The given type has to correspond to the type of the named object. More
details are defined when presenting the various objects.

\section{Block Structure, Validity of Objects}   % 4.3

Blocks are used to structure task or procedure bodies and to influence
the scope and the life-span of PEARL objects. A block is a summary of
declarations and statements:

Block::=\\
\x {\bf BEGIN}\\
\x [\{ Declaration $\mid$ Identification \} $^{...}$ ]\\
\x [ Statement $^{...}$ ]\\
\x {\bf END} [ Identifier\S  Block ] ;

Blocks are regarded as statements and may thus only occur in tasks and
procedures, but there even nested. The entry into a block takes
place when executing BEGIN. A block is left by the corresponding END or
by a branch to an statement outside the block, e.g., by the exit
statement (cf. 7.5). Jumps into a block are not allowed.

Within the blocks, no procedures may be declared!

Memory space is not allocated to the (local) objects declared in a block
until the block is entered; it is abandoned when leaving the block. Like
tasks, procedures and repetitions, blocks can introduce and remove
objects dynamically and thus provide the opportunity to use the
available memory space repeatedly.

Thus, some rules for the life-span and the scope range of these objects
have to be established:

The life-span of an object is the (processing) time between the
evaluation of its declaration and the execution of the end of the block
(or of the repetition, procedure, task or module), where the declaration
takes place.

% Klammern einfuegen !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

{\bf MODULE};\\
\x {\bf SYSTEM};\\
\x \x printer: STDPRINT;\\
\x {\bf PROBLEM};\\
\x \x {\bf SPC} printer {\bf DATION} ... ;\\
\x \x T: {\bf TASK};\\
\x \x \x {\bf DCL} a {\bf FIXED};\\
\x \x \x {\bf BEGIN}\\
\x \x \x \x ...\\
\x \x \x \x {\bf DCL} x {\bf FLOAT};\\
\x \x \x \x ...\\
\x \x \x {\bf END};\\
\x \x \x ...\\
\x \x \x {\bf END}; ! T\\
\x \x ...\\
{\bf MODEND};

The scope of an object are all parts of the program where the object can
be used. The following rules are to be obeyed:
\begin{itemize}
\item An object declared at module level is usable at the module level
and in all tasks and procedures of this module (however, see 4.4), even
in all encapsulated procedures, blocks and repetitions with the
following exception: The scope range is restricted, if in one of the
tasks or procedures another object is declared under the same name.
\item An object declared in a task, procedure, repetition or block is
usable in this task, procedure, repetition or block and all
encapsulated procedures, repetitions and blocks with the following
exception: The scope is restricted, if in one of the encapsulated
procedures, repetitions or tasks another object is declared under the
same name.
\end{itemize}

Example:

% Klammern einfuegen !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

{\bf PROBLEM};\\
\x {\bf DCL} x {\bf FIXED};\\
\x ...\\
\x {\bf SPC} xx {\bf FIXED IDENT} (x);\\
\x T: {\bf TASK};\\
\x \x ...\\
\x \x {\bf END}; ! T\\
\x P: {\bf PROC};\\
\x \x {\bf DCL} y {\bf FIXED};\\
\x \x x := 2;\\
\x \x {\bf BEGIN}\\
\x \x \x {\bf DCL} x {\bf FLOAT};\\
\x \x \x x :=3 ;\\
\x \x \x ...\\
\x \x \x {\bf BEGIN}\\
\x \x \x \x {\bf DCL} x {\bf DUR};\\
\x \x \x \x ...\\
\x \x \x {\bf END};\\
\x \x \x ...\\
\x \x {\bf END};\\
\x \x y := x; ! y = 2\\
\x \x ...\\
\x \x {\bf END}; ! P\\
\x ...\\
{\bf MODEND};

After END, blocks can be provided with identifiers, so that encapsulated
blocks can be left deliberately with the help of the exit statement
(cf. 7.5).

\section{References between Modules}  % 4.4

If a PEARL program consists of several modules, it can be necessary to
use objects declared in a module and occupying memory space there (data,
procedures, etc.) in other modules as well. For this reason, these
(global) objects are declared with the global attribute at module level
in the module where they are to occupy memory space, and specified with
the global attribute at the module level in the other modules. In this
way, the scope of objects declared at module level can be extended.

Example:

\begin{tabbing}
\x {\bf DCL} x {\bf FIXED GLOBAL} \hspace{2cm} \= \kill

{\bf MODULE} (a);                  \> {\bf MODULE} (b); \\
{\bf PROBLEM};                     \> {\bf PROBLEM};\\
\x ...                             \> \x ...\\
\x {\bf DCL} x {\bf FIXED GLOBAL}; \> \x {\bf SPC} x {\bf FIXED GLOBAL} (a);\\
\x ...                             \> \x ...\\
\x x := 2;                         \> \x x := 3;\\
\x ...                             \> \x ...\\
{\bf MODEND};                      \> {\bf MODEND};
\end{tabbing}

All data stations, interrupts and signals given in the system part of a
certain module are regarded as declared (implicitly) with the global
attribute. Thus, they are only specified in the problem parts of the
program; here the global attribute can be omitted in the problem part of
the same module, in all other modules it must be defined.

The general form of the global attribute reads:

GlobalAttribute ::=\\
\x {\bf GLOBAL} [ (Identifier\S OfaModule) ]

When specifying an object, all attributes have to be taken over from its
declaration, except for a given priority, precision or length. In the
latter exceptional case, the precision or length defined in the
corresponding length declaration is applied for the range of the program
where the specification is valid.

Example:

% ??? Einrueckungen im Original unuebersichtlich und unklar

\begin{tabbing}
\x P: {\bf PROC} (A(,) {\bf FIXED IDENT})\=  \kill

{\bf MODULE};                     \> {\bf MODULE};\\
{\bf PROBLEM};                    \> {\bf PROBLEM};\\
\x T: {\bf TASK PRIO 3 GLOBAL};   \> \x {\bf SPC} T {\bf TASK GLOBAL};\\
\x \x \x ! task body              \> \x \x P {\bf ENTRY} ((,) {\bf FIXED IDENT}) {\bf GLOBAL};\\
\x \x {\bf END}; ! T              \> \x INIT: {\bf TASK};\\
                                  \> \x \x {\bf DCL} TAB (10,20) {\bf FIXED;}\\
\x P: {\bf PROC} (A(,) {\bf FIXED IDENT}) \> \x \x ...\\
\x \x \x \x {\bf GLOBAL};         \> \x \x {\bf CALL} P (TAB);\\
\x \x \x ! procedure body         \> \x \x ... \\
\x \x {\bf END}; ! P              \> \x \x {\bf ACTIVATE} T;\\
\x ...                            \> \x {\bf END}; ! INIT\\
{\bf MODEND};                     \> \x ...\\
                                  \> {\bf MODEND};
\end{tabbing}

The different forms of specifying global objects are defined when
presenting the objects.

\section{Execution of a Program}   % 4.5

After the loading of a PEARL program, the PEARL run time system
automatically starts all tasks marked by the attribute MAIN according
to their priority.  All tasks provided with MAIN have to be declared in
the same module.

Example:

\begin{tabbing}
{\bf MODULE} (Main); \= \\
{\bf SYSTEM}; ...    \> \\
{\bf PROBLEM};       \> \\
start:               \> {\bf TASK MAIN};\\
                     \> ! activating and scheduling of other tasks\\
                     \> {\bf END}; start\\
                     \> \\
measuring:           \> {\bf TASK PRIO 1};\\
                     \> ! task body \\
                     \> {\bf END}; ! measuring\\
...                  \> \\
{\bf MODEND};        \>
\end{tabbing}

After the loading, the task start is started first.

\chapter{Variables and Constants}  % 5

\section{Declaration and Specification of Variables and Constants}  % 5.1

Upon its execution, a PEARL program uses and modifies integers, floating
point numbers, bit strings, character strings, times and durations.
These data occur in form of constants or as values of variables.
Constants are identified by their notations and keep their values during
the entire program execution. Variables denote data (their values) which
can change during the program execution.

Generally, the value range of a variable is limited to a single kind of data,
e.g. bit strings, which determines the type of the variable (Bit string
variables have only bit strings as values, e.g.). This type has to be
defined with its identifier, when declaring or specifying a
variable.

Example:

\begin{tabbing}
SPECIFY Status BIT (16) GLOBAL; xx \= \kill

{\bf DECLARE} switch {\bf BIT}; \> /* declaration of a variable
                                   switch of type bit string of  \\
                                \> length 1 */ \\
                                \> \\
{\bf SPECIFY} status {\bf BIT}(16) {\bf GLOBAL};
                                \> /* specification of a global
                                   variable status of type bit string \\
                                \> of length 16 */
\end{tabbing}

A variable denotes {\it one} data element, e.g. {\it one} integer, {\it
one} bit string, etc.; in the following, such scalar variables are
treated. The possibilities to summarise scalar variables to arrays and
structures are described in 5.10 and 5.11.

When declaring a variable, its type has to be given in a type attribute;
if different variables with the same type attribute are to be declared,
this can take place in form of a list in a declaration, e.g., by

{\bf DECLARE} (x,y,z) {\bf FLOAT};

the three variables x, y, and z are declared with the type attribute
FLOAT.  For simpler notation, different declarations may be formulated
in a declaration by separating them by commas:

\begin{tabbing}
{\bf DECLARE} \= x {\bf FLOAT,}\\
              \> i {\bf FIXED};
\end{tabbing}

Summarised, scalar variables can be declared as follows:

ScalarVariableDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} VariableDenotation [ , VariableDenotation ] $^{...}$ ;

VariableDenotation ::=\\
\x IdentifierDecnotation [ AllocationProtection ] TypeAttribute [ GlobalAttribute ]\\
\x [ InitialisationAttribute ]

IdentifierDenotation ::=\\
\x Identifier $\mid$ (Identifier [ , Identifier ] $^{...}$ )

TypeAttribute ::=\\
\x SimpleType $\mid$ TypeReference $\mid$ Identifier\S ForType

SimpleType ::=\\
\x TypeInteger $\mid$ TypeFloatingPointNumber $\mid$\\
\x TypeBitString $\mid$ TypeCharacterString $\mid$\\
\x TypeTime $\mid$ TypeDuration

The general form of specifying scalar variables reads as follows:

ScalarVariableSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} VariableDenotationS [ , VariableDenotationS ] $^{...}$;

VariableDenotationS ::=\\
\x IdentifierDenotation [ AllocationProtection ] TypeAttribute\\
\x \{ GlobalAttribute $\mid$ IdentificationAttribute \}

Allocation protection and initialisation attribute are described in 5.14,
identification and global attributes were already defined in 4.2 and
4.4.

Subsequently, the different type possibilities are presented; variables
of type Sema, Bolt, Interrupt or Signal are considered in 9.3, 9.4 and
10.

\section{Integers (FIXED)}   % 5.2

Integers can be written in decimal or dual representation. The decimal
representation of an integer consists of a sequence of decimal digits. The dual
representation consists of a sequence of the digits 0 and 1, terminated
with character B.

Examples:

\begin{tabular}{rrr}
integer & decimal pres. & dual pres. \\
      6 &             6 &     110B \\
    123 &           123 & 1111011B
\end{tabular}

Furthermore, the precision of the representation can be defined for a
numerical constant by noting the number of bit positions, in which it
shall be represented computer internally without signs, in brackets behind
the numerical constant.

Example: 123(31) \x Integer 123 is presented in 31 bit positions.

If no precision is given, the precision is derived from the constants.

Variables for integers are declared with the type attribute FIXED.

TypeInteger ::=\\
\x {\bf FIXED} [ (Precision) ]

Precision ::=\\
\x IntegerWithoutPrecision\S GreaterZero

The precision gives the number of bit positions in which the
corresponding value of the variable (without signs) is represented. If
the precision declaration is lacking, the precision defined in a length
specification (see 5.6) is inserted. 
\removedtext{Usual precisions are 15 or 31.}

\begin{added}
\OpenPEARL{} supports all lengths from 1 to 63.
All operations are monitored for successful operation.
In case of a range violations the signal FixedRangeSignal is induced.
In case of divide by zero or reminder by zero the signal FixedDivideByZeroSignal
is induced.
\end{added}

Example:

{\bf DCL} counter {\bf FIXED}(31),\\
\x (i,j,k) {\bf FIXED};\\
...\\
i := 2;

\section{Floating Point Numbers (FLOAT)}  % 5.3

Constants for floating point numbers can be represented as a sequence of
\begin{enumerate}
\item a point, an integer and possibly an exponent to the basis 10,
where an exponent consists of a sequence of the character E, possibly a
plus or minus sign, and an integer

\begin{tabbing}
Example: \= .123E-1 xx \=  \kill
Example: \> .123 \> (corresponds to 0.123)\\
 \> .123E2 \> (corresponds to 12.3)\\
 \> .123E-1 \> (corresponds to 0.0123)
\end{tabbing}

\item an integer followed by a sequence given in 1.

Example: 3.123E2 (corresponds to 312.3)

\item an integer, a point, and possibly an exponent

Example: 3. (corresponds to 3.0)

\item an integer and an exponent

Example: 3E-2 (corresponds to 0.03)
\end{enumerate}

Analogously to integers, even constants for floating point numbers can
be defined with precision.

Variables of type floating point number (with integers or floating point
numbers as values) are declared with type attribute FLOAT.

TypeFloatingPointNumber ::=\\
\x {\bf FLOAT} [ (Precision) ]

The statements of 5.2 are valid; 
\removedtext{usual precisions are here 23 and 53, respectively.}
\begin{added}
\OpenPEARL{} uses the supports the lengths 24 and 53.
All operations are monitored for successful operation.
In case of range violations or
divide by zero the result is set to INF (infinity) and
FloatIsINFSignal is induced.
In case of operations leading to NaN (not a number) the signal
FloatIsNaNSignal is induced.
The default preset value of {\bf FLOAT} values is NaN, which will produce
the FloatIsNaNSignal when used without prio assignment.

The precision for float literals is derived in the priority from: 
\begin{enumerate}
\item the given precision like 1.0(53)
\item the {\bf LENGTH} statement
\item is set to 24 as default value in \OpenPEARL
\end{enumerate}
\end{added}

Example:

{\bf DCL} (x,y,z) {\bf FLOAT},\\
\x Koeff {\bf FLOAT}(53);\\
... \\
x:=3.5; y:=1; Koeff:=3.14E-10;

\section{Bit Strings (BIT)}  % 5.4

A bit string constant can be given in binary form (B1), in form of
tetrades (B2), octades (B3), or in hexadecimal form (B4).

The form Bi (i=1,...,4) consists of an apostrophe, a sequence of
\begin{itemize}
\item digits 0 and 1 in case B1
\item digits 0 to 3 in case B2
\item digits 0 to 7 in case B3
\item digits 0 to 9 and letters A to F in case B4
\end{itemize}
followed by an apostrophe and the corresponding attribute B1 or B2 or
B3 or B4.

Example:

\begin{tabular}{rl}
'110010100111'B1 & corresponds to\\
      '302213'B2 & corresponds to\\
        '6247'B3 & corresponds to\\
         'CA7'B4 & \\
\end{tabular}

Instead of B1, B can be written in a shorter way. The following tables
show the assignment between the binary form and the other forms:

\begin{tabular}{cc@{\hspace{2cm}}cc@{\hspace{2cm}}cc}

B2 & B1 & B3 & B1  & B4 & B1 \\
0  & 00 & 0  & 000 & 0  & 0000 \\
1  & 01 & 1  & 001 & 1  & 0001 \\
2  & 10 & 2  & 010 & 2  & 0010 \\
3  & 11 & 3  & 011 & 3  & 0011 \\
   &    & 4  & 100 & 4  & 0100 \\
   &    & 5  & 101 & 5  & 0101 \\
   &    & 6  & 110 & 6  & 0110 \\
   &    & 7  & 111 & 7  & 0111 \\
   &    &    &     & 8  & 1000 \\
   &    &    &     & 9  & 1001 \\
   &    &    &     & A  & 1010 \\
   &    &    &     & B  & 1011 \\
   &    &    &     & C  & 1100 \\
   &    &    &     & D  & 1101 \\
   &    &    &     & E  & 1110 \\
   &    &    &     & F  & 1111 \\
\end{tabular}

Variables for bit strings are to be declared with type attribute BIT.

TypeBitString ::=\\
\x {\bf BIT} [ (Length) ]

Length ::=\\
\x IntegerWithoutPrecision\S GreaterZero

Length gives the number of elements of the bit string. If the length
option is lacking, it had either to be defined in a length
definition (see 5.6), or 1 is assumed as length.

Example:

{\bf DCL} X\_coord {\bf BIT}(2),\\
\x Y\_coord {\bf BIT}(8);\\
...\\
X\_coord:='01'B;\\
Y\_coord:= 'A9'B4;

The addressing of parts of bit strings is treated in 6.1, Expressions.

\begin{added}
\OpenPEARL{} supports all lengths from 1 to 64.
In case of selecting a slice which is not part of the bit string, the
signal BitIndexOutOfRangeSignal is induced.
\end{added}

\section{Character Strings (CHARACTER)}  % 5.5

A character string constant consists of an apostrophe, a sequence of any
characters (besides of apostrophe) and an apostrophe.

Example: 'fault no.: '

If, however, the character string has to contain an apostrophe, it has
to be represented by two subsequent apostrophes.

Example: 'fault''no.: '

Control characters can be inserted into character string constants with
the help of the switch symbols `` `$\backslash$ '' and `` $\backslash$'
''.  The control characters are given as pairs of sedecimal digits.

Examples:

'This string '$\backslash$ 0D 0A $\backslash$' contains two control characters'\\
''$\backslash$1B$\backslash$' control character at the start of the string'\\
'control character at the end of the string'$\backslash$00$\backslash$''\\
''$\backslash$00$\backslash$'' /* string consisting of one single control character */

Example:

'By changing over to the control character sequence'$\backslash$20\\
$\backslash$' very long character string constants'$\backslash$20\\
$\backslash$' can be created (independently from the used editor).'

Variables for character strings are declared by the type attribute
CHARACTER.

TypeCharacterString ::=\\
\x \{ {\bf CHARACTER $\mid$ CHAR} \} [ (Length) ]

Length gives the number of characters. If no length is indicated, it had
either to be defined in a length specification (see 5.6) or length 1 is
assumed.

Examples:

{\bf DCL} ArticleIdentificator {\bf CHAR}(6);\\
...\\
ArticleIdentificator:='BCD/27';

The addressing of parts of character strings is treated in 6.1,
Expressions.

\begin{added}
\OpenPEARL{} supports all lengths from 1 to 32767.
All operations are monitored:
In case defining a {\bf CHAR} variable with more than 32767 elements the
CharacterTooLongSignal is induced.
In case of selecting a slice which is not part of the {\bf CHAR} variable the 
CharacterIndexOutOfRangeSignal is induced.
\end{added}

\begin{tobedone}
\section{The Length Definition}   % 5.6

With the length definition, the precisions and lengths for such
number and string objects are defined, whose precisions and lengths are
not determined by notation (for constants) or declaration (for
variables).

\begin{tabbing}
\x {\bf LENGTH} \= \kill
LengthDefinition::=\\
\x {\bf LENGTH} \{ \{ {\bf FIXED $\mid$ FLOAT} \} (precision)\\
              \x \> $\mid$ \{ {\bf BIT $\mid$ CHARACTER $\mid$ CHAR} \} (length) \};
\end{tabbing}

Example:

\begin{tabbing}
\x \x Y {\bf FLOAT}(23); \x \= \kill
{\bf PROBLEM}; \> \\
\x {\bf LENGTH FIXED}(15); \> \\
\x {\bf LENGTH FLOAT}(53); \> \\
\x {\bf DCL} A {\bf FIXED}, \> /* A is of type {\bf FIXED}(15) */ \\
\x \x X {\bf FLOAT},        \> /* X is of type {\bf FLOAT}(53) */ \\
\x \x Y {\bf FLOAT}(23);    \> /* Y is of type {\bf FLOAT}(23) */ \\
\x ... \> \\
\end{tabbing}

For a length definition, the same validity rules are valid as for
variable declarations (see 4.3, Block Structure).
\end{tobedone}

\section{Times (CLOCK)}   % 5.7

A time constant consists of a positive integer to state the hour, an
integer between 0 and 59 for the minute, and a floating point number
between 0 and 59.999... for the second --- separated by a colon, each.
The hour is interpreted modulo 24.

Example:

\begin{tabbing}
11:30:00 \x \= means 11.30\\
15:45:3.5   \> means 15.45 and 3.5 seconds\\
25:00:00    \> means 1.00
\end{tabbing}

Variables for times are declared with type attribute CLOCK.

TypeClock ::=\\
\x {\bf CLOCK}

Example:

{\bf DCL} time {\bf CLOCK};\\
...\\
time:=12:30:00;

\begin{added}
\OpenPEARL{} provides a resolution for CLOCK values of $1\mu s$
\end{added}

\section{Durations (DURATION)}   % 5.8

A duration constant is composed of stating an hour, a minute, and a
second, however, single pieces of specifications may be lacking. An hour
is given by an integer and the character sequence HRS, a minute by an
integer and the character sequence MIN, a second by a floating point
number and the character sequence SEC.

Examples:

\begin{tabbing}
5 {\bf MIN} 30 {\bf SEC} \= means 5 minutes and 30 seconds \\
.05 {\bf SEC}            \> means 50 milliseconds \\
5 {\bf HRS} 10 {\bf SEC} \> means 5 hours and 10 seconds
\end{tabbing}

The integers and floating point numbers in time constants must not
contain precision specifications.

Variables for durations have to be declared with the type attribute
DURATION.

TypeDuration ::=\\
\x {\bf DURATION $\mid$ DUR}

Example:

{\bf DCL} delay {\bf DUR};\\
...\\
delay:=0.1 {\bf SEC};

\begin{added}
\OpenPEARL{} provides a resolution for DURATION values of $1\mu s$ and
a range of $\approx 100 days$.
In case of an arithmetic overflow in calculations with durations, the
DurationValueSignal is induced.
In case of division by a zero duration or 0 FLOAT, 
the DurationDivideByZeroSignal is induced.
\end{added}

\begin{tobedone}
\section{References (REF)}  % 5.9

For the indirect addressing, so-called reference variables (pointer
variables, pointers) are provided in PEARL. Reference variables have the
names of variables as values (they point at variables). Analogously to
the variables introduced up to now, the value range of a reference
variable is limited to a type of variables given when declaring the
reference variables (see, however, 5.13, Interference of Data
Structures).

The value of a reference variable, the referenced variable, is referred
to with the help of the monadic operator CONT (``content''); this
process is called ``dereferentiation''.

Examples:

\begin{tabbing}
{\bf DCL} (rk1, rk2) {\bf REF FIXED}, \= \kill

{\bf DCL} (k,l) {\bf FIXED}, \> \\
\x        x {\bf FLOAT}      \> \\
\x        (rk1,rk2) {\bf REF FIXED}, \> /* fixed reference variable */ \\
\x        rx {\bf REF FLOAT}; \> /* float reference variable */ \\
rk1:=k;   \> /* rk1 points at k */ \\
rk1:=l;   \> /* rk1 points at l */ \\
rk2:=rk1; \> /* rk2 points at l, pointer assignment */ \\
rx:=x;    \> /* rx points at x */ \\
rx:=k;    \> /* wrong, type unequal */ \\
rx:=rk1;  \> /* wrong, type unequal */ \\
l:=2;     \> \\
k:={\bf CONT} rk1; \> /* k obtains value 2 */ \\
rk2:=3;   \> /* wrong, 3 is no variable */ \\
{\bf CONT} rk2:=3; \> /* l obtains value 3 */ \\
{\bf CONT} rk2:=k; \> /* l obtains value 2 */ \\
\end{tabbing}

Instead of k:=CONT rk1, k:=rk1 can be written in a simpler way; i.e.,
operator CONT may be omitted on the right side of an assignment
(``implicit dereferentiation'').

In general, it holds:

TypeReference ::=\\
\x {\bf REF} [ VirtDimensionList ] [ AssignmentProtection ]\\
\x \{ SimpleType $\mid$ Identifier\S ForType $\mid$ TypeStructure $\mid$\\
\x \x TypeDation $\mid$ {\bf SEMA $\mid$ BOLT $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL $\mid$} \\
\x \x TypeProcedure $\mid$ {\bf TASK} $\mid$ TypeVOID $\mid$ {\bf CHAR}()\\
\x \}

VirtDimensionList ::=\\
\x ( [ , $^{...}$ ] )

Dereferentiation ::=\\
\x {\bf CONT} Name\S ReferenceVariable

The definition of the language form TypeReference shows, which type a
variable may have, at which a reference variable shall point.
Particularly, reference variables may also point at arrays and
structures (cf. 5.10 and 5.11). The number n of commas in the virtual
dimension list states that the referenced variable is an (n + 1)
dimensional array. On the other hand, reference variables must not point
at reference variables; referenced arrays and structures, however, may
possess reference variables as elements and components. This can be
used, e.g., to interlink structures, or to build up lists in general.
Section 5.12, Type Definition, gives an example for that.

TypeStructure and TypeDation are defined in 5.11 and 10.2, TypeProcedure and 
TASK in 8.3 and 9.11, TypeVOID and REF CHAR() in 6.4.2
and 5.9.1

If a reference variable R points at an array F with elements F
(i,j,k,...) or at a structure S with components S.Ki, the elements of F
or the components of S are addressed (taking R as starting-point) with R
(i,j,k,...) or R.Ki without using CONT.

Furthermore, a reference variable is dereferentiated implicitly,
\begin{itemize}
\item if it is the actual parameter of a procedure call, and if the
formal parameter belonging to it is no reference variable.
\item if it is used as operand of a dyadic operator, as far as the
latter is not defined for values of reference variables like IS (see
below).
\end{itemize}

Example:

{\bf DCL} rk {\bf REF FIXED},\\
\x k {\bf FIXED};\\
\x ...\\
\x rk:=k; k:=2;\\
\x k:=rk+1; /* equivalent     k:=k+1; */

E.g., to mark the end of a string, a reference variable NIL (zero
pointer) is provided, possessing a certain, constant value.

To compare the values of reference variables, the dyadic operators IS or
ISNT can be used; IS (ISNT) provides the result '1'B ('0'B), if both the
given reference variables possess the same (different) value(s),
otherwise it provides the result '0'B ('1'B).

Example:

{\bf DCL} NextOrder {\bf REF} type\_order;\\
...\\
{\bf IF} NextOrder {\bf IS NIL THEN}\\
\x ...\\
{\bf FIN;}

\subsection{Variable Character String Pointers (REF CHAR())}  % 5.9.1

Variably long character strings can easily be processed with special
pointer objects, so-called variable character string pointers.

Example: Declarations of variable character string pointers

\begin{tabbing}
{\bf SPC} print {\bf ENTRY (REF CHAR()) GLOBAL}; \=  \kill
{\bf DCL} str\_ptr {\bf REF CHAR()}; \> /* pointer declaration */       \\
{\bf SPC} print {\bf ENTRY (REF CHAR()) GLOBAL}; \>  /* pointer as parameter */
\end{tabbing}

A pointer of type ``REF CHAR ()'' contains, besides of the address of a
character string, two counters storing the maximum length and the
actually used length of the referenced character string variable. When
assigning the address of a character string variable to a variable
character string pointer, both counters are initialised with the length
of the referenced character string variable.

Example: Initalisation of a variable character string pointer

\begin{tabbing}
{\bf DCL} str\_ptr \= {\bf REF CHAR}(); \= \kill
{\bf DCL} s1 \> {\bf CHAR}(20); \> \\
{\bf DCL} s2 \> {\bf CHAR}(100); \> \\
{\bf DCL} str\_ptr \> {\bf REF CHAR}(); \> \\
str\_ptr:=s1; \> \> /* adr=s1, length=20, max=20 */ \\
str\_ptr:=s2; \> \> /* adr=s2, length=100, max=100 */
\end{tabbing}

Thus, the variable pointer differs at first not from a character string
pointer with constant length. When assigning to the character string
variable via this pointer, the length of the assigned character string,
however, is stored in the counter for the actual length, and the
otherwise usual filling of the character string with blanks up to the
maximum length is omitted.

Example: Assignment to the referenced variable

\begin{tabbing}
{\bf CONT} str\_ptr:='Werum GmbH'; \= \kill
str\_ptr:=s1; \> /* adr=s1, length=20, max=20 */ \\
{\bf CONT} str\_ptr:='PEARL 90'; \> /* adr=s1, length=8, max=20 */ \\
 \> \\
str\_ptr:=s2; \> /* adr=s2, length=100, max=100 */ \\
{\bf CONT} str\_ptr:='Werum GmbH'; \> /* adr=s2, length=10, max=100 */
\end{tabbing}

For the subsequent accesses to the character string via this pointer,
only the actual length is used.

Example:

\begin{tabbing}
{\bf DCL} str\_ptr x \= {\bf REF CHAR}(); xxxxxxxxxxx \= \kill
{\bf DCL} s1 \> {\bf CHAR}(20); \> \\
{\bf DCL} s2 \> {\bf CHAR}(100); \> /* filler */ \\
{\bf DCL} str\_ptr \> {\bf REF CHAR}(); \> /* variable pointer */       \\
 \> \> \\
str\_ptr:=s2: \> \> /* adr=s2, length=100, max=100 */ \\
{\bf CONT} str\_ptr:='D21337 ' {\bf CAT} 'Lueneburg'; \> \> /* adr=s2, length=16, max=100 */
\end{tabbing}

After this assignment, the variable ``s2'' contains the characters
``D21337 Lueneburg'' in the first 16 positions, the other characters
were not changed by the assignment. The length index of ``str\_ptr'' was
set to the actual length 16.

s1 := {\bf CONT} str\_ptr;

For this assignment, ``CONT str\_ptr'' generates the character string
value 'D21337 Lueneburg' (with type ``CHAR(16)''). Due to the assignment
rules of PEARL, the character string is extended by four blanks, before
this value is assigned to variable ``s1'' (with type ``CHAR(20)'').

Variable character string pointers turn out particularly useful as
formal parameters of procedures. Apart from the address of a character
string variable, the compiler passes its actual length at the call
position.  Thus, e.g. an error routine can give out error texts of
different length.

Example: Character string pointer as parameters

{\bf SPC} print\_error {\bf ENTRY (REF CHAR()) GLOBAL};\\
{\bf DCL} s1 {\bf CHAR}(20)  {\bf INIT}('...');\\
{\bf DCL} s2 {\bf CHAR}(100) {\bf INIT}('...');

...\\
{\bf CALL} print\_error (s1);\\
{\bf CALL} print\_error (s2);

Even character string constants may be passed, if the formal parameter
was defined with type ``REF INV CHAR()''.

Example:

{\bf SPC} print\_message {\bf ENTRY (REF INV CHAR()) GLOBAL};

...\\
{\bf CALL} print\_message ('text 1');\\
{\bf CALL} print\_message ('longer text 2');

A variable character string pointer can be used in all expressions
analogously to constant character string pointers. The length check
belonging to the type check takes first place at run time.

A variable character string pointer is not allowed as result value of a
function. Type ``CHAR()'' may only be used in combination with ``REF'',
i.e., parameter type ``CHAR()IDENT'' is not allowed.

\section{Arrays}   % 5.10

If possible, objects of the same kind are summarised in
one identifier, and the various objects are addressed with indices.

Example:

An embedded controller controls three devices G(1), G(2), and G(3). For
the output of the bit string '0001'B to the controller, G(1) shall be
switched on, device G(2) for '0010'B, and device G(3) for '0100'B. Here it
suggests itself to summarise the three switch-on signals under one
identifier, e.g., switch\_on, and to address them with indices:

{\bf DCL} switch\_on(1:3) {\bf BIT}(4),\\
\x i {\bf FIXED};\\
switch\_on(1):='0001'B;\\
switch\_on(2):='0010'B;\\
switch\_on(3):='0100'B;\\
...

/* taking over value of i (index of the device to be switched on)
from another program part\\
output of switch\_on (i) to the embedded controller */\\

In general, scalar variables of the same type can be combined into
n-dimensional arrays (n=1,2,3,4).

When declaring the array, an identifier is assigned to it; the various
array elements (scalar variables) are addressed under this identifier
and the definition of their positions within the array (the index).

Thus, with the help of

{\bf DCL} Koeff(1:2, 0:3) {\bf FIXED};

a 2-dimensional array is declared, where the first dimension has the
lower boundary 1 and the upper boundary 2, i.e., length 2, whereas the
second dimension has the lower boundary 0 and the upper boundary 3,
i.e., length 4.  This means that Koeff consists of the 8 scalar fixed
variables

Koeff(1,0) \x  Koeff(1,1) \x  Koeff(1,2) \x  Koeff(1,3) \\
Koeff(2.0) \x  Koeff(2,1) \x  Koeff(2,2) \x  Koeff(2,3)

The general form of a array declaration reads as follows:

ArrayDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} ArrayDenotation [ , ArrayDenotation ] $^{...}$ ;

ArrayDeclaration ::=\\
\x IdentifierDenotation DimensionAttribute [ AssignmentProtection ] TypeAttribute\\
\x [ GlobalAttribute ] [ InitialisationAttribute ]

DimensionAttribute ::=\\
\x (BoundaryDenotation\S FirstDimension [ , BoundaryDenotation\S FurtherDimension ] $^{...}$)

BoundaryDenotation ::=\\
\x [ Boundary\S Lower: ] Boundary\S Upper

Boundary ::=\\
\x [ - ] IntegerWithoutPrecision $\mid$ Identifier\S NamedConstant $\mid$ \\
\x ConstantExpression

Thus, even negative integers are allowed as dimension boundary. The
upper boundary of a dimension, however, has always to be greater or
equal its lower boundary.

If the lower boundary is not given, value 1 is assumed for it. By a
named constant, a variable of type FIXED(15) is understood, declared
with assignment protection (INV) and initial value (INIT).

Examples:

{\bf DCL} switch\_on(3) {\bf BIT}(4),\\
\x Koeff(2, 0:3) {\bf FIXED},\\
\x message(20) {\bf CHAR}(12);

The one-dimensional array message contains e.g. 20 error texts, so that,
in the case of error i, a program can pass the message (i) to a console
(i=1,...,20).

Arrays can also be declared mixed with scalar variables in a declaration,
e.g.:

{\bf DCL} numb\_mess {\bf INV FIXED}(15) {\bf INIT}(20);\\
\x ...

{\bf DCL}  message (numb\_mess) {\bf CHAR}(12),\\
\x (i,j,k) {\bf FIXED},\\
\x (switch\_on, switch\_off)(3) {\bf BIT}(4);

The general specification form of an array reads:

ArraySpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} ArrayDenotationS [ , ArrayDenotationS ] $^{...}$;

ArrayDenotationS ::=\\
\x IdentifierDenotation VirtualDimensionAttribute [ AssignmentProtection ] \\
\x TypeAttribute \{ GlobalAttribute $\mid$ IdentificationAttribute \}

VirtualDimensionAttribute ::=\\
\x ( [ , $^{...}$ ] )

The number n of commas in the virtual dimension attribute informs that
the specified array has n+1 dimensions.

In Section 1 of the Appendix it is described in tabular form, which
objects may be combined to arrays.
\end{tobedone}


\section{Structures}   % 5.11

Arrays allow to combine scalar variables of the {\it same} type under
one identifier; the various variables are addressed by this identifier
and their indices.

For many automation problems, especially for those with dispositive
character, however, data structures have to be described, whose
components have {\it different} types.

Example:

The contributions for the TV news of one day are stored on magnetic
tapes (VTR); the contribution sequence of a certain news broadcast of
that day is composed by the editors with the help of a computer
controlling the corresponding VTR. For this, a data set is necessary for
each contribution with, e.g. the following structure:

\begin{itemize}
\item identity label of the contribution
\item archive number
\item notes whether the contribution already was broadcast in the first,
second or third news broadcast of that day
\item initial position of the contribution on the tape
\item end position of the contribution on the tape
\item notes whether original sound is available
\item length of the text to be stored, if needed
\item a text to be stored, if needed
\end{itemize}

Such data structures can be described in a problem oriented way as
structures; the above structure ``Contribution'', e.g., is declared as
follows:

\begin{tabbing}
{\bf DCL} \= {\bf [} \= \kill
{\bf DCL} \>         \> Contribution {\bf STRUCT} \\
          \> {\bf [} \> (IdentNo, Archive) {\bf FIXED},\\
          \>         \> already\_broadcast(3) {\bf BIT}(1),\\
          \>         \> (Start, End) {\bf FIXED},\\
          \>         \> OriginalSound {\bf BIT}(1),\\
          \>         \> TextLength {\bf FIXED},\\
          \>         \> Text {\bf CHAR}(200) {\bf ]};
\end{tabbing}

(A structure is encapsulated in square brackets; they are printed boldly in
the text to distinguish them from the meta-linguistic characters ``[''
and ``]''. When writing down the program, only square brackets or their
substitutional symbols ``(/'' and ``/)'' are used.)

In contrast to array elements, the components of a structure are not
addressed via the joint identifier and an index, but via the joint
identifier and the identifier denoted in their declaration, where both
identifiers are separated by a full-stop.

Example:

By the statement

Contribution.Start := 1027;

value 1027 is assigned to the component Start of structure Contribution.

As the declaration of contribution shows, components of structures may be
arrays; as usual, the array elements are then addressed with their
indexed identifier preceded by the structure identifier, such as in the
form

{\bf IF} Contribution.already\_broadcast(i) {\bf THEN...FIN};

A structure component, however, can also be a structure itself, so that not only
linear, but also hierarchical data structures can be modeled.

Example:

A staff file shall contain descriptions of the staff members; these
descriptions each have the structure shown in Figure~\ref{mitarbeiter}.
\newpage

\begin{figure}
\setlength{\unitlength}{0.00087500in}%
\begin{picture}(4377,2735)(46,-2103)
\thicklines
\put(676,-736){\line( 1, 0){900}}
\put(1351,389){\line( 0,-1){2475}}
\put(1351,-2086){\line( 1, 0){225}}
\put(1351,-1636){\line( 1, 0){225}}
\put(1351,389){\line( 1, 0){225}}
\put(2386,389){\line( 1, 0){765}}
\put(3376,614){\line(-1, 0){225}}
\put(3151,614){\line( 0,-1){450}}
\put(3151,164){\line( 1, 0){225}}
\put(2566,-736){\line( 1, 0){810}}
\put(3376,-286){\line(-1, 0){225}}
\put(3151,-286){\line( 0,-1){900}}
\put(3151,-1186){\line( 1, 0){225}}
\put( 46,-826){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Person}}}
\put(1711,-826){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Address}}}
\put(1711,-1726){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Sex}}}
\put(3466,524){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}FirstName}}}
\put(3466,
74){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}SecondName}}}
\put(3511,-376){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Street}}}
\put(3466,-826){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}PostCode}}}
\put(3511,-1276){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Town}}}
\put(1666,-2076){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}\ldots}}}
\put(1711,299){\makebox(0,0)[lb]{\smash{\SetFigFont{12}{14.4}{rm}Name}}}
\end{picture}
\caption{\label{mitarbeiter}}
\end{figure}

The components Name and Address are structures themselves, namely
substructures of the main structure Person which can be declared as follows:


\begin{tabbing}
{\bf DCL} Person \= {\bf [} \= Address \= {\bf [} \= \kill
{\bf DCL} Person \>         \> {\bf STRUCT} \> \> \\
                 \> {\bf [} \> Name    \>         \> {\bf STRUCT}\\
                 \>         \>         \> {\bf [} \> FirstName {\bf CHAR}(10),\\
                 \>         \>         \>         \> SecondName {\bf CHAR}(15),\\
                 \>         \>         \> {\bf ]},\> \\
                 \>         \> Address \>         \> {\bf STRUCT}\\
                 \>         \>         \> {\bf [} \> str {\bf CHAR}(15);\\
                 \>         \>         \>         \> PostCode {\bf FIXED},\\
                 \>         \>         \>         \> Town {\bf CHAR}(15)\\
                 \>         \>         \> {\bf ]},\> \\
                 \>         \> Sex     \>         \> {\bf CHAR}(1)\\
                 \>         \> ...     \>         \> \\
                 \> {\bf ]};\>         \>         \> \\
...              \>         \>         \>         \>
\end{tabbing}

Therefore, substructures can be addressed via their identifier and the
preceding identifiers of the respective higher level structures.

The type of a structure is determined by the arrangement of its components
and their types. Structures of the same type can be combined into arrays:

{\bf DCL} Contribution(20) {\bf STRUCT}...;  /* see above */

Thus, any component of a structure is generally addressed with its (if
needed, indexed) identifier and the (if needed, indexed) identifiers of
all higher level structures, where the names are separated by a full-stop,
each.

Example:

Person.Name.FirstName := 'OTTO';\\
{\bf IF} Contribution(i).already\_broadcast(j) {\bf THEN...FIN};

The general form of the structure declaration reads:

StructureDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} StructureDenotation [ , StructurDenotation ] $^{...}$ ;

StructureDenotation ::=\\
\x IdentifierDenotation\S MainStructure [ DimensionAttribute ][ AllocationProtection ]\\
\x TypeStructure [ GlobalAttribute ][ InitialisationAttribute ]

TypeStructure ::=\\
\x {\bf STRUCT [} StructureComponent [ , StructureComponent ] $^{...}$ {\bf ]}

StructureComponent ::=\\
\x IdentifierDenotation TypeAttributeInStructureDeclaration

TypeAttributeInStructureDeclaration ::=\\
\x [ DimensionAttribute ] \\
\x \{ SimpleType $\mid$ TypeReference $\mid$ Identifier\S ForType $\mid$ TypeStructure \}

The general form of the structure specification reads:

StructureSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} StructureDenotationS [ , StructureDenotationS] $^{...}$ ;

StructureDenotationS ::=\\
\x IdentifierDenotation\S MainRecord [ VirtualDimensionAttribute ]\\
\x [ AllocationProtection ] TypeRecord \{ GlobalAttribute $\mid$ IdentificationAttribute\}


\section{Type Definition (TYPE)} % 5.12

A certain structure, e.g., can occur as parameter, as substructure in other
structures, or as type of the transmission data of a data station.  Each
time, the type of this structure must be stated, which might cause
extensive writing effort for complex structures. For that reason, and to
increase the readability of the program, the type of a structure can be
defined as new data type under a freely selectable identifier, and used
under this identifier, e.g., to declare variables of this data type.

Examples:
\begin{enumerate}
\item
\begin{tabbing}
\x \= {\bf TYPE} \= {\bf [} \= \kill
{\bf PROBLEM}; \> \> \> \\
  \> ... \> \> \\
  \> {\bf TYPE} \>         \> Message {\bf STRUCT}\\
  \>            \> {\bf [} \> (IdentNo, Archive) {\bf FIXED},\\
  \>            \>         \> already\_broadcast(3) {\bf BIT}(1),\\
  \>            \>         \> (Start, End) {\bf FIXED},\\
  \>            \>         \> OriginalSound {\bf BIT}(1),\\
  \>            \>         \> TextLength {\bf FIXED},\\
  \>            \>         \> Text {\bf CHAR}(200) {\bf ]};\\
  \>            \>         \> \\
  \> {\bf DCL}  \>         \> Content\_VTR {\bf DATION INOUT} Message...;\\
  \>            \>         \> \\
  \> Coord:     \>         \> {\bf TASK};\\
  \>            \>         \> {\bf DCL} Contribution Message;\\
  \>            \>         \> ...\\
  \>            \>         \> {\bf READ} Contribution {\bf FROM} Content\_VTR;\\
  \>            \>         \> ...\\
  \>            \>         \> {\bf END}; ! Coord\\
  \> ...        \>         \>
\end{tabbing}
\item A task controls certain devices; it receives the control orders
from another task. Since occasionally more than one order can be
existing and the orders can be of different urgency, they are buffered
in form of a queue. Let the structure of the orders be of the (re-defined)
type OrderType; let this even contain the urgency criteria for
arranging new orders. The reference variables Next\_Order and Free,
respectively, as shown in Figure~\ref{kette}, point at the order to be treated next or the next free position
in the queue order string, respectively; starting with Free, let the free
positions be interlinked as well. Let the queue be not longer than 10
elements.


\begin{figure}
\setlength{\unitlength}{0.0007500in}%
\begin{picture}(7539,2889)(124,-2110)
\thicklines
\put(451,-1411){\framebox(1035,1350){}}
\put(2071,-1411){\framebox(1035,1350){}}
\put(3646,-1411){\framebox(1035,1350){}}
\put(6121,-1411){\framebox(1035,1350){}}
\thinlines
\put(451,-961){\line( 1, 0){1035}}
\put(946,-1276){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Succ}}}
\put(901,-421){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Order}}}
\put(901,-781){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots}}}
\put(2071,-961){\line( 1, 0){1035}}
\put(2566,-1276){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Succ}}}
\put(2521,-421){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Order}}}
\put(2521,-781){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(3646,-961){\line( 1, 0){1035}}
\put(4141,-1276){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Succ}}}
\put(4096,-421){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Order}}}
\put(4096,-781){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(6121,-961){\line( 1, 0){1035}}
\put(6616,-1276){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Succ}}}
\put(6571,-421){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Order}}}
\put(6571,-781){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(4681,-1186){\line( 1, 0){270}}
\put(4951,-1186){\line( 0,-1){450}}
\put(4951,-1636){\line(-1, 0){4815}}
\put(136,-1636){\line( 0, 1){1260}}
\put(136,-376){\vector( 1, 0){315}}
\put(3106,-1186){\line( 1, 0){270}}
\put(3376,-1186){\line( 0, 1){1575}}
\put(3376,389){\line( 1, 0){2250}}
\put(5626,389){\line( 0,-1){765}}
\put(5626,-376){\line( 1, 0){495}}
\put(1486,-1186){\line( 1, 0){315}}
\put(1801,-1186){\line( 0,-1){675}}
\put(1801,-1861){\vector( 1, 0){450}}
\put(2566,614){\vector( 0,-1){675}}
\put(4186,614){\line( 0,-1){180}}
\put(4186,344){\vector( 0,-1){405}}
\put(7156,-1186){\line( 1, 0){495}}
\put(7651,-1186){\line( 0, 1){1575}}
\put(7651,389){\vector(-1, 0){450}}
\put(2566,659){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Next\_Order}}}
\put(4186,659){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Free}}}
\put(2476,-1861){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(5401,-736){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(7021,389){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}\ldots }}}
\put(946,-2086){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}1}}}
\put(2521,-2086){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}2}}}
\put(4141,-2086){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}3}}}
\put(6616,-2086){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}10}}}
\end{picture}
\caption{}
\label{kette}
\end{figure}


The order string can be declared as follows:

\begin{tabbing}
{\bf TYPE} \= \x \= \x \= \kill
... \> \> \> \\
{\bf TYPE} \> StringElement {\bf STRUCT} \> \> \\
           \>   \> {\bf [} \> Order  OrderType,\\
           \>   \>         \> ...,\\
           \>   \> {\bf ]};\\
{\bf DCL}  \> OrderString (10) StringElement, \> \> \\
           \> (Next\_Order, Free) {\bf REF} StringElement;\\
... \> \> \>
\end{tabbing}

After initialising and arranging various orders, a finished order can be
removed from the queue as follows (let Help be a variable of type REF
string element):

...\\
Help := Next\_Order;
Next\_Order := Next\_Order.Succ;\\
Help.Succ := Free\\
Free := Help\\
...

These statements are also further examples for implicit
dereferentiation. The order string can be initialised as follows:

{\bf FOR} i {\bf TO} 9\\
\x {\bf REPEAT} \\
\x \x OrderString(i).Succ:=OrderString(i+1);\\
\x {\bf END};\\
OrderString(10).Succ:={\bf NIL};
\end{enumerate}

Generally, a new data type is defined as follows:

TypeDefinition ::=\\
\x {\bf TYPE} Identifier\S ForType \{ SimpleType $\mid$ TypeStructure \}

The definition of a new data type has to take place before its use.
Besides, data types defined at module level, can be used in all tasks
and procedures of the module; the usability of locally defined data
types depends on the rules of the block structure.

In contrast to global objects, re-defined data types can only be used
in the module where they are defined. Thus, type definitions for
global objects have to be repeated in all used modules.

Example:

\begin{tabbing}
\x {\bf TYPE} T {\bf STRUCT} [...]; \hspace{2cm} \= \kill

{\bf MODULE} (ModuleA);            \> {\bf MODULE} (ModuleB);\\
{\bf PROBLEM;}                      \> {\bf PROBLEM;}\\
                                    \> \\
\x {\bf TYPE} T {\bf STRUCT} [...]; \> \x {\bf TYPE} T {\bf STRUCT} [...];\\
\x ...                              \> \x ... \\
\x {\bf DCL} x T {\bf GLOBAL;}      \> \x {\bf SPC} x T {\bf GLOBAL}(ModuleA); \\
\x ...                              \> \x ...\\
{\bf MODEND;}                       \> {\bf MODEND;}
\end{tabbing}


\section{The Initialisation Attribute (INITIAL)}   % 5.13

The initialisation attribute allows to assign initial values to
variables upon their declaration. For variables with assignment
protection (see 5.15), this is the only possibility of allocating
values. The initialisation attribute is given as last attribute of the
respective declaration:

InitialisationAttribute ::=\\
\x \{ {\bf INITIAL $\mid$ INIT} \} ( InitElement [ , InitElement ] $^{...}$ )

InitElement ::=\\
\x Constant\\
\x $\mid$ Identifier\S NamedConstant\\
\x $\mid$ ConstantExpression\\
\x ...

Constant ::=\\
\x Integer\\
\x $\mid$ FloatingPointNumber\\
\x $\mid$ BitStringConstant\\
\x $\mid$ TimeConstant\\
\x $\mid$ DurationConstant\\
\x $\mid$ {\bf NIL}

The type of the given init element has to be compatible with the type of
the declared variable in accordance with the rules for assignment (cf.
6.3):

Example:

...
{\bf DCL} number\_devices {\bf FIXED INIT}(12),\\
\x (UGR, OGR) {\bf FIXED INIT}(2,15);\\
...\\
{\bf FOR} i {\bf FROM} 1 {\bf TO} number\_devices\\
...

Here, the variables number\_devices, UGR, and OGR have the values 12, 2
and 15, i.e., the elements of a declared constant list are assigned in
the sequence of writing down the declared identifier list.

Arrays and structures can also be initialised at the position of
declaration. For all structure components, one initial value has to be
given, each. For arrays, the initialisation list may be shorter than the
number of array elements. In this case, the last initial value for the
remaining elements is used repeatedly.

Example:

\begin{tabbing}
{\bf DCL} \= all\_sixes \= {\bf INIT}(21337, \= HouseNumber \= \kill
... \> \> \> \> \\
{\bf DCL} \> Address \> {\bf STRUCT}[ \> PostNumber  \> {\bf FIXED},\\
          \>         \>               \> Town        \> {\bf CHAR}(20),\\
          \>         \>               \> Street      \> {\bf CHAR}(20),\\
          \>         \>               \> HouseNumber \> {\bf FIXED \hspace{1cm} ]}\\
          \>         \> {\bf INIT}(21337, 'Lueneburg', 'Erbstorfer Landstr.', 14); \> \> \\
{\bf DCL} \> colours \> (3)           \> {\bf CHAR}(7) \> {\bf INIT} ('black\ \ ', 'white\ \ ', 'red\ \ \ \ ');\\
{\bf DCL} \> all\_sixes \> (6)        \> {\bf FIXED}  \> {\bf INIT} (6);\\
... \> \> \> \>
\end{tabbing}

The initialisation list can, besides constants, even contain identifiers
of named constants as well as expressions calculable by the compiler
(cf. 5.15.1 and 5.15.2).

\begin{tobedone}
\section{Assignment Protection (INV)}    % 5.14

Variables can be declared with an assignment protection,i.e. the attribute
INV (from ``invariant''), in order to forbid --- apart from
initialisation --- assignments to these variables. The attribute INV is
noted immediately before the type attribute.

Example:

...\\
{\bf DCL} Pi {\bf INV FLOAT INIT}(3.141);\\

Pi := 3;  /* results in error message of the compiler */

An assignment protection which once is associated with an object in its
declaration cannot be revoked; thus it must be considered in
specifications of this object, but also when transmitting it as actual
procedure parameter or when using it as value of reference variables. On
the other hand, in one of this ways an assignment protection may arise
which was not associated in the declaration.

Example:

\begin{tabbing}
{\bf CALL} \= pi {\bf FLOAT IDENT} (Pi); \= \kill
... \> \> \\
P:  \> {\bf PROC}(A (,) {\bf INV FIXED IDENT}, x {\bf FLOAT IDENT}); /* procedure body */ \> \\
    \> {\bf END}; ! P \> \\
    \> \> \\
{\bf DCL} \> Tab(10,20) {\bf FIXED}, \> \\
          \> Pi {\bf INV FLOAT INITIAL}(3.141), \> \\
          \> R1 {\bf REF FLOAT}, \> \\
          \> R2 {\bf REF INV FIXED}; \> \\
... \> \> \\
    \> \> \\
{\bf SPC} \> pi {\bf FLOAT IDENT} (Pi); \> /* wrong */ \\
... \> \> \\
    \> \> \\
{\bf CALL} \> P (Tab, Pi); \> /* wrong */ \\
R1:=Pi;    \>              \> /* wrong */ \\
R2:=Tab(5,7); \> \>
\end{tabbing}

The specification of pi is wrong, because assignments to pi are allowed,
and thus the assignment protection of Pi is circumvented.

The call of P is wrong, because the formal parameter x belonging to Pi
is specified without assignment protection, and thus a (forbidden) value
change of Pi could happen in the body of P via an assignment to x.

In contrast, in the same call, the parameter transmission from Tab to A
is correct, because only an assignment protection for Tab arises which
was not introduced yet.

The assignment R1:=Pi is not permitted, because otherwise the assignment
protection for Pi via (allowed) assignments to CONT R1 could be revoked.
The assignment R2:=Tab(5,7), however, is permitted; a value modification
of the tabular element via CONT is not possible.

\subsection{Named Constants (INV Constants)}   % 5.14.1

The compiler treats objects of type FIXED, BIT, CHAR(1), CLOCK and
DURATION declared with attribute INV as (named) constants. The names of
these objects may be used after their declaration (with initialisation)
for declaring and initialising further objects. For this, they may be
applied as dimension boundary denotation in array declarations as well
as in initialisation lists.

Example:

A surveillance program shall be adapted for various projects with
different numbers of embedded controllers. The number of message
buffers and synchronising variables belonging to them (cf. 9.3) can be
adapted easily by changing the constant NumberControls:

...\\
{\bf DCL} NumberControls {\bf INV FIXED INIT}(11);\\

{\bf DCL} MessageBuffer (NumberControls) {\bf CHAR}(100); \\
{\bf DCL} BufferAccess (NumberControls) {\bf BOLT};\\
...

For a further project with another number of controls, only the named
constant NumberControls has to be adapted to the actual conditions. The
memory areas dependent on that are adapted by the compiler.

Since the compiler does not generate any run time objects for named
objects, they may not be assigned to a reference variable. Likewise,
they cannot be used as actual parameters of a procedure, if the formal
parameter was specified with the IDENTICAL attribute or as reference
variable (cf. 8.2).

\subsection{Constant Expressions (of Type FIXED)}   % 5.14.2

In all positions where the compiler expects constants, also constant
expressions may occur. These expressions may only contain constants
(also named constants) as operands. They are evaluated by the compiler,
and the results are inserted in the respective positions.

ConstantExpression ::=\\
\x \{ + $\mid$ - \} FloatingPointNumber\\
\x $\mid$ \{ + $\mid$ - \} DurationConstant\\
\x $\mid$ constant-FIXED-Expression

Constant-FIXED-Expression ::=\\
\x Term [ \{ + $\mid$ - \} Term ] $^{...}$

Term ::=\\
\x Factor [ \{ $^*$ $\mid$ // $\mid$ {\bf REM} \} Factor ] $^{...}$

Factor ::=\\
\x [ + $\mid$ - ] \\
\x \{ integer \\
\x \x $\mid$ (Constant-FIXED-Expression)\\
\x \x $\mid$ {\bf TOFIXED} \{ CharacterStringConstant\S OfLength1 $\mid$ BitStringConstant \}\\
\x \x $\mid$ Identifier\S NamedConstant\\
\x \} \\
\x [ {\bf FIT} constant-FIXED-Expression ]

Constant expressions of type FIXED can, e.g., be applied in the
following positions:
\begin{itemize}
\item denotation of dimension boundaries in array declarations,
\item precision declaration (for FIXED and FLOAT variables),
\item length definition (for CHAR and BIT variables),
\item in initialisation lists (also for PRESET),
\item priority definition in task declarations and task statements
\item in the constant lists of the CASE statement
\item on the right side of an assignment
\end{itemize}

Often, several objects of a program (variables, constants) are dependent
from one another. If this dependence can be described by a simple
formula, a program can probably be configured by just adapting few
constants.

Example:

A warning shall be given, if a buffer system is filled up to the last 10
\%:

\begin{tabbing}
{\bf DCL} WarnBoundary \= {\bf INV} \= \kill
... \> \> \\
{\bf DCL} MaxBuffer    \> {\bf INV} \> {\bf FIXED INIT}(1000); \\
{\bf DCL} WarnBoundary \> {\bf INV} \> {\bf FIXED INIT}(MaxBuffer - MaxBuffer // 10);\\
{\bf DCL} Buffer (MaxBuffer) \>     \> {\bf FIXED};\\
{\bf DCL} ActualBufferIndex \>     \> {\bf FIXED INIT}(1);
\end{tabbing}
... \\
ActualBufferIndex := ActualBufferIndex+1;\\
{\bf IF} ActualBufferIndex $>$ WarnBoundary\\
{\bf THEN} /* output of warning */ \\
{\bf FIN};\\
...
\end{tobedone}

\chapter{Expressions and Assignments}   % 6

\section{Expressions}   % 6.1

Expressions are used for various language forms, e.g.,

\begin{itemize}
\item as index when addressing array elements:\\
      Identifier\S Array(Expression,Expression)\\
      e.g., Tab(K,2*i)
\item as reference value for the return statement in function procedures
      (see 8.1):\\
      {\bf RETURN}(Expression);\\
      e.g., {\bf RETURN}(No);
\item as parameter when calling procedures (see 8.2):\\
      ListOfActualParameters ::= (Expression [ , Expression ] $^{...}$ )\\
      e.g., {\bf CALL} P(A, Tab (K, 2*i));
\item as start condition for tasks (see 9.2.1):\\
      {\bf AT} Expression\S Time\\
      e.g., {\bf AT} 12:00:00 {\bf ACTIVATE} T;
\end{itemize}

These examples show that an expression at least can be

\begin{itemize}
\item a constant
\item an identifier
\item an indexed identifier or
\item an arithmetical expression (e.g., 2*i).
\end{itemize}

Identifiers, indexed identifiers and names of structure components are
generally summarised under the notion ``Name'':

Name ::= Identifier [ (Index [ , Index ] $^{...}$ ) ] [ . Name ] $^{...}$

Index ::= Expression\S WithIntegerAsValue

Examples:

A, A(3), A(i,j,2*k), A.B, A.B.C, A(3).B.C(i,j)

The identifiers of the components of a structure can be selected
independently from the identifiers outside the structure:

{\bf DCL} Person {\bf STRUCT}..., /* see above */ \\
\x Town {\bf CHAR}(15);\\
\x ...\\
Person.Address.Town := Town;

Generally, the names denoted in expressions have to be names of scalar
variables; however, in the expression lists of the output statements
(cf. 10.4, 10.5, 10,6, 10.7) even identifiers of arrays may be given.

In general, an expression has the form

Expression::=\\
\x [ MonadicOperator ] Operand [ DyadicOperator Expression ] $^{...}$

Monadic operators have only one operand, dyadic operators have two
operands.

MonadicOperator ::=\\
\x + $\mid$ - {\bf $\mid$ NOT $\mid$ ABS $\mid$ SIGN $\mid$ LWB $\mid$ UPB $\mid$ SIZEOF $\mid$ CONT \\
\x $\mid$ TOFIXED $\mid$ TOFLOAT $\mid$ TOBIT $\mid$ TOCHAR $\mid$ ENTIER $\mid$ ROUND} \\
\x $\mid$ Identifier\S UserDefinedMonadicOperator

DyadicOperator ::=\\
\x + $\mid$ - $\mid$ * $\mid$ / $\mid$ // $\mid$ {\bf REM} $\mid$ ** \\
\x $\mid$ $<$ $\mid$ {\bf LT} $\mid$ $>$ $\mid$ {\bf GT} $\mid$ $<$= $\mid$ {\bf LE} $\mid$ $>$= $\mid$ {\bf GE} $\mid$ == $\mid$ {\bf EQ} $\mid$ /= $\mid$ {\bf NE} \\
\x $\mid$ {\bf AND $\mid$ OR $\mid$ EXOR} $\mid$ $><$ $\mid$ {\bf CAT} $\mid$ $<>$ $\mid$ {\bf CSHIFT $\mid$ SHIFT $\mid$ LWB $\mid$ UPB \\
\x $\mid$ IS $\mid$ ISNT $\mid$ FIT} \x $\mid$ Identifier\S UserDefinedDyadicOperator

Operand ::=\\
\x Constant $\mid$ Name $\mid$ FunctionCall $\mid$ ConditionalExpression $\mid$ Dereferentiation $\mid$\\
\x StringExcerpt $\mid$ (Expression)

Examples:

\begin{itemize}
\item -A + B * C - D/E**2
\item (A - B) / (A + B)
\item F(Tab(K, 2*i)) / (F(i) - 3)
\item A $<$ B {\bf OR} A $<$ C
\item ProcessImage\_new {\bf AND NOT} ProcessImage\_old\\
      (the result has 1 in {\it that} bit place where ProcessImage\_old
      has 0 and ProcessImage\_new has 1)
\item Xcoord $><$ Ycoord $><$ Zcoord\\
      (the three bit strings are concatenated to one bit string)
\end{itemize}

The conditional expression can be useful, e.g., in assignments or
function procedures (see 8); it has the following form:

ConditionalExpression ::=\\
\x {\bf IF} Expression\S WithValueOfType-BIT(1)\\
\x \x {\bf THEN} Expression {\bf ELSE} Expression {\bf FIN}

If the calculation of the expression following IF yields value '1'B
(true), the expression following THEN is executed; if the value equals '0'B (wrong), the expression after ELSE
is executed.

Examples:

\begin{enumerate}
\item The function procedure max shall state and return the greater one
      of two floating point numbers.

      max: {\bf PROC}((X,Y){\bf FLOAT}) {\bf RETURNS} ({\bf FLOAT});\\
      \x {\bf RETURN}({\bf IF} X$>$Y {\bf THEN} X {\bf ELSE} Y {\bf FIN});\\
      \x {\bf END};\\
      ... \\
      A := max(B,C)/2.0 ;

\item Equivalent with this assignment is the following one:

      A := ( {\bf IF} B$>$C {\bf THEN} B {\bf ELSE} C {\bf FIN})/2.0;
\end{enumerate}

The importance of dereferentiation was treated in 5.6, References. The
general form reads:

Dereferentiation::=\\
\x {\bf CONT} \{ Name\S Reference $\mid$ FunctionCall \}

The i-th bit of a bit string can be addressed with the help of the
standard attribute BIT(i) which --- separated by a full-stop --- is mentioned
behind the name of the bit string. Therefore, a bit string B of length
lg is considered as structure B, which as only component has a
one-dimensional array BIT of length lg, whose elements are of type
BIT(1). Analogously, the i-th character of a character string Z can be
addressed with Z.CHAR(i) or Z.CHARACTER(i). The bits or characters of a
bit or character string are numbered from the left to the right, starting with 1.

Example:

\begin{tabbing}
{\bf DCL} Byte {\bf BIT}(8), \= \kill
... \> \\
{\bf DCL} Byte {\bf BIT}(8), \> \\
\x Bt {\bf BIT}(1),   \> \\
\x i {\bf FIXED};     \> \\
... \> \\
Byte:='11101111'B;            \> \\
Bt:=Byte.{\bf BIT}(4);        \> /* Bt obtains value '0'B */\\
Byte.{\bf BIT}(2):='0'B;      \> /* Byte has value '10101111'B */\\
i:=8; \> \\
Byte.{\bf BIT}(i):=Bt;        \> /* Byte has value '10101110'B */
\end{tabbing}

Furthermore, segments of bit or character strings containing several
bits or characters can be addresses analogously; the general form of
addressing is:

StringPart::=\\
\x Name\S String. \{ {\bf BIT $\mid$ CHAR $\mid$ CHARACTER} \} (Expression\S Start [ : Expression\S End ] )

The expressions Start and End must have integer values. End must be
greater than or equal to Start, and both values must be within the
declared string length.
\begin{added}
If Start or End is outside of the boundaries of  the CHAR string
the CharacterIndexOutOfRangeSignal ins induced.
If Start or End is outside of the boundaries of  the BIT string
the BitIndexOutOfRangeSignal is induced.
\end{added}

The result of such a string segment expression has type BIT(lg) or
CHAR(lg), resp., where ``lg := End - Start + 1'' is holds. For bit
strings, the compiler must be able to calculate length ``lg'', so that
further type checks are possible when using the string segment
expression.

The following cases are distinguished by the compiler:
\begin{enumerate}
\item Name.\{ {\bf BIT $\mid$ CHAR} \}(Expression)
\item Name.\{ {\bf BIT $\mid$ CHAR} \}(constant-FIXED-Expression: constant-FIXED-Expression)
\item Name.\{ {\bf BIT $\mid$ CHAR} \}(Expression1: Expression2 + FIXED-Constant)
\item Name.{\bf CHAR}(Expression\S Start: Expression\S End)
\end{enumerate}

In case (1), the length of the string segment equals 1, ``Expression''
denotes the bit number or the character position, respectively.

In case (2), the compiler calculates the values of the two constant
expressions and determines the length ``lg := Constant\S End -
Constant\S Start + 1''.

In case (3), Expression1 and Expression2 must be equal. Thus, the length
results from the additive constant: ``lg := FIXED-Constant + 1''.

In case (4), the compiler cannot calculate the length of the string
segment! This is not allowed for bit strings. Case (4) provides a
variable character string, i.e., the length is not calculable until run
time. Variable character strings can be used anywhere, besides in
conjunction with the CAT operator.

Example:

Let a transport vehicle in a warehouse be connected to a digital input
via 16 consecutive positions. Let the meaning of the connectors be as
follows:

\begin{tabular}{l@{ : }l}
connector 1--8   & X coordinate\\
connector 9--12  & Y coordinate\\
connector 13     & Z coordinate\\
connector 14--16 & further parameters
\end{tabular}

When positioning has been completed, the actual position shall be
retrieved and checked.

\begin{removed}
{\bf MODULE};\\
{\bf SYSTEM};\\
\x RFZ : DIGE(1)*0*1, 16;\\
\x ...\\
{\bf PROBLEM};\\
\x {\bf SPC} RFZ {\bf DATION IN BIT}(16);\\
\x {\bf DCL} Rfz {\bf DATION IN BIT}(16) {\bf CREATED}(RFZ);\\
\x ...\\
\x Control:{\bf TASK};\\
\x \x {\bf DCL} Rfz\_State {\bf BIT}(16),\\
\x \x \x Xcoord {\bf BIT}(8), Ycoord {\bf BIT}(4), Zcoord {\bf BIT}(1);\\
\x \x ...\\
\x \x \x /* positioning */ \\
\x \x {\bf TAKE} Rfz\_State {\bf FROM} Rfz;\\
\x \x Xcoord:=Rfz\_State.{\bf BIT}(1:8);\\
\x \x Ycoord:=Rfz\_State.{\bf BIT}(9:12);\\
\x \x Zcoord:=Rfz\_State.{\bf BIT}(13);\\
\x \x \x /* checking of the actual position */ \\
\x \x ...\\
\x {\bf END}; ! Control\\
\x ...
\end{removed}

\begin{added}
{\bf MODULE};\\
{\bf SYSTEM};\\
\x RFZ : DIGE(1)*0*1, 16;\\
\x ...\\
{\bf PROBLEM};\\
\x {\bf SPC} RFZ {\bf DATION};\\
\x ...\\
\x Control:{\bf TASK};\\
\x \x {\bf DCL} Rfz\_State {\bf BIT}(16),\\
\x \x \x Xcoord {\bf BIT}(8), Ycoord {\bf BIT}(4), Zcoord {\bf BIT}(1);\\
\x \x ...\\
\x \x \x /* positioning */ \\
\x \x {\bf TAKE} Rfz\_State {\bf FROM} Rfz;\\
\x \x Xcoord:=Rfz\_State.{\bf BIT}(1:8);\\
\x \x Ycoord:=Rfz\_State.{\bf BIT}(9:12);\\
\x \x Zcoord:=Rfz\_State.{\bf BIT}(13);\\
\x \x \x /* checking of the actual position */ \\
\x \x ...\\
\x {\bf END}; ! Control\\
\x ...
\end{added}


This program part can be programmed more flexibly by additionally
recording the initial positions of the partial strings Xcoord, Ycoord
and Zcoord in variables Init\_X, Init\_Y, Init\_Z.

Control: {\bf TASK};\\
\x ... \\
\x {\bf DCL} (Init\_X, Init\_Y, Init\_Z) {\bf INV FIXED INIT}(1, 9, 13);\\
\x ... \\
\x Xcoord := Rfz\_State.{\bf BIT}(Init\_X:Init\_X+7);\\
\x Ycoord := Rfz\_State.{\bf BIT}(Init\_Y:Init\_Y+3);\\
\x Zcoord := Rfz\_State.{\bf BIT}(Init\_Z);\\
\x ... \\
{\bf END}; ! Control

Assignments to string segments are possible, too; furthermore, they may
occur as operands in expressions.

Parts of an expression may be written in brackets to influence the order
of the expression calculation (cf. 6.3), e.g.

A - ( B + C )

\subsection{Monadic Operators}   % 6.1.1

Table~\ref{tab71} describes for each listed monadic operator
\begin{itemize}
\item which type the operand may have
\item which type the result (of the operation) has, and
\item the meaning of the operator.
\end{itemize}
In Tables~\ref{tab71} to \ref{tab74}, ``a'' stands for any operand, g for the precision, and lg for
the length of the operand.

\begin{table} % 7.1 
\begin{center}
\caption{Monadic operators for numerical, temporal and bit values}
\label{tab71}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|} 
\hline
{\bf Expression} & {\bf Operand type} & {\bf Result type} & {\bf Meaning of operator}\\ \hline

+a               & FIXED(g)          & FIXED(g)         & identity\\
                 & FLOAT(g)          & FLOAT(g)         & \\
                 & DURATION          & DURATION         & \\ \hline

-a               & FIXED(g)          & FIXED(g)         & changing the sign of a\\
                 & FLOAT(g)          & FLOAT(g)         & \\
                 & DURATION          & DURATION         & \\ \hline

NOT a            & BIT(lg)           & BIT(lg)          & inverting all bit positions of a\\ \hline

ABS a            & FIXED(g)          & FIXED(g)         & absolute value of a\\
                 & FLOAT(g)          & FLOAT(g)         & \\
                 & DURATION          & DURATION         & \\ \hline

SIGN a           & FIXED(g)          & FIXED(1)         & determining the sign of a\\ 
                 & FLOAT(g)          &                  & 1 for a $>$ 0\\
                 & DURATION          &                  & 0 for a = 0\\   
                 &                   &                  & -1 for a $<$ 0\\
\hline
\end{tabular}
\end{center}
\end{table}

Examples (Table~ref{tab71}):

\begin{tabbing}
{\bf DCL} (X, Y) \= {\bf FLOAT},  \= \\
\x        B      \> {\bf BIT}(4); \> \\
X := 3;            \> \> \\
B := '1001'B       \> \> \\
Y := -X;           \> \> /* Y has value -3 */\\
B := {\bf NOT} B;  \> \> /* B has value '0110'B */\\
\end{tabbing}

In general, in an assignment, the type of the variable given to the left
of the assignment character must match the type of the value of the
assigned expression (cf. section 6.3). Particularly, only values of type
integer may be assigned to variables of integers. Furthermore, the types
of operands of dyadic operators must be compatible.

Thus, several operators are provided which cause a possibly needed
conversion of the type of objects.

\begin{table} % 7.2
\begin{center}
\caption{Monadic operators for explicit type conversions}
\label{tab72}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|}
\hline
{\bf Expression} & {\bf Operand type} & {\bf Result type} & {\bf Meaning of operator}\\ \hline

TOFIXED a        & CHARACTER(1)      & FIXED(7)         & ASCII code for operand character\\ \cline{2-4}
                     
                 & BIT(lg)           & FIXED(g)         & interpreting the bit pattern of the\\
                 &                   &                  & operand as an integer, with g = lg\\ \hline

TOFLOAT a        & FIXED(g)          & FLOAT(g)         & converting the operand into a\\
                 &                   &                  & floating point number\\ \hline
    
TOBIT a          & FIXED(g)          & BIT(lg)          & interpreting the operand as bit\\
                 &                   &                  & pattern, with lg = g\\ \hline

TOCHAR a         & FIXED             & CHARACTER(1)     & character for the ASCII code of the\\
                 &                   &                  & operand\\ \hline

ENTIER a         & FLOAT(g)          & FIXED(g)         & greatest integer less or equal than\\
                 &                   &                  & the operand\\ \hline
 
ROUND a          & FLOAT(g)          & FIXED(g)         & next integer according to DIN\\ \hline

CONT a           & REF type          & type             & explicit de-referentiation\\
\hline
\end{tabular}  
\end{center} 
\end{table}

Examples (Table \ref{tab72}):
\begin{modified}
\begin{tabbing}
A1 := {\bf ROUND} 3.4; \x \x \=  /* delivers 4 */ \kill 

{\bf DCL} A {\bf FIXED}(31),\\
\x A1 {\bf FIXED}(31);\\
\x (B, C) {\bf BIT}(15);\\
...\\
A1 := {\bf ENTIER} X//2; \> /* corresponds to A := (ENTIER X)//2; */ \\
A1:= {\bf ENTIER} (X/2.0);\\
A1 := {\bf ENTIER} 3.4; \> /* delivers 3 */ \\
A1 := {\bf ROUND} 3.4;  \>  /* delivers 4 */ \\
A1 := {\bf ENTIER} 3.5; \> /* delivers 3 */ \\
A1 := {\bf ROUND} 3.5;  \>  /* delivers 4 */ \\
A1 := {\bf ENTIER} -3.4; \> /* delivers -3 */ \\
A1 := {\bf ROUND} -3.4; \> /* delivers 4 */ \\
A1 := {\bf ENTIER} -3.5; \> /* delivers -3 */ \\
A1 := {\bf ROUND} -3.5; \> /* delivers -4 */ \\
C := {\bf TOBIT} A {\bf AND} B;\\
A := {\bf ROUND} X + {\bf TOFIXED} B;
\end{tabbing}
\end{modified}


\begin{table} % 7.3
\begin{center}
\caption{Monadic arithmetical operators}
\label{tab73}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|}
\hline 
{\bf Expression} & {\bf Operand type} & {\bf Result type} & {\bf Meaning of operator}\\ \hline
SQRT a           & FIXED(g) or        & FLOAT(g)          & square root of operand \\ \cline{1-1} \cline{4-4}
SIN a            & FLOAT(g)           &                   & sine of operand \\ \cline{1-1} \cline{4-4}
COS a            &                    &                   & cosine of operand \\ \cline{1-1} \cline{4-4}
EXP a            &                    &                   & $e^{a}$, with e=2.718281828459\\ \cline{1-1} \cline{4-4}
LN a             &                    &                   & natural logarithm of operand\\ \cline{1-1} \cline{4-4}
TAN a            &                    &                   & tangent of operand \\ \cline{1-1} \cline{4-4}
ATAN a           &                    &                   & arcus tangent of operand\\ \cline{1-1} \cline{4-4}
TANH a           &                    &                   & tangent hyperbolicus of operand\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table} % 7.4 Hat noch keinen Textbezug!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\begin{center}
\caption{Other monadic operators}
\label{tab74}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|}
\hline
{\bf Expression} & {\bf Operand type} & {\bf Result type} & {\bf Meaning of operand}\\ \hline

LWB a            & array              & FIXED(31)        & lower boundary of the first\\
                 &                    &                  & dimension of the operand array\\ \hline

UPB a            & array              & FIXED(31)        & upper boundary of the first\\
                 &                    &                  & dimension of the operand array\\ \cline{2-4}
                 & CHARACTER(lg)      & FIXED(15)        & result := Lg \\ \hline
 
SIZEOF a         & identifier         & FIXED(31)        & memory size of the identified\\
                 &                    &                  & object at run time in bytes\\ \cline{2-2} \cline{4-4}
                 & simple type        &                  & \\ \hline

SIZEOF a MAX     & REF CHAR( )        & FIXED(31)        & maximum length of the referenced\\
                 &                    &                  & character string variable\\ \hline

SIZEOF a LENGTH  & REF CHAR( )        & FIXED(31)        & actual length of the referenced\\
                 &                    &                  & character string variable\\ \hline

TRY a            & SEMA               & BIT(1)           & try of a REQUEST, '1'B\\
                 &                    &                  & if successful\\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Dyadic Operators}   % 6.1.2

Tables~\ref{tab75}, \ref{tab76}, \ref{tab77} and \ref{tab78} describe for each listed dyadic operator
\begin{itemize}
\item which type the operands may have
\item which type the result (of the operation) has, and
\item the meaning of the operator,
\end{itemize}
where
\begin{itemize}
\item ``op1'' and ``op2'', denote the first and second operand, resp.
\item g1, g2, ..., and lg1, lg2, ..., denote the precision and
lengths,resp., of the operands and the results.
\end{itemize}
Since the precision of the result of an addition, subtraction,
multiplication or division equals the maximum of the precisions of both
operands, it may happen that the overflows arising in these operations
are cut off. Hence, the dyadic operator FIT is provided.
It causes the conversion from the precision of operand ``a'' into the
precision of operand b. FIT has rank 1.

\begin{table} % 7.5
\begin{center}
\caption{Dyadic operators for numerical and temporal values}
\label{tab75}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
{\bf Expression} & {\bf Type}      & {\bf Type}      & {\bf Result type} & {\bf Meaning of operator}\\
                 & {\bf operand 1} & {\bf operand 2} &                   & \\ \hline
op1 + op2        & FIXED(g1)       & FIXED(g2)       & FIXED(g3)         & addition of the values of\\

                 & FIXED(g1)       & FLOAT(g2)       & FLOAT(g3)         & the operands op1 and op2\\
                 & FLOAT(g1)       & FIXED(g2)       & FLOAT(g3)         & \\
                 & FLOAT(g1)       & FLOAT(g2)       & FLOAT(g3)         & g3 = max (g1, g2)\\
                 & DURATION        & DURATION        & DURATION          & \\
                 & DURATION        & CLOCK           & CLOCK             & \\
                 & CLOCK           & DURATION        & CLOCK             & \\ \hline

op1 - op2        & FIXED(g1)       & FIXED(g2)       & FIXED(g3)         & subtraction of the values of\\
                 & FIXED(g1)       & FLOAT(g2)       & FLOAT(g3)         & the operands op1 and op2\\
                 & FLOAT(g1)       & FIXED(g2)       & FLOAT(g3)         & \\
                 & FLOAT(g1)       & FLOAT(g2)       & FLOAT(g3)         & g3 = max (g1, g2)\\
                 & DURATION        & DURATION        & DURATION          & \\
                 & CLOCK           & DURATION        & CLOCK             & \\
                 & CLOCK           & CLOCK           & DURATION          & \\ \hline

op1 * op2        & FIXED(g1)       & FIXED(g2)       & FIXED(g3)         & multiplication of the values of\\
                 & FIXED(g1)       & FLOAT(g2)       & FLOAT(g3)         & the operands op1 and op2\\
                 & FLOAT(g1)       & FIXED(g2)       & FLOAT(g3)         & \\
                 & FLOAT(g1)       & FLOAT(g2)       & FLOAT(g3)         & g3 = max (g1, g2)\\
                 & FIXED(g1)       & DURATION        & DURATION          & \\
                 & DURATION        & FIXED(g2)       & DURATION          & \\
                 & FLOAT(g1)       & DURATION        & DURATION          & \\
                 & DURATION        & FLOAT(g2)       & DURATION          & \\ \hline

op1 / op2        & FIXED(g1)       & FIXED(g2)       & FLOAT(g3)         & division of the values of\\
                 & FLOAT(g1)       & FIXED(g2)       & FLOAT(g3)         & the operands op1 and op2,\\
                 & FIXED(g1)       & FLOAT(g2)       & FLOAT(g3)         & if op2 $\neq$ 0\\
                 & FLOAT(g1)       & FLOAT(g2)       & FLOAT(g3)         & \\
                 & DURATION        & FIXED(g2)       & DURATION          & g3 = max (g1, g2)\\
                 & DURATION        & FLOAT(g2)       & DURATION          & g4 = 31\\
                 & DURATION        & DURATION        & FLOAT(g4)         & (dependent on implementation)\\ \hline

op1 // op2       & FIXED(g1)       & FIXED(g2)       & FIXED(g3)         & integer division of the values of\\
                 &                 &                 &                   & the operands op1 and op2\\
                 &                 &                 &                   & \\
                 &                 &                 &                   & g3 = max (g1, g2)\\ \hline

op1 REM op2      & FIXED(g1)       & FIXED(g2)       & FIXED(g3)         & remainder of the integer division\\
                 &                 &                 &                   & of the values of the operands op1\\
                 &                 &                 &                   & and op2\\ \hline

op1 ** op2       & FIXED(g1)       & FIXED(g2)       & FIXED(g1)         & exponentiation of the values\\
                 & FLOAT(g1)       & FIXED(g2)       & FLOAT(g1)         & of the operands op1 and op2\\ \hline

op1 FIT op2      & FIXED(g1)       & FIXED(g2)       & FIXED(g2)         & changing the precision of\\
                 & FLOAT(g1)       & FLOAT(g2)       & FLOAT(g2)         & operand op1 into the precision\\
                 &                 &                 &                   & of operand op2\\  
\hline
\end{tabular}
\end{center}
\end{table}

Example:

\begin{modified}
\begin{tabbing}
C:=(A {\bf FIT} C)*B; \x \x \= \kill

... \> \\
{\bf DCL} (A, B) {\bf FIXED}(15), \> \\
\x        C {\bf FIXED}(31);      \> \\
{\bf DCL} D {\bf BIT}(16);        \> \\
A:=32767;                         \> \\
B:=4;                             \> \\
C:=(A {\bf FIT} C)*B;    \> /* C obtains value 131068 */ \\
A:=A {\bf FIT} C;        \> /* assignment not permitted */ \\
A:=C {\bf FIT} A;        \> /* OK, but lack of information of C by C FIT A */ \\
A:= (-5) REM (-3);	 \> /* delivers -2 */ \\
A:= (-5) REM (+3);	 \> /* delivers -2 */ \\
A:= (+5) REM (-3);	 \> /* delivers +2 */ \\
A:= (+5) REM (+3);	 \> /* delivers +2 */ \\
\end{tabbing}
\end{modified}

/* conversion of FIXED and BIT objects */ \\
/* without conversion of the internal presentation */ \\
A:=({\bf TOFIXED} D) {\bf FIT} A;\\
D:={\bf TOBIT} (A {\bf FIT} 1(16));

\begin{table} % 7.6
\begin{center}
\caption{Dyadic comparison operators}
\label{tab76}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
{\bf Expression} & {\bf Type}      & {\bf Type}      & {\bf Result type} & {\bf Meaning of operator}\\
                 & {\bf operand 1} & {\bf operand 2} &                   & \\ \hline

op1 $<$ op2      & FIXED(g1)       & FIXED(g2)       &   BIT(1)             & ``less than''\\
or               & FIXED(g1)       & FLOAT(g2)       &                      & If op1 is less than op2,\\
op1 LT op2       & FLOAT(g1)       & FIXED(g2)       &                      & the result has value '1'B,\\
                 & FLOAT(g1)       & FLOAT(g2)       &                      & otherwise '0'B.\\
                 & CLOCK           & CLOCK           &                      & \\
                 & DURATION        & DURATION        &                      & \\ \cline{2-3} \cline{5-5}
                 & CHAR(lg1)       & CHAR(lg2)       &                      & character string comparison\\
                 &                 &                 &                      & (for comparison algorithm,\\
                 &                 &                 &                      & cf. explanations)\\ \hline

op1 $>$ op2      & compare         & compare         & BIT(1)               & ``greater than'':\\
or               & op1 $<$ op2     & op1 $<$ op      &                      & If op1 is greater than op2,\\
op1 GT op2       &                 &                 &                      & the result has value '1'B,\\
                 &                 &                 &                      & otherwise '0'B.\\ \hline

op1 $<$= op2     & compare         & compare         & BIT(1)               & ``less or equal''\\
or               & op1 $<$ op2     & op1 $<$ op2     &                      & If op1 is less or equal op2,\\
op1 LE op2       &                 &                 &                      & the result has value '1'B,\\
                 &                 &                 &                      & otherwise '0'B.\\ \hline

op1 $>$= op2     & compare         & compare         & BIT(1)               & ``greater or equal''\\
or               & op1 $<$ op2     & op1 $<$ op2     &                      & If op1 is greater or equal op2,\\
op1 GE op2       &                 &                 &                      & the result has value '1'B,\\
                 &                 &                 &                      & otherwise '0'B.\\ \hline

op1 == op2       & FIXED(g1)       & FIXED(g2)       & BIT(1)               & ``equal''\\
or               & FIXED(g1)       & FLOAT(g2)       &                      & If op1 is equal op2,\\
op1 EQ op2       & FLOAT(g1)       & FIXED(g2)       &                      & the result has value '1'B,\\
                 & FLOAT(g1)       & FLOAT(g2)       &                      & otherwise '0'B.\\
                 & CLOCK           & CLOCK           &                      & If lg2 $\neq$ lg1, the shorter\\
                 & DURATION        & DURATION        &                      & character or bit string, resp.,\\
                 & CHAR(lg1)       & CHAR(lg2)       &                      & is padded with blanks or zeros,\\
                 & BIT(lg1)        & BIT(lg2)        &                      & resp., on the right side to match\\
                 &                 &                 &                      & the length of the longer string.\\ \hline

op1 /= op2       & compare         & compare         & BIT(1)               & ``not equal''\\
or               & op1 $<$ op2     & op1 $<$ op2     &                      & If op1 is not equal op2,\\
op1 NE op2       &                 &                 &                      & the result has value '1'B,\\
                 &                 &                 &                      & otherwise '0'B.\\
                 &                 &                 &                      & If lg2 $\neq$ lg1, the shorter\\
                 &                 &                 &                      & character or bit string, resp.,\\
                 &                 &                 &                      & is padded with blanks or zeros,\\
                 &                 &                 &                      & resp., on the right side to match\\
                 &                 &                 &                      & the length of the longer string.\\ \hline

op1 IS op2       & REF type        & REF type        & BIT(1)               & Comparison for euqality of the\\
                 &                 &                 &                      & values of references variables.\\
                 &                 &                 &                      & The result upon equality is '1'B.\\ \hline

op1 ISNT op2     & REF type        & REF type        & BIT(1)               & Comparison for euqality of the\\
                 &                 &                 &                      & values of references variables.\\
                 &                 &                 &                      & The result upon non-equality\\
                 &                 &                 &                      & is '1'B.\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table} % 7.7
\begin{center}
\caption{Dyadic Boolean and shift operators}
\label{tab77}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
{\bf Expression} & {\bf Type}      & {\bf Type}      & {\bf Result type} & {\bf Meaning of operator}\\
                 & {\bf operand 1} & {\bf operand 2} &                   & \\ \hline

op1 AND op2      & BIT(lg1)        & BIT(lg2)        & BIT(lg3)          & Boolean bitwise conjunction,\\  
                 &                 &                 &                   & disjunction, or antivalence,\\
                 &                 &                 &                   & resp., of the operands\\
                 &                 &                 &                   & lg3 = max (lg1, lg2).\\
                 &                 &                 &                   & The shorter operand is padded\\
                 &                 &                 &                   & with zeros on the right side to\\
                 &                 &                 &                   & match the length of the longer\\
                 &                 &                 &                   & operand.\\ \cline{1-4}
op1 OR op2       & BIT(lg1)        & BIT(lg2)        & BIT(lg3)          & \\ \cline{1-4}
op1 EXOR op2     & BIT(lg1)        & BIT(lg2)        & BIT(lg3)          & \\ \hline

op1 $<>$ op2     & BIT(lg)         & FIXED(g)        & BIT(lg)           & Cyclic shift of operand op1 for the\\
or               &                 &                 &                   & number of positions determined\\
op1 CSHIFT op2   &                 &                 &                   & by operand op2.\\
                 &                 &                 &                   & If operand op2 $>$ 0,\\
                 &                 &                 &                   & op1 is shifted to the left,\\
                 &                 &                 &                   & otherwise to the right.\\ \hline

op1 SHIFT op2    & BIT(lg)         & FIXED(g)        & BIT(lg)           & Shifting of operand op1 for the\\
                 &                 &                 &                   & number of positions determined\\
                 &                 &                 &                   & operand op2. If operand op2 $>$ 0,\\
                 &                 &                 &                   & op1 is shifted to the left,\\
                 &                 &                 &                   & otherwise to the right. In both\\
                 &                 &                 &                   & cases, zeros are padded.\\ 
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table} % 7.8
\begin{center}
\caption{Dyadic character string operators}
\label{tab78}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
{\bf Expression} & {\bf Type}      & {\bf Type}      & {\bf Result type} & {\bf Meaning of operator}\\
                 & {\bf operand 1} & {\bf operand 2} &                   & \\ \hline

op1 $><$ op2     & CHAR(lg1)       & CHAR(lg2)       & CHAR(lg3)         & Concatenation of the strings\\ 
or               & BIT(lg1)        & BIT(lg2)        & BIT(lg3)          & op1 and op2. Op2 is linked \\
                 &                 &                 &                   & to op1 on the right side.\\
op1 CAT op2      &                 &                 &                   & lg3 = lg1 + lg2.\\
\hline
\end{tabular}
\end{center}
\end{table}

In order to enable the user to reconstruct the result of a comparison
operation of two character strings, the comparison algorithm is given
here (the shorter character string is filled with blanks on the right
side).

Algorithm to compare two character strings, where it holds ``lg3 =
max(lg1, lg2)'':

{\bf TYPE} StringCheck
{\bf FIXED; DCL} (less, equal, greater) {\bf INV FIXED INIT}(-1, 0, 1);\\
\x string\_comparison: {\bf PROC}((string1, string2) {\bf REF INV CHAR}(lg3)){\bf RETURNS}(StringCheck);\\
\x \x {\bf FOR} i {\bf TO} lg3 {\bf REPEAT}\\
\x \x \x {\bf IF TOFIXED} string1.{\bf CHAR}(i) $<$ {\bf TOFIXED} string2.{\bf CHAR}(i)\\
\x \x \x {\bf THEN} {\bf RETURN}(less);\\
\x \x \x {\bf ELSE IF TOFIXED} string1.{\bf CHAR}(i) $>$ {\bf TOFIXED} string2.{\bf CHAR}(i)\\
\x \x \x \x {\bf THEN}\\
\x \x \x \x {\bf RETURN}(greater);\\
\x \x \x \x {\bf FIN};\\
\x \x \x {\bf FIN};\\
\x \x {\bf END}; ! loop\\
\x \x {\bf RETURN}(equal);\\
\x {\bf END}; ! PROC string\_comparison\\


Two further dyadic standard operators relating to array bounds are defined in Table~\ref{tab79}.

\begin{table} % 7.9 
\begin{center}
\caption{Other dyadic operators}
\label{tab79}
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
{\bf Expression} & {\bf Type}      & {\bf Type}      & {\bf Result type} & {\bf Meaning of operator}\\
                 & {\bf operand 1} & {\bf operand 2} &                   & \\ \hline

op1 LWB op2      & FIXED(g)        & array           & FIXED(31)         & lower boundary of the dimension\\
                 &                 &                 &                   & (given by op1) of the array\\
                 &                 &                 &                   & (determined by op2), if existing\\ \hline

op1 UPB op2      & FIXED(g)        & array           & FIXED(31)         & upper boundary of the dimension\\
                 &                 &                 &                   & (given by op1) of the array\\
                 &                 &                 &                   & (determined by op2), if existing\\ 
\hline
\end{tabular}
\end{center}
\end{table}

\newpage
Example:

...\\
P: {\bf PROC}(A(,) {\bf FIXED IDENT});\\
\x ... \\
\x {\bf FOR} i {\bf FROM LWB} A {\bf TO UPB} A\\
\x \x {\bf REPEAT} \\
\x \x \x {\bf FOR} k {\bf FROM} 2 {\bf LWB} A {\bf TO} 2 {\bf UPB} A \\
\x \x \x \x {\bf REPEAT} \\
\x \x \x \x \x ...\\
\x \x \x \x {\bf END}; ! for k\\
\x \x ... \\
\x \x {\bf END}; ! for i\\
\x ...\\
\x {\bf END}; ! proc p \\
...\\
{\bf DCL} Tab1(5,10) {\bf FIXED},\\
\x Tab2(-1:2, 3:5) {\bf FIXED};\\
... \\
{\bf CALL} P(Tab1) ;\\
...\\
{\bf CALL} P(Tab2);

\subsection{Evaluation of Expressions}   % 6.1.3

In the sequel, lower-case letters a, b, c ... denote constants or scalar
variables.

According to the rules of arithmetics, the order of calculating an
expression is dependent on the \mbox{(pre-)}rank of the various operators in
the expression. The dyadic operator ``*'', e.g., has a higher rank than
the dyadic operator ``+'': In the expression ``a+b*c'', hence, ``b*c''
is calculated first, and the product is added to a.

The ranking of dyadic operators is defined in Table~\ref{ranks}. Lower
numbers correspond to higher ranks.

\begin{table}
\begin{center}
\caption{Ranks of the operators defined in PEARL}
\label{ranks}
\vspace{5mm}
\begin{tabular}{|l@{\x}|l@{\x}|l|}
\hline
rank & dyadic operators       & evaluation order \\ \hline
1    & **, FIT, LWB, UPB      & from the right to the left\\
2    & *, /, $><$, //, REM    & from the left to the right\\
3    & +, -, $<>$, SHIFT      & from the left to the right\\
4    & $<$, $>$, $<=$, $>=$   & from the left to the right\\
5    & ==, /=, IS, ISNT       & from the left to the right\\
6    & AND                    & from the left to the right\\
7    & OR, EXOR               & from the left to the right\\
\hline
\end{tabular}
\end{center}
\end{table}

All monadic standard operators have rank 1.

The order of calculating an expression is furthermore influenced in the
common way of putting parentheses around parts of the expression; e.g.,
in the expression

a*(b-(c-d))

first c-d is calculated, this first intermediate result is subtracted
from b, and then this second intermediate result is multiplied by a.

In general, an expression is calculated according to following rules:
\begin{itemize}
\item The partial expression with the highest rank operator is
calculated first, unless one of the two following rules is violated.
\item If several operators of the same rank occur, the calculation takes
place
\begin{itemize}
\item from the left to the right in case 2$\ge$rank$\ge$7
\item from the right to the left in case rank=1\\
      Example: -a**b corresponds to -(a**b)
\end{itemize}
\item parenthesised partial expressions are completely calculated due to
the rules above, before they are combined with another partial
expression.
\end{itemize}

\begin{removed}
\section{Operator Definition (OPERATOR)}   % 6.2

The operator definition allows to define new operators with freely
selectable identifiers, or to extend the meaning of the previously
introduced standard operators.

OperatorDefinition ::=\\
\x {\bf OPERATOR} OpName ( [ OpParameter , ] OpParameter )\\
\x {\bf RETURNS} (ResultType);\\
\x ProcedureBody\\
\x {\bf END};

OpName ::=\\
\x Identifier $\mid + \mid - \mid * \mid ** \mid / \mid // \mid == \mid /= \mid <= \mid >= \mid < \mid > \mid <> \mid ><$

OpParameter ::=\\
\x Identifier [ VirtDimensionList ] ParameterType [ {\bf IDENTICAL $\mid$ IDENT} ]

ResultType ::=\\
\x SimpleType $\mid$ StructuredType $\mid$ TypeReference

The meaning is analogous to the one of a function procedure (cf. 8).


Example:

The standard operator + shall be extended for complex numbers.

{\bf PROBLEM};

{\bf TYPE} Complex {\bf STRUCT}\\
\x [ Real {\bf FLOAT}, Imag {\bf FLOAT} ];

{\bf OPERATOR} + (A Complex {\bf IDENT}, B Complex {\bf IDENT}) {\bf RETURNS} (Complex):\\
\x {\bf DCL} Sum Complex;\\
\x Sum.Real := A.Real + B.Real;\\
\x Sum.Imag := A.Imag + B.Imag;\\
\x {\bf RETURN} (Sum);\\
\x {\bf END}; ! Operator +

{\bf DCL} (XX, YY, ZZ) Complex,\\
\x (X, Y, Z) {\bf FLOAT};\\
...\\
ZZ := XX + YY;\\
Z := X + Y;\\
...

This example shows the possibility to define various operators with the
same operator name, if the operands are of different types. If an
expression is evaluated, in which such an operator name occurs, that
operation is executed where the parameter types are identical with the
operand types in the expression.

If an operator declaration serves for extending the meaning of a
standard operator, the re-declared operator has the rank of the standard
operator. For an operator declared with a new operator name not
introduced in a standard way, a rank between 1 and 7 can be determined
with the help of a rank declaration:

PrecedenceDefinition ::=\\
\x {\bf PRECEDENCE} OpName ( \{ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 \} );

If a precedence shall be defined for a new operator, this must take place
before the operator definition; if no precedence definition is stated, the
new operator is given precedence 7.

Example:

...
{\bf PRECEDENCE} INDEX(1);\\
{\bf OPERATOR} INDEX...;
\end{removed}


\section{Assignments}   % 6.3

Assignments are implemented for scalar variables and for structures, but
not for arrays.

Assignment ::=\\
\x ScalarAssignment $\mid$ StructureAssignment

\subsection{Assignments for Scalar Variables}   % 6.3.1

Assignments for scalar variables are defined as follows:

ScalarAssignment ::=\\
\x Name\S ScalarVariable \{ := $\mid$ = \} Expression;

The statement causes that the value of the expression on the right side
is assigned to the variable given on the left of the assignment sign
(``:='' or ``=''), i.e., after the execution of the assignment, this
name can be used to refer to the value determined by this expression
and, if needed, calculated before the actual assignment:

Result(i) := Koeff * SIN((X(i+1) - X(i)) / X(i));

The type of the variable given to the left of the assignment sign has to
match the type of the value of the expression, with the following
exceptions:
\begin{itemize}
\item The value of a FIXED variable or an integer, resp., may be
assigned to a FLOAT variable.
\item The precision of a numeric variable to the left of an assignment
sign may be greater than the precision of the value of the expression.
\item A bit or character string, resp., to the left may have a greater
length than the value to be assigned; if needed, the latter is extended
by zeros or spaces, resp., on the right.
\end{itemize}

Operators for needed type conversions are described in 6.1.2.

Examples:

{\bf DCL} (I, J) {\bf FIXED}(15),\\
\x K {\bf FIXED}(31),\\
\x (X, Y) {\bf FLOAT},\\
\x Bit8 {\bf BIT}(8),\\
\x Bit12 {\bf BIT}(12),\\
\x Text4 {\bf CHAR}(4),\\
\x Text10 {\bf CHAR}(10),\\
\x Duration(2) {\bf DURATION},\\
\x Time(2) {\bf CLOCK};

\begin{tabbing}
Time(2) := Time(1) + \= {\bf FIN}); \= {\bf THEN} \= \kill

I := 2.0; \> \> \> ! wrong \\
J := 3;   \> \> \> \\
X := J+5; Y := 0; \> \> \> \\
K := J;   \> \> \> \\
J := K;   \> \> \> ! wrong\\
Text10 := 'Result'; \> \> \> ! Text10 has value 'Result\_\_' \\
Bit8 := 'A9F'B4;    \> \> \>! wrong, because too long \\
Duration(1) := 1 {\bf HRS}; \> \> \>\\
Duration(2) := 30 {\bf MIN}; \> \> \> \\
Time(1) := 11:00:00; \> \> \>\\
Time(2) := Time(1) + \> ({\bf IF} \> Time(1) $<$ 12:00:00 \> \\
       \>          \> {\bf THEN} Duration(1) \> \\
       \>          \> {\bf ELSE} Duration(2) \> \\
       \> {\bf FIN}); \> \> \\
Bit8 := '10001100'B; \> \> \> \\
Bit12 := Bit8 $><$ '11'B; \> \> \> /* Bit12 has value '100011001100'B */ \\
Bit8 := Bit8 {\bf CSHIFT} 3; \> \> \> /* Bit8 has value '01100100'B */ \\
Bit12 := Bit8 {\bf SHIFT} -6; \> \> \> /* Bit12 has value '000000100011'B */ \\
\end{tabbing}

It is possible to declare variables with an attribute for assignment
protection (cf. 5.15). Assignments to such variables result in error
messages.

\subsection{Assignments for Structures}   % 6.3.2

The values of all components of a structure can be assigned to another
structure in one single assignment:

StructureAssignment ::=\\
\x Name\S Structure\_1 \{ := $\mid$ = \} ExpressionStructure\_2;

The values of the components of Structure\_2 are assigned to the
corresponding components of Structure\_1. Both structures must have the same
type; i.e., the number of components and their types must match; an
implicit type adaptation like for scalar variables takes not place.

Example:

\begin{tabbing}
{\bf TYPE} \= {\bf [} \= \kill

{\bf TYPE} \>         \> Type\_Measurement {\bf STRUCT}\\
    \> {\bf [} \> Time\_Stamp, \\
    \>         \> Value {\bf FLOAT}(53){\bf ]};\\
    \>         \> \\
{\bf DCL}  \>         \> Workpiece {\bf STRUCT} \\
    \> {\bf [} \> Ident {\bf CHAR}(8),\\
    \>         \> Quality Type\_Measurement,\\
    \>         \> ... {\bf ]};\\
    \>         \> \\
{\bf DCL}  \>         \> Measurement Type\_Measurement;\\
...        \>         \> \\
Workpiece.Quality := Measurement;
\end{tabbing}

\begin{removed}
\section{Overloading of Data Structures}   % 6.4

To exclude programming errors to a large extent, the compiler checks the
use of variables and values in accordance with types.

Upon assignments, the types of the left and right side have to match
each other (see 6.3: Assignments), and when calling a procedure, the
actual parameters have to match the formal parameters in type (see 8.2:
Call of Procedures).

However, there are often situations where the required type
compatibility (``strong typing'') proves to be a hindrance. As an
example, we refer to a data base interface: the data base shall store
user data of different types with different length. For this, the
routines only need the address and the length of the structures to be
stored. For strong typing, a new data base interface (with the desired
user types) had to be programmed for each application.

PEARL 90 provides two different syntactic forms for the overloading of
different data types. Both forms allow exclusively the type conversion
of the objects' addresses when assigning or identifying, resp. A data
conversion does not take place in any case. For converting basic types,
there is a sufficient number of standard operations in PEARL (see 6.1:
Monadic and Dyadic Operators).

\subsection{The ``BY TYPE'' Operator} % 6.4.1

With the ``BY TYPE'' operator, the type of a variable address can be
converted to any other pointer type.

TypeConvertingExpression ::=\\
\x Name {\bf BY TYPE} Type

The type of the variable ``Name'' is converted into the given Type by
operator ``BY TYPE''. The result of the type converting expression is
the address of ``Name'' with type ``Type''. This type conversion is a
compiler internal action preventing an error message of the compiler. At
run time, no action is executed; especially the content of ``Name''
stays unchanged.

Example:

Overloading of data objects upon assignment

{\bf DCL} var \x        TYPE\_A;\\
{\bf DCL} ptr {\bf REF} TYPE\_B;\\
...\\
ptr := var {\bf BY TYPE} TYPE\_B;

The address of variable ``var'' receives type ``TYPE\_B''; thus, the
assignment to pointer ``ptr'' is correct. It is now possible to access a
data object of type ``TYPE\_B'', which overloads variable ``var'', via
pointer ``ptr''.

Example:

Overloading of data objects upon procedure call

{\bf SPC} p1 {\bf ENTRY} ({\bf REF} TYPE\_B) {\bf GLOBAL};\\
{\bf SPC} p2 {\bf ENTRY} (TYPE\_B {\bf IDENT}) {\bf GLOBAL};\\
{\bf DCL} var TYPE\_A;\\
...\\
{\bf CALL} p1 (var {\bf BY TYPE} TYPE\_B);\\
{\bf CALL} p2 (var {\bf BY TYPE} TYPE\_B);

The type of the formal parameter ``var'' is converted to type
``TYPE\_B'' by operator ``BY TYPE''. In both cases, the address of
variable ``var'' is passed on to an object of type ``TYPE\_B'' to the
procedures as pointer. Thus, both calls are correct.

By switching off the type control, the compiler cannot indicate errors
any longer. On no account it is allowed to read or write beyond the end
of the basic memory space with the help of an overloaded data structure,
because severe errors can arise upon program execution (a data loss is
just the smallest problem).

The programmer should not make use of any assumptions about data storage
within the overloaded memory area, either. Storing data is generally
dependent on the target machine. Programs converting data with the help
of overloaded data structures are hardware dependent and only portable
with great effort. Access to data should always be executed via the same
data structure, both for writing and for reading later on. Since in
this case, the data are always processed in accordance with their types,
such programs are portable, if the space requirements of the overloading
data structure do not go beyond the supported filler.

\subsection{The ``VOID'' Data Type}    % 6.4.2

In contrast to the active type conversion by the ``BY TYPE'' operator,
the ``VOID'' data type provides a passive possibility to overload
different data objects. Similar to the constant ``NIL'', which can be
assigned to pointer variables of any data types, the compiler accepts
the assignment of any data addresses to a pointer variable of type
``VOID''.

The ``VOID'' data type is written as structure description without
components, and may only be used in combination with REF.

VOID-DataType ::=\\
\x {\bf STRUCT} [ ]

A reference variable with this type can admit any variable address, the
variable, however, cannot be altered directly. First, the address must
be assigned to a reference variable with the needed type, before the
data object can be manipulated via the reference variable.

Example:

General memory administration routine

\begin{tabbing}
{\bf DCL} memory\_block (c\_max\_buffer) \= {\bf FIXED}(31); \= \kill

{\bf DCL} c\_max\_buffer \x    {\bf INV} \> {\bf FIXED}(31)  \> {\bf INIT}(10000);\\
{\bf DCL} memory\_block (c\_max\_buffer) \> {\bf CHAR}(1);   \> \\
{\bf DCL} free                           \> {\bf FIXED}(31)  \> {\bf INIT}(0);\\
{\bf DCL} memory\_protection             \> {\bf SEMA}       \> {\bf PRESET}(1);
\end{tabbing}

Malloc: {\bf PROC}(size {\bf FIXED}(31)){\bf RETURNS}({\bf REF STRUCT}[ ]){\bf GLOBAL};\\
\x {\bf DCL} ptr {\bf REF CHAR}(1);

\x {\bf REQUEST} memory\_protection; \x /* synchronize access to global variables */

\x {\bf IF} free + size $>=$ c\_max\_buffer {\bf THEN}\\
\x \x ptr := {\bf NIL}; \x /* no space left */\\
\x {\bf ELSE} \\
\x \x ptr := memory\_block(free + 1);\\
\x \x free := free + size;\\
\x {\bf FIN};

\x {\bf RELEASE} memory\_protection;\\
\x {\bf RETURN}(ptr);\\
{\bf END}; ! Malloc

t: {\bf TASK};\\
\x {\bf DCL} ptr\_var\_a {\bf REF} TYPE\_A;\\
\x {\bf DCL} ptr\_var\_b {\bf REF} TYPE\_B;

\x /* require memory range for different types */\\
\x ptr\_var\_a := Malloc ({\bf SIZEOF} TYPE\_A);\\
\x ptr\_var\_b := Malloc ({\bf SIZEOF} TYPE\_B);\\
{\bf END}; ! t

This second form is particularly suitable for polymorphic procedures,
i.e., procedures called with actual parameters of different types. The
``VOID'' data type serves on the one hand as indication in the procedure
specification that the procedure works with different parameter types,
on the other hand, an explicit type conversion with the ``BY TYPE''
operator can be omitted in the call position.

Example (Data base interface):

\begin{tabbing}
{\bf SPC} write\_record \= {\bf ENTRY}(adr {\bf REF INV} \= {\bf STRUCT}[ ], size {\bf FIXED}(31)) {\bf GLOBAL}; \kill
{\bf SPC} read\_record  \> {\bf ENTRY}(adr {\bf REF}     \> {\bf STRUCT}[ ], size {\bf FIXED}(31)) {\bf GLOBAL}; \\
{\bf SPC} write\_record \> {\bf ENTRY}(adr {\bf REF INV} \> {\bf STRUCT}[ ], size {\bf FIXED}(31)) {\bf GLOBAL};
\end{tabbing}

...\\
{\bf DCL} user\_data TYPE\_A;

/* add record with user data into data base */\\
{\bf CALL} write\_record (user\_data, {\bf SIZEOF} TYPE\_A);

/* read user record from data base */\\
{\bf CALL} read\_record (user\_data, {\bf SIZEOF} TYPE\_A);

The data base routines ``read\_record'' and ``write\_record'' are
called by various user programs. They can store and read records of
different length.  For this, the data base routines need only the
addresses and lengths of the records, but not the user specific data
types.
\end{removed}

\begin{tobedone}
\chapter{Statements for the Control of Sequential Execution}   % 7

A task or procedure declaration defines a sequence of statements which
are processed sequentially in the defined order when executing the task or
the procedure, unless control statements designated for this influence the
order of processing.

Such control statements are
\begin{itemize}
\item the conditional statement
\item the statement selection
\item the empty statement
\item the repetition
\item the jump statement
\item the exit statement
\end{itemize}
\end{tobedone}

\section{Conditional Statement (IF)}   % 7.1

With the help of the conditional statement, it is determined depending
on the result of an expression with which statement the program
execution is to continued.

ConditionalStatement ::=\\
\x {\bf IF} Expression {\bf THEN} Statement$^{...}$ {\bf [ ELSE} Statement$^{...}$ {\bf ] FIN};

The result of the expression must be of type BIT(1). If the expression
provides value '1'B (true), the statements following THEN are evaluated;
otherwise the statements following ELSE are evaluated.

If the execution of the statements following THEN or ELSE, resp., does
not result in a jump out of the conditional statement, the statement
following FIN is evaluated subsequently.

Example:

{\bf IF} gradient $>$ degree\_bound \\
\x {\bf THEN} alarm;\\
\x {\bf ELSE IF} gradient $>$ degree\_threshold \\
\x \x \x {\bf THEN ALL} 1 {\bf SEC ACTIVATE} measurement; ! measure more often\\
\x \x {\bf FIN};\\
{\bf FIN};\\
...

\begin{tobedone}
\section{Statement Selection (CASE) and Empty Statement}  % 7.2

Let us assume that a (function) procedure control shall be used for
controlling several devices of the same kind, after each call returning
a number between 1 and 4 meaning:
\begin{itemize}
\item returned value = 1: request carried out
\item returned value = 2: request data wrong
\item returned value = 3: device not addressable
\item returned value = 4: device does not work correctly
\end{itemize}

The task supply shall perform a measure planned for each case.

For the programming of such case distinctions, the statement selection
provided in two (historically caused) forms is suitable: The older form
allows only integers as distinction criteria; the newer one permits also
characters. At first, the older form is described:

StatementSelection1 ::=\\
\x {\bf CASE} Expression\\
\x \x \{ {\bf ALT} Statement$^{...} \}^{...}$\\
\x \x [ {\bf OUT} Statement$^{...}$ ]\\
\x {\bf FIN};

The number 1 is assigned to the statement sequence following the first
ALT (alternative 1), the number 2 to the statement sequence following
the second ALT (alternative 2), etc.

Upon execution of the statement selection, the given expression is
evaluated; it must result in a value of type FIXED. If the integer value
is between 1 and the number of given alternatives, the associated
statement sequence is executed; otherwise the statement sequence
following OUT (if given) is executed.

If the selected statement sequence does not contain a jump out of the
statement selection, the statement following FIN is evaluated
subsequently.

Example:

The above problem can be programmed as follows:

\begin{tabbing}

control: \= {\bf TASK} \= order {\bf BIT}(8)) \x \= \kill

supply:  \> {\bf TASK} \> {\bf PRIO} 7;       \> \\
 \> \> \> \\
control: \> {\bf PROC} \> (No {\bf FIXED},    \> ! device \\
 \>             \> order {\bf BIT}(8)) \> ! order inf.\\
 \> {\bf RETURNS} ({\bf FIXED});   \>  \> \\
 \> ! procedure body for carrying out the control order \> \> \\
 \> {\bf END}; ! control \> \> \\
 \> ... \> \> \\
 \> ! creating an order for the device with index no \> \> \\
 \> \> \> \\
again:   \> {\bf CASE} \> control (no, order) \> \\
 \> {\bf ALT}   \> ! order carried out \> \\
 \>             \> ; \> \\
 \> {\bf ALT}   \> ! order inf. wrong \> \\
 \>             \> {\bf CALL} error(2); {\bf GOTO} end; \> \\
 \> {\bf ALT}   \> ! device dead \> \\
 \>             \> {\bf ACTIVATE} device\_breakdown {\bf PRIO} 2; \> \\
 \>             \> {\bf CALL} error(3); {\bf GOTO} end; \> \\
 \> {\bf ALT}   \> ! device works incorrectly \> \\
 \>             \> {\bf CALL} device\_check; {\bf GOTO} again; \> \\
 \> {\bf OUT}   \> ! result out of range \> \\
 \>             \> {\bf CALL} error(5); \> \\
 \> {\bf FIN}; \> \> \\
 \> ...         \> \> \\
end:     \> {\bf END}; \> ! supply \>
\end{tabbing}

In this example, the empty statement is used. It consists of one
semicolon only and has no effects. The keyword ALT must be followed by
one statement at least; this may also be an empty statement. It has no
effects and is only of interest in conditional statements and statement
selections.

In the example, the empty statement results in the immediate execution
of the statement following FIN in the case of success (``request carried
out'').

The general form of the empty statement reads:

EmptyStatement ::=\\
\x ;

The second form of the statement selection has the following form:

StatementSelection2 ::= \\
\x {\bf CASE} CaseIndex\\
\x \{ {\bf ALT} (CaseList) Statement$^{...} \}^{...}$ \\
\x [ {\bf OUT} Statement$^{...}$ ] \\
\x {\bf FIN};

CaseIndex ::=\\
\x Expression\S WithValueOfType-FIXED-or-CHAR(1)

CaseList ::= \\
\x IndexRange [ , Index-Range ]$^{...}$

IndexRange ::= \\
\x Constant [ : Constant ]

All given constants must be of type CaseIndex expression; CHAR(1) or
FIXED are allowed.

When executing the StatementSelection2, the CaseIndex is evaluated.
If the value is contained in one of the given case lists, the associated
statement sequence is executed; otherwise the statement sequence
following OUT (if given) is executed.

If the selected statement sequence does not contain a jump out of the
statement selection, the statement following FIN is evaluated
subsequently.

Examples:

\begin{tabbing}
{\bf CASE} \= {\bf ALT} ('A':'Z') \= \kill

{\bf DCL}  \> (Operator, chr)CHAR(1), (x, y) {\bf FIXED}; \> \\
...        \> \> \\
{\bf CASE} \> Operator \> \\
    \> {\bf ALT} ('+')    \> x := x + y; \\
    \> {\bf ALT} ('-')    \> x := x - y; \\
    \> {\bf ALT} ('*')    \> x := x * y; \\
    \> {\bf ALT} ('/')    \> {\bf CASE} y \\
    \>                    \> {\bf ALT} (0) {\bf CALL} Error;\\
    \>                    \> {\bf OUT} x := x//y;\\
    \>                    \> {\bf FIN};\\
{\bf FIN}; \> \> \\
    \> \> \\
{\bf CASE} \> chr \> \\
    \> {\bf ALT} ('A':'Z') \> {\bf CALL} uppercase;\\
    \> {\bf ALT} ('a':'z') \> {\bf CALL} lowercase;\\
{\bf FIN}; \> \> \\
    \> \> \\
{\bf CASE} \> chr \> \\
    \> {\bf ALT} ('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u') {\bf CALL} Vocal(chr); \> \\
    \> ... \> \\
{\bf FIN}; \> \>
\end{tabbing}

It is not intended to mix both forms of the statement selection. Thus,
e.g., the following is not correct:

\begin{tabbing}
{\bf CASE} \= {\bf ALT} /* 1 */ \= \kill

{\bf CASE} \> ErrNum \> \\
    \> {\bf ALT} /* 1 */  \> {\bf CALL} ok;\\
    \> {\bf ALT} (0)      \> {\bf CALL} nothing\_done;\\
    \> {\bf ALT} (-99:-1) \> {\bf CALL} ErrorMsg (ErrNum);\\
    \> ... \>
\end{tabbing}

The selection must be deterministic.

Jumps into a statement selection are forbidden.

\section{Repetition (FOR -- REPEAT)}   % 7.3

Often, a statement sequence must be executed repeatedly, with only one
parameter changing. E.g., various devices are to be checked; let
num\_devices be the number of devices:

{\bf FOR} i {\bf FROM} 1 {\bf BY} 1 {\bf TO} num\_devices\\
{\bf REPEAT}\\
\x checking of device(i)\\
{\bf END};

In general, such ``program loops'' are constructed like this:

repetition ::= \\
\x [ {\bf FOR} Identifier\S ControlVariable ] \\
\x [ {\bf FROM} Expression\S InitialValue ] \\
\x [ {\bf BY} Expression\S Increment ] \\
\x [ {\bf TO} Expression\S FinalValue ] \\
\x [ {\bf WHILE} Expression\S Condition ] \\
\x {\bf REPEAT} \\
\x [ Declaration ]$^{...}$ [ Statement ]$^{...}$ \\
\x {\bf END} [ Identifier\S Loop ] ;

The declarations and statements following REPEAT, i.e., the loop body,
are run so often as specified by the clauses given in front of them; the
statement following END is carried out subsequently. However, it is also
possible to leave the loop body prematurely by a jump statement or the
exit statement (cf. 7.5). Jumps into the loop body are not permitted.

In the loop body, all statements are permitted; thus, particularly
repetitions can be nested:

{\bf FOR} i {\bf TO} 10\\
{\bf REPEAT} \\
\x {\bf FOR} k {\bf TO} 10 \\
\x {\bf REPEAT} \\
\x \x c (i,k) := a (i,k) + b(i,k);\\
\x {\bf END};\\
{\bf END};

If InitialValue or Increment are missing, they are assumed as 1. If FinalValue is lacking, the loop body can be repeated unrestrictedly.

The ControlVariable may neither be declared nor changed; it has
implicitly type FIXED. The values of the expressions for InitialValue,
Increment and FinalValue have to be of type FIXED, the value of the
expression for the Condition must be of type BIT(1).

The ControlVariable may not be used in the given expressions, except
for Expression\S Condition, but in the statements to be repeated.

Besides, all rules for blocks are valid for the loop body (cf. 4.4).

The flow chart depicted in Figure~\ref{schleife} is an equivalent representation of the
statement

{\bf FOR} Indicator\S ControlVariable \\
{\bf BY} Expression\S InitialValue \\
{\bf TO} Expression\S Increment \\
{\bf WHILE} Expression\S Condition \\
{\bf REPEAT} \\
\x LoopBody \\
{\bf END};

\end{tobedone}

\begin{figure}[htb]
\centering
\setlength{\unitlength}{0.00087500in}%
\begin{picture}(4299,8001)(214,-7150)
\thicklines
\put(1126,-736){\framebox(2475,1125){}}
\put(1576,-1411){\line( 1, 0){1575}}
\put(3151,-1411){\line( 1,-1){450}}
\put(3601,-1861){\line(-1,-1){450}}
\put(3151,-2311){\line(-1, 0){1575}}
\put(1576,-2311){\line(-1, 1){450}}
\put(1126,-1861){\line( 1, 1){450}}
\put(1126,-3211){\framebox(2475,450){}}
\put(1126,-5011){\framebox(2475,450){}}
\put(1126,-5911){\framebox(2475,450){}}
\put(1126,-3886){\line( 1, 1){225}}
\put(1351,-3661){\line( 1, 0){2025}}
\put(3376,-3661){\line( 1,-1){225}}
\put(3601,-3886){\line(-1,-1){225}}
\put(3376,-4111){\line(-1, 0){2025}}
\put(1351,-4111){\line(-1, 1){225}}
\thinlines
\put(2386,839){\vector( 0,-1){450}}
\put(2386,-736){\vector( 0,-1){675}}
\put(2386,-2311){\vector( 0,-1){450}}
\put(2386,-3211){\vector( 0,-1){450}}
\put(2386,-4111){\vector( 0,-1){450}}
\put(2386,-5011){\vector( 0,-1){450}}
\put(2386,-5911){\line( 0,-1){270}}
\put(2386,-6181){\line(-1, 0){2160}}
\put(226,-6181){\line( 0, 1){5085}}
\put(226,-1096){\line( 1, 0){2160}}
\put(3601,-1861){\line( 1, 0){900}}
\put(4501,-1861){\line( 0,-1){4725}}
\put(4501,-6586){\line(-1, 0){2115}}
\put(2386,-6586){\vector( 0,-1){270}}
\put(3601,-3886){\vector( 1, 0){900}}
\put(2341,119){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}a:=
Expression\S InitialValue}}}
\put(2341,-181){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}s:=
Expression\S Increment}}}
\put(2296,-481){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}e:=
Expression\S FinalValue}}}
\put(2251,-1681){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}s $>$ 0
AND a $<=$ e OR}}}
\put(2251,-1951){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}s $<$ 0
AND a $>=$ e OR}}}
\put(2251,-2221){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}s == 0 ?}}}
\put(2251,-3076){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}Indicator\S ControlVariable := a}}}
\put(2350,-3976){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}Expression\S Condition == '1'B ?}}}
\put(2251,-4876){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}LoopBody}}}
\put(2341,-5776){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}a := a + s}}}
\put(3916,-1771){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}no}}}
\put(3916,-3796){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}no}}}
\put(2600,-2570){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}yes}}}
\put(2600,-4325){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}yes}}}
\put(2386,-7126){\makebox(0,0)[b]{\smash{\SetFigFont{10}{14.4}{rm}LoopEnd}}}
\end{picture}

\caption{Flow chart for evaluating a repetition statement}
\label{schleife}
\end{figure}

\section{GoTo Statement (GOTO)}   % 7.4

GoToStatement ::=\\
\x {\bf GOTO} Identifier\S Label;

This statement has the result that program processing is continued at
the program position determined by the label identifier. This program
position must be a statement and may not be outside the body of the
task or procedure executing the GoTo statement.

Example:

\begin{tabbing}
measure: read: \= \kill
        \> ...\\
measure: read: \> {\bf READ} value {\bf FROM} device;\\
        \> ... \\
        \> {\bf GOTO} read;
\end{tabbing}

In general, statements can (several times) be marked with lables; i.e.,
the label is given immediately before the (possibly already marked)
statement, separated by a colon.

\begin{added}
The label for a {\bf GOTO} statement must be defined in the same block or in a superior block 
in the same {\bf PROC} or {\bf TASK}.
\end{added}

\section{Exit Statement (EXIT)}    % 7.5

The exit statement serves to exit blocks and loops deliberately. With
EXIT, also blocks and loops nested several times can be exited
deliberately, which must have an identifier (the jump target) at the
corresponding end.

ExitStatement ::= \\
\x {\bf EXIT} [ Identifier\S BlockOrLoop ] ;

If the identifier is missing, program processing is continued with the
statement following the end of the block or the loop containing the exit
statement.

If the identifier is given, program processing is continued with the
statement following the end of the indicated block or loop, the exit
statement being in an internal block or loop.

The exit statement may not serve for exiting procedures or tasks.

Example:

\begin{tabbing}
\hspace*{7cm} \= \kill

... \> \\
{\bf BEGIN} \> /* analysis */ \\
\x ... \> \\
\x {\bf TO} number {\bf REPEAT} \> /* comparison */ \\
\x \x ... \> \\
\x \x {\bf IF} MeasuredValue $<$ BoundaryValue \> \\
\x \x {\bf THEN EXIT} analysis; \> \\
\x \x {\bf ELSE} ... \> \\
\x \x {\bf FIN}; \> \\
\x \x ... \> \\
\x {\bf END} comparison; \> \\
\x ... \> \\
{\bf END} analysis; \> \\
{\bf RETURN} (OK);\> \\
\x ... \>
\end{tabbing}

The execution of ``EXIT analysis;'' would immediately be followed by
``RETURN (OK);''.

\begin{tobedone}
\chapter{Procedures}   % 8

When solving an automation problem, in the sense of structured
programming an independent program part is formulated and named for a
logically independent algorithm, particularly if the processing of the
algorithm is needed in several parts of the program, eventually only
changing the arguments of the algorithm, its parameters. The execution
of such a program part is initiated by calling its name --- possibly
provided with actual parameters.

If this call shall have the same effect as executing the proper program
part instead of it, in PEARL this program part is declared and called
as a procedure. Otherwise --- namely, if the statements following the
call are to be executed simultaneously with the called program part ---
the program part is declared and started as task. Tasks are treated in
Chapter 9, Parallel Activities.

Procedures returning a result to their call position are called function
procedures, all other ones are called subprogram procedures.

Example for a subprogram procedure:

Let the procedure Output convert a position indication of type FIXED
into a bit string BinPos and pass it to a machine to be positioned and
marked by number Mach\_No of type FIXED. Let Output be called by
the task Control.

{\bf PROBLEM};\\
\x Output: {\bf PROC} ((Position, Mach\_No) {\bf FIXED});\\
\x \x {\bf DCL} BinPos {\bf BIT}(8);\\
\x \x ! transmission of Position into BinPos\\
\x \x ! output of BinPos to machine Mach\_No \\
\x \x {\bf END}; ! declaration of Output

\x Control: {\bf TASK};\\
\x \x {\bf DCL} (Pos, /* actual nominal position */ \\
\x \x \x         No   /* no of the device */ ) {\bf FIXED};\\
\x \x ... \\
\x \x /* assignments to Pos and No */ \\
\x \x {\bf CALL} Output (Pos, No); \\
\x \x ... \\
\x \x {\bf END}; ! declaration of Control \\
\x ...

Position and Mach\_No are the formal parameters of Output; Pos and No
are actual parameters. BinPos is a local variable of Output only known
within this procedure.

Example for a function procedure:

Due to a schedule Occ\_Plan, procedure Next\_Machine shall determine the
number of the machine to be occupied next among all available machines.
Occ\_Plan shall not be passed on as parameter. Let the number to be
returned be of type FIXED. Next\_Machine shall be declared and called
within the task Supply.

{\bf PROBLEM};\\
\x {\bf DCL} Occ\_Plan ...;

\x Supply: {\bf TASK};\\
\x \x \x {\bf DCL} Mach\_No {\bf FIXED};\\
\x \x \x ... \\
\x \x \x Next\_Machine: {\bf PROCEDURE RETURNS (FIXED)};\\
\x \x \x \x \x {\bf DCL} No {\bf FIXED}; ! No of the next machine\\
\x \x \x \x \x \x ! establishing of No with the help of Occ\_Plan\\
\x \x \x \x \x {\bf RETURN} (No);\\
\x \x \x \x {\bf END} ! Declaration of Next\_Machine\\
\x \x \x ...

\x \x \x Mach\_No := Next\_Machine;\\
\x \x \x ... \\
\x \x {\bf END}; ! Declaration of Supply\\
\x ...

Since the variable Occ\_Plan is declared at module level, it can be used
and, if needed, changed by all procedures and tasks of the module.

\section{Declaration and Specification of Procedures (PROC)}  % 8.1

The statement sequence to be executed when calling a procedure is
prescribed in a procedure declaration, defining a procedure identifier.
The statements of the procedure can use data
\begin{itemize}
\item which are declared at module level or in a higher level relativ to the procedure
(see 4.1),
\item which are specified as formal parameters, i.e., as representatives
for those expressions or variables, which, upon calling, are passed
to the procedure as actual parameters, or
\item which are locally declared in the procedure.
\end{itemize}

The local declarations and the statements of the procedure form the
procedure body.

ProcedureDeclaration ::= \\
\x Identifier: \{ {\bf PROCEDURE $\mid$ PROC} \} [ ListOfFormalParameters ]\\
\x [ ResultAttribute ]\\
\x [ GlobalAttribute ] ;\\
\x ProcedureBody\\
\x {\bf END};

ProcedureBody ::= \\
\x [ Declaration$^{...}$ ] [ Statement$^{...}$ ]

ListOfFormalParameters ::=\\
\x (FormalParameter [ , FormalParameter ]$^{...}$)

FormalParameter ::=\\
\x Identifier\_or\_IdentifierList [ VirtualDimensionList ] [ AssignmentProtection ]\\
\x ParameterType [ {\bf IDENTICAL $\mid$ IDENT} ]

VirtualDimensionList ::=\\
\x ( [ , $^{...}$ ] )

ParameterType ::= \\
\x SimpleType $\mid$ TypeReference $\mid$ TypeStructure\\
\x $\mid$ Identifier\S ForType $\mid$ TypeDation $\mid$ TypeRealTimeObject

TypeRealTimeObject ::=\\
\x {\bf SEMA $\mid$ BOLT $\mid$ IRPT $\mid$ INTERRUPT $\mid$ SIGNAL}

ResultAttribute ::= \\
\x {\bf RETURNS}(ResultType)

ResultType ::= \\
\x SimpleType $\mid$ TypeReference $\mid$ TypeStructure $\mid$ Identifier\S ForType

The general form of the specification of a procedure reads as follows:

ProcedureSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\S Procedure \{ {\bf ENTRY $\mid$ [ : ] PROC} \} \\
\x [ ListOfParametersFor-SPC ] [ResultAttribute ] GlobalAttribute ;

ListOfParametersFor-SPC ::=\\
\x (ParameterSpecification [ , ParameterSpecification ]$^{...}$)

ParameterSpecification ::=\\
\x [ Identifier ] [ VirtualDimensionList ] [ AssignmentProtection ] \\
\x ParameterType [ {\bf IDENTICAL $\mid$ IDENT} ]

In the procedure specification, the (optionally) definable list of
parameters is only of documentary importance; however, it is thus
possible to copy the head of a procedure declaration into another module
and to generate a correct specification of the procedure by adding the
keyword SPECIFY.

Subprogram procedures are declared without and function procedures with
result attribute. The result type determines the type of the calculated
result which is returned to the call position. With the help of the
return statement, this return takes place in the form

{\bf RETURN} (Expression);

Thus, the value of the expression must have the type specified by the
result attribute.

Execution of the procedure body of a function procedure is terminated by
executing a return statement. Function procedures may only be terminated
this way and no other.

Execution of a subprogram procedure is terminated by
\begin{itemize}
\item executing the return statement in the form\\
      {\bf RETURN};\\
\item executing the last statement of the procedure body.
\end{itemize}

The procedure body can contain declarations, e.g., declarations of local
variables which are only known within the procedure body. However,
further procedures, so-called nested procedures, may also be declared; the
occurring aspects of unambiguity of names, also occurring when declaring
procedures in task bodies, are described in 4.3 within the context of
blocks.

Due to the call, variables or expressions are associated with the
specified formal parameters of the procedure as actual parameters. How
this association takes place (two possibilities), is determined by the
fact whether the attribute IDENTICAL is given or not. Both ways are
explained in 8.2, Call of Procedures.

The number n of commas in the virtual dimension list indicates that the
parameter is an (n+1) dimensional array. Formal array parameters
(virtual dimension list is present) may only be specified together with
the IDENTICAL attribute. If, e.g., the one-dimensional array ``A(10)
FIXED'' shall be passed on to a procedure P with the corresponding
formal parameter Array, Array is to be specified like this: ``Array()
FIXED IDENTICAL''.

Procedures declared at module level, are translated by the compiler with
the {\em re-entrancy} capability, so that they can be used
simultaneously by several tasks (see 9). The recursive call of
procedures is allowed for all --- even for nested --- procedures.
However, since for each task only limited memory space for the local
data of the called procedures (stack) is provided, the programmer
should avoid (or suitably restrict) recursion in the sense of safe
programs.

\section{Calls of Procedures (CALL)}   % 8.2

Subprogram procedures are called with the help of the keyword CALL or
only with their identifiers:

CallStatement ::=\\
\x [ {\bf CALL} ] Name\S SubprogramProcedure [ ListOfActualParameters ] ;

ListOfActualParameters ::=\\
\x (Expression [ , Expression ]$^{...}$)

Example:

{\bf SPC} Output {\bf PROC} (P {\bf FIXED}, N {\bf FIXED}) {\bf GLOBAL};\\
{\bf DCL} (Pos, No) {\bf FIXED};\\
...\\
! Assignments to Pos and No\\
{\bf CALL} Output (Pos, No);

The call statement results in associating the given actual parameters
to the formal parameters of the indicated procedure in the order of
writing down them, and then executing the procedure body. Subsequently,
the statement following the call statement is executed.

The call of a function procedure does not take place as an independent
statement, but within expressions upon stating the identifier and the
actual parameters:

FunctionCall ::= \\
\x Name\S FunctionProcedure [ ListOfActualParameters ]

Example:

The function procedure Ari shall calculate the arithmetic average of an
array of n FLOAT variables. This average shall then be printed together
with the text ``Arith.Average''.

Ari: {\bf PROC} (Array() {\bf FLOAT IDENTICAL}) {\bf RETURNS} ({\bf FLOAT});\\
\x \x {\bf DCL} Sum {\bf FLOAT};\\
\x \x {\bf DCL} (LowerBound, UpperBound) {\bf FIXED};\\
\x \x Sum := 0;\\
\x \x LowerBound := LWB Array; \\
\x \x UpperBound := UPB Array; \\
\x \x {\bf FOR} i {\bf FROM} LowerBound {\bf BY} 1 {\bf TO} UpperBound\\
\x \x {\bf REPEAT}\\
\x \x \x Sum := Sum + Array(i);\\
\x \x {\bf END}; ! loop\\
\x \x {\bf RETURN} (Sum/(UpperBound - LowerBound + 1));\\
\x {\bf END}; ! Ari

\x {\bf DCL} MeasuredValue(10) {\bf FLOAT};\\
\x ...
\x \x /* Acquisition of the measured values */ \\
\x {\bf PUT} Ari (MeasuredValue), 'Arith.Average' {\bf TO} Printer {\bf BY} LIST;\\
\x ...

When evaluating a function call, the given actual parameters are
associated with the formal parameters of the indicated function
procedure in the order of writing down them; then the procedure body is
executed. Subsequently, the evaluation of the expression where the
function call took place is continued --- in the above example the
evaluation of the expression 'Arith.Average' in the put statement.

Both in the call statement and in the function call, the types of the
actual parameters must match the types of the formal parameters
corresponding to them.

The association of the actual parameters with the formal parameters can
take place in two ways: If the specification of a formal parameter has
the attribute IDENTICAL or IDENT, the association takes places with the
help of identification, otherwise by value transmission.

In the case of value transmission (also called {\em call by value}), a
new object, having the type of the formal parameter and being local to
the procedure body, is declared for each defined formal parameter when
invoking the procedure; i.e., the formal parameters become local
variables of specified types. Then, the values of the actual parameters
are assigned to the corresponding formal parameters. An assignment to a
formal parameter by a statement in the procedure body, hence, does not
result in a change of the actual parameter. Furthermore, in this case
any expressions may be passed as actual parameters.

When associating with the help of identification (also called {\em call
by reference}), a formal parameter is identified with the corresponding
actual parameter; i.e., in the procedure body, the data of the actual
parameter are referred to under the name of the formal parameter. An
assignment to a formal parameter in the procedure body means, thus, an
assignment to the variable passed as corresponding actual parameter.
Hence, in this case, not expressions, but only names (of variables) may
be passed as actual parameters.

Example:

\begin{tabbing}
P2: \= \kill

{\bf PROBLEM}; \> \\
    \> \\
P1: \> {\bf PROC} (pi {\bf FIXED}, pj {\bf FLOAT IDENT});\\
    \> ... \\
    \> pi := 3; pj := 5.0;\\
    \> {\bf END}; ! P1\\

P2: \> {\bf PROC} ...;\\
    \> {\bf DCL} (i, j) {\bf FIXED}, a(100) {\bf FLOAT};\\
    \> ... \\
    \> i := 2 ; a(i) := 2.5; \\
    \> {\bf CALL} P1 (i, a(i));\\
    \> ... \\
    \> {\bf END}; ! P2 \\
... \>
\end{tabbing}

After the call of P1 in P2 i (still) has the value 2, but a(i) has the
value 5.0.

As the language form of the procedure declaration already shows (see
8.1), the values of the actual parameters may be of type
\begin{itemize}
\item Integer or FloatingPointNumber, or
\item BitString or CharacterString, or
\item Time or Duration, or
\item Structure or Identifier\S For\_Type, or
\item TypeReference.
\end{itemize}
No explicit values are assigned to objects of types
\begin{itemize}
\item DATION, SEMA, BOLT, INTERRUPT and SIGNAL.
\end{itemize}
Such objects may only be passed to a procedure via identification, i.e.,
the formal parameter may only be defined with the IDENTICAL attribute.

\section{References to Procedures (REF PROC)}  % 8.3

The opportunity to use procedure reference variables is a first step
towards object oriented programming. With the help of it, e.g., data
structures and the necessary procedures for the controlled manipulation of
these structures can be combined into new, abstract data structures.

A declaration of reference variables for procedures contains the
description of all parameter types, as well as the type of the result.

ProcedureReferenceDeclaration ::= \\
\x \{ {\bf DECLARE $\mid$ DCL} \} Identifier\_or\_IdentifierList [ DimensionAttribute ] [ {\bf INV} ]\\
\x {\bf REF} TypeProcedure [ GlobalAttribute ] [ InitialisationAttribute ] ;

TypeProcedure ::=\\
\x {\bf PROC} [ ListOfParametersFor-SPC ] [ ResultAttribute ]

The general form of the specification of procedure reference variables
reads:

ProcedureReferenceSpecification ::= \\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\_or\_IdentifierList [ VirtualDimensionList ] [ {\bf INV} ]\\
\x {\bf REF} TypeProcedure GlobalAttribute;

The value assignment to a procedure reference variable takes place with
the assignment:

Assignment ::=\\
\x Name\S RefProcVariable \{ := $\mid$ = \} Identifier\S Procedure;

Only procedures declared at module level may be assigned here.

The required matching of types means in this case, that the number of
parameters, all parameter types and also the type of the result
attributes match.

Calling a procedure via a procedure reference variable takes simply
place by giving the reference variable, followed by a list of the actual
parameters. For procedures without parameters, CALL, or in the case of
function procedures, also CONT, can be used.

Examples:
\begin{enumerate}
\item {\bf DCL} ProcPointer {\bf REF PROC} (a {\bf FIXED}, b {\bf FIXED}, c {\bf FIXED IDENT});\\
      add: {\bf PROC} (a {\bf FIXED}, b {\bf FIXED}, c {\bf FIXED IDENT});\\
      \x   c := a + b;\\
      \x   {\bf END};\\
      \x   {\bf DCL} (A, B, C) {\bf FIXED};\\
      ProcPointer := add;\\
      ProcPointer (A, B, C);
\item {\bf DCL} FuncPointer {\bf REF PROC RETURNS(CLOCK)};\\
      time: {\bf PROC RETURNS(CLOCK)};\\
      \x    {\bf RETURN}(NOW);\\
      \x    {\bf END};

      {\bf DCL}(A, B) {\bf CLOCK};\\
      FuncPointer := time;\\
      A := FuncPointer;\\
      B := {\bf CONT} FuncPointer;
\end{enumerate}
\end{tobedone}

\chapter{Parallel Activities}  % 9

Typical for a program to control a technical process are
\begin{itemize}
\item asynchronous processes as program parts which run parallel in time 
and independent from one another, and which are initiated by
spontaneous events or at certain (scheduled) times, as well as
\item the synchronisation of such processes at certain program points,
e.g., to be able to exchange data with one another.
\end{itemize}

To program such processes, in PEARL tasks, interrupts and
synchronisation objects are used.

A task is of a program part which is executed under the control of the
operating system. The task body, like a procedure body consists of PEARL 
declarations and statements. Before using it, a task must be declared; 
upon this, an identifier is assigned to it, which is then mentioned 
in tasking operations such as start or resumption.

Since usually only one processor is available to the tasks of a program,
they must compete for its use --- but also for the access to other
resources (such as I/O devices) which have to be shared. The
operating system, assigns the resources taking account of
the tasks' priority. Thus, a positive integer can be allocated to a task
as priority, smaller numbers meaning higher priority. The thus
determined task priorities are used by the operating system to control
the allocation of resources. If a task, e.g., possesses the only
processor and requests another, exclusively occupied resource, the
operating system withdraws the processor from this task and allocates it to
the task of highest priority among all runable  tasks waiting for the
processor. To runnable tasks of the same priority, the processor is
allocated due to the Round-Robin-Strategy.

Such a priority controlled re-allocation of a processor takes place each
time, when one of its operating system functions is called, e.g., upon
the occurrence of an interrupt or upon executing statements for task 
control, for synchronisation and for input and output.

\section{Declaration and Specification of Tasks (TASK)}   % 9.1

The declaration of tasks takes place analogously to the declaration of
procedures. In contrast to procedures, tasks may only be declared at
module level --- i.e., not within procedure or task bodies. Furthermore,
parameters are not permitted. However, since in a task body all PEARL
objects declared at module level may be used and --- as far as it is
possible --- changed, the data exchange with a task can take place via
data which are declared at module level. Particularly the access of
several tasks to the same data, however, should carefully be
synchronised with the means described in 9.3. In the case of the data 
exchange by I/O statements, the input/output functions
already take over the synchronisation.

Example:

A task Protocol deposits protocol texts in the variable Text to be
delivered to a terminal via the task Output. (The needed synchronisation
statements are explained in 9.3.)

\begin{tabbing}
\x Protocol: \= \kill

{\bf PROBLEM}; \> \\
\x {\bf DCL} Text {\bf CHAR}(60); \> \\
\x Protocol: \> {\bf TASK}; \\
      \> Text := ProtocolText(27);\\
      \> ... \\
      \> {\bf END}; ! Protocol \\
      \> \\
\x Output:   \> {\bf TASK}; \\
      \> {\bf PUT} Text {\bf TO} Printer {\bf BY} LIST;\\
      \> ... \\
      \> {\bf END}; ! Output\\
\x ...       \>
\end{tabbing}

The general form of a task declaration reads:

TaskDeclaration ::=\\
\x Identifier: {\bf TASK} [ PriorityAttribute ] [ {\bf MAIN} ] [ GlobalAttribute ] ;\\
\x TaskBody \\
\x {\bf END};

PriorityAttribute ::= \\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} IntegerWithoutPrecision$\S $GreaterZero

TaskBody ::= \\
\x [ Declaration$^{...}$ ] [ Statement$^{...}$ ]

If no priority is given in a task declaration, priority 255 is assumed.
\addedtext{The priority value must be in the range from 1 to 255. 
In case the priority value is not inside this range the PrioOutOfRangeSignal
is induced.}


The general form of a task specification reads:

TaskSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier$\S $Task {\bf TASK} GlobalAttribute;

Upon program or system start, the tasks marked with MAIN are started
according to their priority. All MAIN tasks must be declared in the same
module.

The global attribute is explained in 4.4.

\subsection{References to Tasks (REF TASK)}   % 9.1.1

The control of all task activities is also possible via references to
objects of type TASK. The declaration of corresponding reference
variables can take place like this:

TaskReferenceDeclaration ::= \\
\x \{ {\bf DECLARE $\mid$ DCL} \} Identifier\_or\_IdentifierList [ DimensionAttribute ]\\
\x [ AllocationProtection ] {\bf REF TASK} [ GlobalAttribute ] [ InitialisationAttribute ];

The general form of the specification of task reference variables reads:

TaskReferenceSpecification ::= \\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\_or\_IdentifierList [ VirtualDimensionList ] \\
\x [ AllocationProtection ] {\bf REF TASK} GlobalAttribute;

The following short example shows an application possibility for task
reference variables:

Example:

Both segments from two PEARL programs show how various tasks can be
started from a procedure, once via their names, once via references.

\begin{tabbing}
\x {\bf SPC} \= {\bf END}; \= {\bf PROC} \= \kill

{\bf PROBLEM}; \> \> \\
\x {\bf SPC} (Consumer\_1, Consumer\_2, Consumer\_3) {\bf TASK GLOBAL}; \> \> \> \\
\x ... \> \> \> \\
\x StartTask: \> \> {\bf PROC} \> (Index {\bf FIXED});\\
       \> \> {\bf CASE} \> Index \\
       \> \> {\bf ALT}  \> {\bf ACTIVATE} Consumer\_1;\\
       \> \> {\bf ALT}  \> {\bf ACTIVATE} Consumer\_2; \\
       \> \> {\bf ALT}  \> {\bf ACTIVATE} Consumer\_3; \\
       \> \> {\bf FIN}; \> \\
\x \> {\bf END}; \> ! StartTask \> \\
\x ... \> \> \>
\end{tabbing}

\begin{tabbing}
\x {\bf DCL} Consumer (3) \= \kill
{\bf PROBLEM}; \>  \\
\x {\bf SPC} (Consumer\_1, Consumer\_2, Consumer\_3) {\bf TASK GLOBAL}; \> \\
\x {\bf DCL} Consumer (3) \> {\bf INV REF TASK GLOBAL} \\
     \> {\bf INIT} (Consumer\_1, Consumer\_2, Consumer\_3);\\
\x ... \> \\
\x {\bf DCL} \= {\bf END}; \= \kill
\x StartTask: \> \> {\bf PROC} (Index {\bf FIXED});\\
       \> \> {\bf IF} Index $<$ {\bf UPB} Consumer {\bf THEN}\\
       \> \> \x {\bf ACTIVATE} Consumer (Index);\\
       \> \> {\bf FIN};\\
\x \> {\bf END}; \> ! StartTask\\

\x ... \> \>
\end{tabbing}

\subsection{Determining Task Addresses}  % 9.1.2

The address of a task can be obtained by calling the predefined
function TASK or simply by assigning a task identifier to a task
reference variable.

Example:

{\bf SPC} TemperatureMeasurement {\bf TASK GLOBAL};\\
{\bf DCL} PtrTask {\bf REF TASK};\\
...\\
PtrTask := {\bf TASK} (TemperatureMeasurement);\\
PtrTask := TemperatureMeasurement;

Both assignments are equivalent, however, the first form should be used,
because it documents the address assignment in a better way.

The address of the running task is received by invoking the function
TASK without stating a parameter.

Example:

...\\
PtrTask := {\bf TASK}; \x ! provides address of the task containing
this statement.\\
...\\

Besides using task reference variables in task statements, they can
also be used for identifying tasks (cf. IS and ISNT operators).

Example:

{\bf IF} PtrTask {\bf IS TASK}(hello) {\bf THEN}\\
\x \x ...\\
{\bf FIN};\\
{\bf IF} PtrTask {\bf IS TASK THEN}\\
\x \x $/^*$ points to running task $^*/$\\
\x \x ...\\
{\bf FIN};

\subsection{Determining Task Priorities}   % 9.1.3

The (current) priority of a task can be obtained by the predefined
function PRIO. Without stating a parameter, it provides the priority of
the running task, and with a task name as parameter, it returns the
priority of that task.

Example:

{\bf DCL} CurrPrio {\bf FIXED}(15);\\
{\bf DCL} CurrTaskA {\bf FIXED}(15);\\
{\bf SPC} TaskA {\bf TASK GLOBAL};\\
...\\
CurrPrio := {\bf PRIO};\\
PrioTaskA := {\bf PRIO} (TaskA);\\
{\bf CONTINUE} TaskA {\bf PRIO} CurrPrio + 1;

\section{Statements for Controlling Tasks}    % 9.2

A task can be started, terminated, suspended, continued, resumed and
descheduled.

\subsection{Start Condition}   % 9.2.1

Unlike procedures, tasks are not executed immediately by calls, but in
dependence of time instants and interrupts. Thus, a task must first be
{\bf scheduled} for the start by a task control statement of the
syntax

Task\_Start ::= \\
\x [ StartCondition ] {\bf ACTIVATE} Name$\S $Task;

The start itself is managed by a real time operating system. If
the StartCondition defined in the control statement is fulfilled,
the task first becomes ``runnable''; but it is not started, i.e.,
transferred into the state ``running'', until it has become the runnable
task of highest priority (cf. also 9.2.2).

Examples:

{\bf AT} 20:0:0 {\bf ACTIVATE} Statistics;\\
\x means that the task ``statistics'' is not to be started until the
future time ``8 o'clock p.m.''.

{\bf ACTIVATE} statistics;\\
\x in contrast, means that the task ``statistics'' is to be started
immediately.

With the start condition, tasks can be scheduled for cyclic (repeated)
start, in accordance with the syntax definition

StartCondition ::=\\
\x {\bf AT} Expression$\S $Time [ Frequency ]\\
\x $\mid$ {\bf AFTER} Expression$\S $Duration [ Frequency ]\\
\x $\mid$ {\bf WHEN} Name$\S $Interrupt [ {\bf AFTER} Expression$\S $Duration ] [ Frequency ]\\
\x $\mid$ Frequency

Frequency ::= \\
\x {\bf ALL} Expression$\S $Duration [ \{ {\bf UNTIL} Expression$\S $Time \}\\
\x $\mid$ \{ {\bf DURING} Expression$\S $Duration \} ]

% Zeile zu lang; Umbruch vor ]

Examples:

{\bf ALL} T {\bf ACTIVATE} Regulator;\\
\x means that task Regulator becomes runnable at each integer
multiple of the time interval T.

{\bf WHEN} Alarm {\bf ACTIVATE} ShutDown;\\
\x means that the task ShutDown becomes runnable each time when the
interrupt Alarm occurs.

AT Expression$\S $Time determines, at which time the task shall be
executed for the first time, AFTER Expression$\S $Duration determines,
from when on this is to happen relative to the execution of the task
control statement, and WHEN Name$\S $Interrupt determines that this is
to happen when the denoted interrupt occurs, possibly delayed by the
duration denoted in AFTER Expression$\S $Duration. If AT, AFTER and WHEN
are lacking, the task becomes runnable immediately after the execution
of the task control statement.

If the task is to be repeated after equal time intervals, the time between
two executions is to be determined by ALL Expression$\S $Duration. To
limit the repeated executions, a time can be determined by UNTIL
Expression$\S $Time, or a duration with DURING Expression$\S $Duration,
respectively, after which no more task starts are repeated.

If the start condition commences with WHEN, the task becomes runnable
each time the denoted interrupt occurs, considering further components
of the start condition. A schedule determined by ALL becomes
re-effective, relative to the occurrence of the interrupt, whereas the
previous schedule becomes ineffective.

\begin{added}
In combinations of WHEN and AFTER each interrupt occurance restarts
the delay period for the tasks activation.
This is shown in figure  \ref{whenAfter}.
\end{added}

\begin{figure}
\setlength{\unitlength}{1.00mm}
\linethickness{0.4pt}
\begin{picture}(140.00,30.0)
\footnotesize
\thicklines{}
\setlength\fboxsep{0pt}

\put(0,18){IruptTask}
\put(0,8){Interrupt occurs}
\put(20,05){\vector(1,0){120}}
\put(135,0){time}
\put(29.2,8){$\uparrow$}
% ################
\put(30,18){\colorbox{gray!20}{\framebox(10,5){delay}}} % 
\put(40.20,18){\framebox(10,5){T1}}

\put(52.2,8){$\uparrow$}
\put(53,18){\colorbox{gray!20}{\framebox(10,5){delay}}} % 
\put(54.2,8){$\uparrow$ (a)}
\put(55,22){\colorbox{gray!20}{\framebox(10,5){delay}}} % 
\put(65.20,22){\framebox(10,5){T1}}

\put(79.2,8){$\uparrow$}
\put(80,18){\colorbox{gray!20}{\framebox(10,5){delay}}} % 
\put(90.20,18){\framebox(25,5){T1}}
\put(93.2,8){$\uparrow$ (b)}
\put(94,22){\colorbox{gray!20}{\framebox(10,5){delay}}} % 
\put(115.45,22){\framebox(10,5){T1}}
\multiput(104,27)(2,0){5}{\line(1,0){1}}
  \put(114.5,27){\vector(1,0){1}}
\put(110.2,8){$\uparrow$ (c)}
\end{picture}
\caption{The task IruptTask becomes activated by an interrupt. 
The activation itself is delayed for 1 second. 
If the interrupt re-occurs during the delay period - the delay
period is retriggered (a).
If the interrupt occurs while the task is still active, the delay
timer is started again (b). If the task is still active at the end
of the delay time
the activation is buffered once and executed immediately after the 
task's termination (c).}
\label{whenAfter}
\end{figure}

The start condition becomes ineffective 
\removedtext{(i.e., the task associated with
it is not executed any longer)} % verwirrende Formulierung
,
\begin{itemize}
\item if it commences with AFTER or ALL and an end condition determined
by UNTIL or DURING is reached, or if it has the form AFTER
Expression$\S $Duration and the denoted Duration reckoning from the
execution of the task control statement has passed,
\item because a statement to deschedule a task is executed (see 9.2.7),
\item \removedtext{
 upon execution of a new task control statement of the same type.
The previous start condition is replaced by the new one
, or, if no new
condition is denoted, deleted.}
\item \addedtext{
 upon execution of a new task control statement of the same type ({\bf ACTIVATE}
or {\bf CONTINUE}).
The previous start condition is replaced by the new one
, or, if no new
condition is denoted, deleted.}
\end{itemize}

Example:

...\\
{\bf AT} 12:0:0 {\bf ACTIVATE} Protocol; \\
{\bf ALL} 2 HRS {\bf ACTIVATE} Protocol; \\
...

These two schedulings cannot be valid at the same time. On the contrary,
start condition ALL 2 HRS replaces start condition AT 12:0:0, unless
time ``12 o'clock'' does not occur before executing the second
statement.

\subsection{Starting a Task (ACTIVATE)}   % 9.2.2

The general form of the statement to start a task (i.e., to schedule a
task to be started) reads:

TaskStart ::=\\
\x [ StartCondition ] {\bf ACTIVATE} Name$\S $Task [ Priority ];

Priority ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} Expression$\S $WithPositiveIntegerAsValue

Executing such a start statement causes that the indicated task
applies for the allocation of a processor immediately (form without
start condition) or at the instant determined by the start condition ---
competing with all other tasks being runable at the moment
of the start (being runable) as well. Thus, upon an immediate start,
the started task competes particulary with the starting task, if only
one processor is provided.

Possibly, the indicated task has already been started and not been
terminated when executing the start statement. If in this case no
StartCondition is denoted, an error message occurs.
However, if the
start statement contains a StartCondition, the indicated task is
continued, and its re-start is scheduled (buffered) according to the
StartCondition, replacing a possibly existing scheduling by the new
one.
\begin{added}
The the task will be re-started as soon as the task terminates.
This buffering is limited to 1 re-start action.
% as described in FullPEARL(1977)

This behavior is shown in figure~\ref{task-sched} and \ref{task-sched1}. The rectangles denote the time period, where the tasks are active. The arrows mark
the time of interaction.
\end{added}

\begin{figure}
\setlength{\unitlength}{1.00mm}
\linethickness{0.4pt}
\begin{picture}(90.00,20.0)
\footnotesize
\thicklines{}
\put(0,8){Interrupt occurs}
\put(0,14){IruptTask}
\put(20,05){\vector(1,0){70}}
\put(85,0){time}
\put(39.2,8){$\uparrow$ (a)}
\put(40,12){\framebox(10,5){T1}}
\put(59.2,8){$\uparrow$}
\put(60,12){\framebox(10,5){T1}}
\put(63,8){$\uparrow$}
\put(65,8){$\uparrow$ (b)}
\put(70.3,12){\framebox(10,5){T1}}

\end{picture}
\caption{The task IruptTask becomes activated by an interrupt (a). 
If the interrupt occurs while the task is still active, the 
activation is buffered once and executed immediately after the 
task's termination (b).}
\label{task-sched}
\end{figure}

\begin{figure}
\setlength{\unitlength}{1.00mm}
\linethickness{0.4pt}
\begin{picture}(110.00,20.0)
\footnotesize
\thicklines{}
\put(0,10){CyclTask}
\put(0,0){1 second tick}
\put(10,05){\vector(1,0){100}}
\put(105,0){time}
\multiput(29.2,0)(20,0){4}{$\uparrow$}
\put(30,10){\framebox(10,5){T1}}

\put(50,10){\framebox(25,5){T1}}
\put(75.3,10){\framebox(5,5){T1}}

\put(90,10){\framebox(5,5){T1}}
\end{picture}
\caption{The task CyclTask should become activated all 1 sec. 
The execution time varies. If the task is still active at the 
next activation time, the 
activation is buffered once and executed immediately after the 
task's termination.}
\label{task-sched1}
\end{figure}

A possibly stated priority overwrites the priority stated in the
declaration of the indicated task. 
\begin{added}
The new priority is valid only 
for this activation. Subsequent activations will use the priority, which
is specified in the task declaration.
\end{added}

\begin{added}
\OpenPEARL{} uses relative times for the startCondition. This becomes apparent,
if the time-scale is re-adjusted. The re-start will occur according the
time-base which was valid while setting the task schedule condition.

Example:

{\bf AT} 22:00:00 {\bf ALL} 2 HRS {\bf UNTIL} 2:00:00  {\bf ACTIVATE} t1;
will produce the activation of the task t1 at the following time, 
depending on the time of the execution of the scheduled activation statement.
\begin{tabular}{l|l}
current time & activation times \\
\hline
12:00:00 & 22:00:00, 0:00:00 (tomorrow), 2:00:00 (tomorrow) \\
23:00:00 & 22:00:00 (tomorrow), 0:00:00 (day after tomorrow) ,\\
  &  2:00:00 (day after tomorrow) \\ 
\end{tabular}

Note that \OpenPEARL{} treats time intervals inclusive the borders.

Figure \ref{sched_act} illustrates the possibilities to start a task
immediately or under various start conditions.
\end{added}

\setlength{\unitlength}{1.00mm}
\begin{figure}
\begin{picture}(145,145)
\newsavebox{\normalstmt}
\savebox{\normalstmt}(40,8)[bl]{
   \put(0,0){\line(1,0){40}}
   \put(0,8){\line(1,0){40}}
   \put(0,0){\line(0,1){8}}
   \put(40,0){\line(0,1){8}}
}
\newsavebox{\compare}
\savebox{\compare}(30,8)[bl]{
   \put(0,4){\line(1,1){4}}
   \put(0,4){\line(1,-1){4}}
   \put(4,0){\line(1,0){22}}
   \put(4,8){\line(1,0){22}}
   \put(26,0){\line(1,1){4}}
   \put(26,8){\line(1,-1){4}}
}

% show bounding frame
%\put(0,0){\line(1,0){145}}
%\put(0,0){\line(0,1){145}}
%\put(145,145){\line(0,-1){145}}
%\put(145,145){\line(-1,0){145}}

\put(60,140){\makebox(0,0){{\bf start by statement}}}
\put(110,140){\makebox(0,0){{\bf start by interrupt}}}
\put(110,130){\makebox(0,0){{\bf WHEN} Name\S Interrupt}}
\put(090,126){\usebox{\normalstmt}}
\put(110,126){\vector(0,-1){8}}
\put(60,126){\vector(0,-1){8}}
% --------------------

\put(60,114){\makebox(0,0){delayed start ?}}
\put(45,110){\usebox{\compare}}
\put(75,114){\line(1,0){4}}
\put(74,110){y}
\put(79,114){\line(0,-1){8}}
\put(60,106){\vector(0,-1){4}}
\put(60,106){\vector(1,0){50}}
\put(30,114){\line(1,0){15}}
\put(42,116){n}
\put(30,114){\line(0,-1){28}}
\put(30,86){\vector(1,0){55}}

\put(110,114){\makebox(0,0){delayed start ?}}
\put(095,110){\usebox{\compare}}
\put(110,110){\vector(0,-1){8}}
\put(112,107){y}
\put(125,114){\line(1,0){15}}
\put(127,116){n}
\put(140,114){\line(0,-1){28}}
\put(140,86){\vector(-1,0){55}}

\put(15,98){\makebox(0,0){\shortstack{delayed\\start}}}

\put(60,98){\makebox(0,0){\shortstack{{\bf AT} time\\e.g. 12:00:00}}}
\put(40,94){\usebox{\normalstmt}}
\put(60,94){\line(0,-1){4}}

\put(110,98){\makebox(0,0){\shortstack{{\bf AFTER} delay\\e.g. 5 SEC}}}
\put(090,94){\usebox{\normalstmt}}
\put(110,94){\line(0,-1){4}}

\put(60,90){\line(1,0){50}}
\put(85,90){\vector(0,-1){8}}

% ---------------------------------
\put(85,78){\makebox(0,0){periodic start ?}}
\put(70,74){\usebox{\compare}}
\put(85,74){\vector(0,-1){8}}
\put(87,71){y}
\put(30,78){\line(1,0){40}}
\put(67,80){n}
\put(30,78){\line(0,-1){60}}
\put(30,18){\vector(1,0){55}}

\put(85,62){\makebox(0,0){\shortstack{{\bf ALL} period\\(e.g.  5 SEC)}}}
\put(65,58){\usebox{\normalstmt}}
\put(85,58){\vector(0,-1){8}}

\put(15,62){\makebox(0,0){\shortstack{periodic\\start}}}

\put(85,46){\makebox(0,0){end condition ?}}

\put(70,42){\usebox{\compare}}
\put(70,46){\vector(-1,0){40}}
\put(67,48){n}
\put(85,42){\line(0,-1){4}}
\put(87,39){y}
\put(60,38){\line(1,0){50}}
\put(110,38){\vector(0,-1){4}}
\put(60,38){\vector(0,-1){4}}

% -----------------------
\put(60,30){\makebox(0,0){\shortstack{{\bf UNTIL} time\\(e.g. 12:30:00)}}}
\put(40,26){\usebox{\normalstmt}}
\put(60,26){\line(0,-1){4}}

\put(110,30){\makebox(0,0){\shortstack{{\bf DURING} duration\\(e.g. 20 MIN)}}}
\put(090,26){\usebox{\normalstmt}}
\put(110,26){\line(0,-1){4}}

\put(15,30){\makebox(0,0){\shortstack{end\\criteria}}}

\put(60,22){\line(1,0){50}}
\put(85,22){\vector(0,-1){8}}

\put(85,10){\makebox(0,0){{\bf ACTIVATE} Name\S Task}}
\put(65, 6){\usebox{\normalstmt}}
\end{picture}
\caption{Possibilities to start a task immediately or under 
various conditions}
\label{sched_act}
\end{figure}
% Bild. 9-9 einfuegen !!!

% Fussnote (im Bild): After occurrence of the interrupt, the task is
% re-scheduled under the related start condition. The old scheduling becomes
% ineffective.
\begin{added}
Possible problem situations:
\begin{description}
\item[TaskRunningSignal] is induced, if the task is still active when 
an {\bf ACTIVATE} statement without start-condition is executed.
\item[IllegalSchedulingSignal] is induced, if at least one the values of 
  {\bf AFTER}, {\bf ALL} or {\bf DURING} is non positiv.
\end{description}
The first activation will be on the next day, if the current time is larger 
than the value of the {\bf AT} parameter.
If the time specified by {\bf UNTIL} is less than the time of {\bf bf} the 
period will end the day after the first scheduled activation. This is true
independent of the way of specifying the first activation.
\end{added}

A task is terminated
\begin{itemize}
\item when it reaches the terminating END statement of its body, or
\item by executing a statement to terminate tasks related to the task
(see 9.2.3).
\end{itemize}

Example:

The task Pressure\_measurement shall measure all 5 seconds the pressure in a tank and transfer it to the task Checking. If the pressure increases significantly fast, the measurement shall by taken all second with increased priority. The task Checking is started immediately by task Initial.

\begin{tabbing}
\x Pressure\_measurement: \= \kill

{\bf PROBLEM}; \> \\
\x Initial:    \> {\bf TASK MAIN};\\
        \> {\bf ACTIVATE} Checking;\\
        \> \x $/^*$ further initialisations $^*/$ \\
        \> \\
        \> {\bf END}; ! Initial\\
        \> \\
\x Checking:   \> {\bf TASK PRIORITY} 6;\\
        \> {\bf ALL} 5 {\bf SEC ACTIVATE} Pressure\_measurement;\\
        \> \x $/^*$ taking over the measured values\\
        \> \x if the pressure rises: $^*/$\\
        \> {\bf ALL} 1 {\bf SEC ACTIVATE} Pressure\_measurement {\bf PRIO} 2;\\
        \> ...\\
        \> {\bf END}; ! Checking\\
        \> \\
\x Pressure\_measurement: \> {\bf TASK PRIO} 5;\\
    \> $/^*$ measuring and passing over to checking $^*/$\\
    \> {\bf END}; ! Pressure\_measurement\\
\x ... \>
\end{tabbing}



\subsection{Terminating a Task (TERMINATE)}    % 9.2.3

The premature termination of a task is achieved by following
statement:

TaskTermination ::= \\
\x {\bf TERMINATE} [ Name$\S $Task ] ;

If the denotation Name$\S $Task is lacking, the statement refers to
the task in whose body it is contained.

All resources occupied by the terminated task (including processor) are
withdrawn from it. Synchronisation variables blocked by the task,
however, are not released automatically.

\begin{added}
Possible problem situations:
\begin{description}
\item[TaskTerminatedSignal] is induced, if the task is in terminated state
 when a {\bf TERMINATE} statement is executed.
\item[Termination is delayed], if the task is doing i/o. The task's termination
is delayed until the i/o-statement is completed, or a record mark ({\bf SKIP}) 
is encountered.  This is done to enshure the integrity of the i/o-behavior.
\end{description}
\end{added}

\subsection{Suspending a Task (SUSPEND)}   % 9.2.4

By executing the statement

TaskSuspension ::=\\
\x {\bf SUSPEND} [ Name$\S $Task ] ;

the indicated task --- or the executing task, respectively, if
Name$\S $Task is lacking --- is suspended, i.e., its execution is
postponed. The processor allocated to it is withdrawn from it --- but
not all the other resources occupied by it.

A suspended task can only be continued by executing a continue
statement (see 9.2.5).

\begin{added}
Possible problem situations:
\begin{description}
\item[TaskTerminatedSignal] is induced, if the task is not activated when 
a {\bf SUSPEND} statement is executed.
\item[TaskSuspendedSignal] is induced, if the task is already suspended when
a {\bf SUSPEND} statement is executed.
\item[Suspending is delayed], if the task is doing i/o. The task's suspension
is delayed until the i/o-statement is completed, or a record mark ({\bf SKIP}) 
is encountered. This is done to enshure the integrity of the i/o-behavior.
\end{description}
\end{added}


\subsection{Continuing a Task (CONTINUE)}    % 9.2.5

A suspended task can be continued immediately, at a certain point in
time, after a certain duration or after the occurrence of an interrupt by
the following statement:

TaskContinuation ::=\\
\x [ SimpleStartCondition ] {\bf CONTINUE} [ Name$\S $Task ] [ Priority ]\

SimpleStartCondition ::= \\
\x {\bf AT} Expression$\S $Time $\mid$ {\bf AFTER} Expression$\S $Duration $\mid$ {\bf WHEN} Name$\S $Interrupt

If Name$\S $Task is stated, the statement causes that the indicated task
competes for the processor immediately (form without start condition) or
at the instant determined by the start condition --- possibly with the
given priority replacing the declared one.

The form without Name$\S $Task causes that the executing task re-competes
for the processor at the instant determined by the start condition ---
possibly with the given priority replacing the declared one.

Example:

The task Acquisition shall cause an output and not continue until
the occurrence of the interrupt Continuation, but then with higher
priority.

\begin{tabbing}
Acquisition: \= {\bf TASK PRIO} 8;\\
      \> \x \x ! Acquisition of data\\
      \> \x {\bf WHEN} Continuation {\bf CONTINUE PRIO} 5;\\
      \> \x \x ! Output\\
      \> \x {\bf SUSPEND};\\
      \> \x \x ! Acquisition of data\\
      \> {\bf END}; ! Acquisition
\end{tabbing}

In Figure~\ref{zustaende},
the state transitions of a task possible by executing CONTINUE
instructions are illustrated graphically. For the case of
``scheduled continuations'', the state transitions for SUSPEND statements are
given additionally.
\begin{added}
Note that fulfilling the continuation condition annihilates the
continuation condition.
\end{added}

\begin{added}
Possible problem situations:
\begin{description}
\item[TaskTerminatedSignal] is induced, if the task is not activated when 
a {\bf CONTINUE} statement is executed, without a schedule condition.
\item[Priority update] occurs at any {\bf CONTINUE PRIO xxx} statement,
 except if the tasks state is terminated.
\item[executing a scheduled CONTINUE] never induces a signal. The action will
   be discarded, if the tasks state is not suspended. The priority will be 
   updated, if the tasks state is not terminated.
\end{description}
\end{added}


\begin{figure}
\unitlength 1.00mm
\linethickness{0.4pt}
\begin{picture}(158.00,117.67)
\footnotesize
\thicklines{}
%\circle(15.00,46.00){18.00}
\multiput(15.00,55.00)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(16.97,54.78)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(18.84,54.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(20.53,53.10)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(21.95,51.72)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(23.03,50.06)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(23.72,48.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(24.00,46.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(23.83,44.27)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(23.24,42.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(22.25,40.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(20.91,39.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(19.28,38.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(17.45,37.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(15.50,37.01){\line(-1,0){1.98}}
\multiput(13.52,37.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(11.61,37.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(9.87,38.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(8.38,39.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(7.21,41.50)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(6.41,43.31)(-0.09,0.49){4}{\line(0,1){0.49}}
\put(6.03,45.26){\line(0,1){1.98}}
\multiput(6.09,47.24)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(6.57,49.16)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(7.47,50.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(8.72,52.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(10.29,53.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(12.08,54.51)(0.58,0.10){5}{\line(1,0){0.58}}
%\end
%\circle(15.00,72.00){18.00}
\multiput(15.00,81.00)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(16.97,80.78)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(18.84,80.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(20.53,79.10)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(21.95,77.72)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(23.03,76.06)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(23.72,74.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(24.00,72.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(23.83,70.27)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(23.24,68.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(22.25,66.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(20.91,65.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(19.28,64.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(17.45,63.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(15.50,63.01){\line(-1,0){1.98}}
\multiput(13.52,63.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(11.61,63.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(9.87,64.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(8.38,65.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(7.21,67.50)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(6.41,69.31)(-0.09,0.49){4}{\line(0,1){0.49}}
\put(6.03,71.26){\line(0,1){1.98}}
\multiput(6.09,73.24)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(6.57,75.16)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(7.47,76.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(8.72,78.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(10.29,79.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(12.08,80.51)(0.58,0.10){5}{\line(1,0){0.58}}
%\end
%\circle(71.00,23.00){18.01}
\multiput(71.00,32.01)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(72.97,31.79)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(74.84,31.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(76.53,30.11)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(77.95,28.73)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(79.03,27.07)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(79.73,25.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(80.00,23.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(79.84,21.28)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(79.25,19.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(78.26,17.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(76.92,16.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(75.29,15.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(73.45,14.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(71.50,14.01){\line(-1,0){1.98}}
\multiput(69.52,14.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(67.61,14.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(65.87,15.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(64.38,16.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(63.20,18.49)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(62.41,20.31)(-0.10,0.49){4}{\line(0,1){0.49}}
\put(62.03,22.25){\line(0,1){1.98}}
\multiput(62.08,24.23)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(62.57,26.15)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(63.46,27.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(64.72,29.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(66.28,30.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(68.07,31.52)(0.59,0.10){5}{\line(1,0){0.59}}
%\end
%\circle(71.00,88.00){18.00}
\multiput(71.00,97.00)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(72.97,96.78)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(74.84,96.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(76.53,95.10)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(77.95,93.72)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(79.03,92.06)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(79.72,90.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(80.00,88.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(79.83,86.27)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(79.24,84.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(78.25,82.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(76.91,81.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(75.28,80.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(73.45,79.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(71.50,79.01){\line(-1,0){1.98}}
\multiput(69.52,79.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(67.61,79.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(65.87,80.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(64.38,81.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(63.21,83.50)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(62.41,85.31)(-0.09,0.49){4}{\line(0,1){0.49}}
\put(62.03,87.26){\line(0,1){1.98}}
\multiput(62.09,89.24)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(62.57,91.16)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(63.47,92.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(64.72,94.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(66.29,95.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(68.08,96.51)(0.58,0.10){5}{\line(1,0){0.58}}
%\end
%\circle(130.00,23.00){18.00}
\multiput(130.00,32.00)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(131.97,31.78)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(133.84,31.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(135.53,30.10)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(136.95,28.72)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(138.03,27.06)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(138.72,25.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(139.00,23.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(138.83,21.27)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(138.24,19.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(137.25,17.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(135.91,16.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(134.28,15.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(132.45,14.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(130.50,14.01){\line(-1,0){1.98}}
\multiput(128.52,14.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(126.61,14.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(124.87,15.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(123.38,16.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(122.21,18.50)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(121.41,20.31)(-0.09,0.49){4}{\line(0,1){0.49}}
\put(121.03,22.26){\line(0,1){1.98}}
\multiput(121.09,24.24)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(121.57,26.16)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(122.47,27.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(123.72,29.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(125.29,30.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(127.08,31.51)(0.58,0.10){5}{\line(1,0){0.58}}
%\end
%\circle(130.00,88.00){18.01}
\multiput(130.00,97.01)(0.98,-0.11){2}{\line(1,0){0.98}}
\multiput(131.97,96.79)(0.31,-0.11){6}{\line(1,0){0.31}}
\multiput(133.84,96.14)(0.19,-0.12){9}{\line(1,0){0.19}}
\multiput(135.53,95.11)(0.12,-0.12){12}{\line(1,0){0.12}}
\multiput(136.95,93.73)(0.11,-0.17){10}{\line(0,-1){0.17}}
\multiput(138.03,92.07)(0.12,-0.31){6}{\line(0,-1){0.31}}
\multiput(138.73,90.21)(0.09,-0.65){3}{\line(0,-1){0.65}}
\multiput(139.00,88.25)(-0.08,-0.99){2}{\line(0,-1){0.99}}
\multiput(138.84,86.28)(-0.12,-0.38){5}{\line(0,-1){0.38}}
\multiput(138.25,84.38)(-0.11,-0.19){9}{\line(0,-1){0.19}}
\multiput(137.26,82.67)(-0.11,-0.12){12}{\line(0,-1){0.12}}
\multiput(135.92,81.21)(-0.16,-0.11){10}{\line(-1,0){0.16}}
\multiput(134.29,80.08)(-0.26,-0.11){7}{\line(-1,0){0.26}}
\multiput(132.45,79.34)(-0.65,-0.11){3}{\line(-1,0){0.65}}
\put(130.50,79.01){\line(-1,0){1.98}}
\multiput(128.52,79.12)(-0.38,0.11){5}{\line(-1,0){0.38}}
\multiput(126.61,79.66)(-0.22,0.12){8}{\line(-1,0){0.22}}
\multiput(124.87,80.60)(-0.14,0.12){11}{\line(-1,0){0.14}}
\multiput(123.38,81.90)(-0.12,0.16){10}{\line(0,1){0.16}}
\multiput(122.20,83.49)(-0.11,0.26){7}{\line(0,1){0.26}}
\multiput(121.41,85.31)(-0.10,0.49){4}{\line(0,1){0.49}}
\put(121.03,87.25){\line(0,1){1.98}}
\multiput(121.08,89.23)(0.10,0.38){5}{\line(0,1){0.38}}
\multiput(121.57,91.15)(0.11,0.22){8}{\line(0,1){0.22}}
\multiput(122.46,92.92)(0.11,0.14){11}{\line(0,1){0.14}}
\multiput(123.72,94.45)(0.14,0.11){11}{\line(1,0){0.14}}
\multiput(125.28,95.67)(0.22,0.11){8}{\line(1,0){0.22}}
\multiput(127.07,96.52)(0.59,0.10){5}{\line(1,0){0.59}}
%\end
\put(14.67,72.00){\makebox(0,0)[cc]{\tekst 20mm,explicitly suspended;}}
\put(14.67,46.33){\makebox(0,0)[cc]
{\tekst 15mm,explicitly suspended and scheduled for continuation;}}
\put(70.67,88.00){\makebox(0,0)[cc]
{\tekst 12mm,runable and scheduled for continuation;}}
\put(130.00,88.00){\makebox(0,0)[cc]{\tekst 12mm,runable;}}
\put(71.00,23.33){\makebox(0,0)[cc]
{\tekst 12mm,running and scheduled for continuation;}}
\put(130.00,22.67){\makebox(0,0)[cc]{\tekst 12mm,running;}}
\put(13.33,7.00){\makebox(0,0)[cc]{``active''}}
\put(74.00,7.00){\makebox(0,0)[cc]{``executing''}}
\put(16.34,88.00){\makebox(0,0)[cc]{``suspended''}}
\put(41.33,34.67){\makebox(0,0)[cc]{\tekst 12mm,SUSPEND;}}
\put(45.00,54.66){\makebox(0,0)[cc]{\tekst 25mm,ContinuationCondition fulfilled;}}
\put(41.33,76.33){\makebox(0,0)[cc]{\tekst 12mm,SUSPEND t$_i$;}}
\put(100.67,19.00){\makebox(0,0)[cc]{\tekst 20mm,ContinuationCondition\\
CONTINUE PRIO p;}}
\put(144.67,50.67){\makebox(0,0)[cc]{\tekst 12mm,CONTINUE\\~[PRIO p];}}
\put(145.33,98.00){\makebox(0,0)[cc]{\tekst 20mm, CONTINUE t$_i$\\PRIO p;}}
\put(100.67,100.00){\makebox(0,0)[cc]
{\tekst 25mm,ContinuationCondition\\CONTINUE t$_i$ PRIO p;}}
\bezier{92}(123.33,16.33)(114.00,9.00)(104.67,15.00)
\bezier{80}(137.67,28.00)(143.33,36.00)(143.67,46.33)
%\bezvec{120}(97.33,103.67)(78.67,106.67)(76.33,96.00)
\put(76.33,96.00){\vector(-1,-3){0.2}}
\bezier{120}(97.33,103.67)(78.67,106.67)(76.33,96.00)
%\end
%\bezvec{80}(97.00,23.00)(92.33,28.33)(79.67,25.33)
\put(79.67,25.33){\vector(-4,-1){0.2}}
\bezier{80}(97.00,23.00)(92.33,28.33)(79.67,25.33)
%\end
\bezier{60}(121.67,92.00)(113.67,92.67)(108.33,97.00)
%\bezvec{104}(36.67,73.00)(26.67,65.33)(20.67,53.33)
\put(20.67,53.33){\vector(-1,-2){0.2}}
\bezier{104}(36.67,73.00)(26.67,65.33)(20.67,53.33)
%\end
\bezier{84}(62.00,24.67)(46.33,27.33)(44.00,32.33)
%\bezvec{76}(39.00,38.33)(34.67,45.00)(24.00,43.67)
\put(24.00,43.67){\vector(-1,0){0.2}}
\bezier{76}(39.00,38.33)(34.67,45.00)(24.00,43.67)
%\end
\bezier{72}(62.33,85.67)(50.00,81.67)(46.00,79.00)
%\bezvec{116}(144.33,55.33)(145.00,69.33)(136.67,81.67)
\put(136.67,81.67){\vector(-2,3){0.2}}
\bezier{116}(144.33,55.33)(145.00,69.33)(136.67,81.67)
%\end
\bezier{56}(139.00,87.33)(146.67,88.33)(146.67,94.33)
%\bezvec{96}(144.00,102.33)(135.00,109.00)(133.00,96.67)
\put(133.00,96.67){\vector(-1,-4){0.2}}
\bezier{96}(144.00,102.33)(135.00,109.00)(133.00,96.67)
%\end
\thinlines{}
\put(79.00,55.67){\oval(158.00,110.67)[]}
\put(106.50,55.50){\oval(97.00,105.00)[]}
\put(120.00,103.00){\makebox(0,0)[cc]{\tekst 20mm,Start condition\\fulfilled;}}
\bezier{48}(122.00,117.67)(118.67,113.00)(119.67,107.00)
%\bezvec{24}(120.67,99.33)(120.33,98.00)(124.00,95.33)
\put(124.00,95.33){\vector(1,-1){0.2}}
\bezier{24}(120.67,99.33)(120.33,98.00)(124.00,95.33)
%\end
\put(130.33,116.33){\makebox(0,0)[cc]{\tekst 12mm,from state\\``scheduled'';}}
\put(100.33,89.00){\makebox(0,0)[cc]{\tekst 20mm,ContinuationCondition\\fulfilled;}}
\bezier{72}(80.00,90.33)(86.33,95.33)(95.33,92.00)
%\bezvec{68}(105.33,85.33)(108.33,82.33)(120.67,85.67)
\put(120.67,85.67){\vector(4,1){0.2}}
\bezier{68}(105.33,85.33)(108.33,82.33)(120.67,85.67)
%\end
\bezier{48}(23.67,49.00)(30.67,49.00)(35.33,51.67)
%\bezvec{312}(48.33,59.33)(77.33,72.67)(122.67,82.00)
\put(122.67,82.00){\vector(4,1){0.2}}
\bezier{312}(48.33,59.33)(77.33,72.67)(122.67,82.00)
%\end
\put(105.00,66.00){\makebox(0,0)[cc]{\tekst 20mm,ContinuationCondition\\fulfilled;}}
\bezier{160}(77.33,29.33)(92.67,43.67)(101.67,60.67)
%\bezvec{88}(107.00,70.67)(112.33,78.00)(124.67,79.67)
\put(124.67,79.67){\vector(4,1){0.2}}
\bezier{88}(107.00,70.67)(112.33,78.00)(124.67,79.67)
%\end
\put(122.33,46.33){\makebox(0,0)[cc]
{\tekst 12mm,t$_i$ is highest priority\\runable task;}}
\put(134.33,63.67){\makebox(0,0)[cc]
{\tekst 20mm,t$_i$ not any longer\\highest priority\\runable task;}}
\bezier{132}(128.00,79.00)(115.33,68.67)(120.00,52.67)
%\bezvec{36}(123.67,40.33)(126.67,31.67)(126.67,31.67)
\put(126.67,31.67){\vector(1,-3){0.2}}
\bezier{36}(123.67,40.33)(126.67,31.67)(126.67,31.67)
%\end
\bezier{120}(134.00,31.67)(140.67,43.67)(135.67,59.33)
%\bezvec{36}(133.00,70.67)(131.33,74.33)(131.33,79.00)
\put(131.33,79.00){\vector(0,1){0.2}}
\bezier{36}(133.00,70.67)(131.33,74.33)(131.33,79.00)
%\end
\put(63.67,48.33){\makebox(0,0)[cc]
{\tekst 12mm,t$_i$ is highest priority\\runable task;}}
\put(80.67,61.00){\makebox(0,0)[cc]
{\tekst 20mm,t$_i$ not any longer\\highest priority\\runable task;}}
\bezier{100}(66.67,79.67)(60.00,69.67)(61.67,56.67)
%\bezvec{44}(63.67,41.67)(64.33,37.33)(66.33,31.33)
\put(66.33,31.33){\vector(1,-3){0.2}}
\bezier{44}(63.67,41.67)(64.33,37.33)(66.33,31.33)
%\end
\put(16.83,62.33){\oval(31.00,64.67)[]}
%------
\bezier{100}(73.67,31.67)(80.00,44.33)(80.00,55.67)
%\bezvec{60}(80.33,66.67)(80.33,75.00)(76.33,80.33)
\put(76.33,80.33){\vector(-1,2){0.2}}
\bezier{60}(80.33,66.67)(80.33,75.00)(76.33,80.33)
%\end
\end{picture}

\caption{State transition diagram of task $t_i$ when executing
CONTINUE}
\label{zustaende}
\end{figure}


\subsection{Delaying a Task (RESUME)}    % 9.2.6

If the running task shall release the processor allocated to it for a
certain duration or until the occurrence of a certain point in time or an
interrupt, respectively, (if it is to be delayed), the following
statement is to be executed:

TaskDelay ::= \\
\x SimpleStartCondition {\bf RESUME};

This statement if equivalent to the non-devisable combination of
the statements

SimpleStartCondition {\bf CONTINUE};\\
{\bf SUSPEND};

After having executed the statement TaskDelay, the start condition is
ineffective, i.e., the execution is once.

\begin{added}
Note that {\bf RESUME} annihilates a continuation condition
for the current task, due to the implicit {\bf CONTINUE} in the {\bf RESUME}-
statement.
\end{added}

Example:

The task Control shall turn on a device and check 10 seconds later,
whether the device works as desired.

\begin{tabbing}
Control: \= {\bf TASK};\\
  \> \x \x ! turning on the device\\
  \> \x {\bf AFTER} 10 {\bf SEC} {\bf RESUME};\\
  \> \x \x ! ckecking the function of the device\\
  \> \x ...\\
  \> {\bf END}; ! Control
\end{tabbing}

\subsection{De-scheduling a Task (PREVENT)}    % 9.2.7

Sometimes it is necessary to cancel the schedules existing for a task,
i.e., to take care that the start conditions related to this task become
ineffective. This can be achieved with the following statement:

TaskPrevent ::= \\
\x {\bf PREVENT} [ Name$\S $Task ] ;

This statement does not terminate the corresponding task; if
Name$\S $Task is not given, the statement effects the running task.

Example:

The procedure Control called by a higher level task, gives a move
request to an AGV (Automatic Guided Vehicle) which has to send the ready message Ready within
30 seconds in order to start the task Supply. If the ready message has not
arrived within 30 seconds, the task Malfunction shall be started, and
the probably still possible, but delayed start of Supply shall be
de-scheduled. In the normal case --- Ready arrives within 30 seconds
--- the already scheduled start of Malfunction must be de-scheduled.

\begin{tabbing}
\x malfunction: \= {\bf PROC} (\= \kill

{\bf PROBLEM}: \> \> \\
\x {\bf SPECIFY} \> Ready {\bf INTERRUPT}; \> \\
   \> \> \\
\x Control:      \> {\bf PROC} (\> X {\bf FIXED},  $/^*$ X coordinate $^*/$ \\
   \>             \> Y {\bf FIXED}); $/^*$ Y coordinate $^*/$ \\
   \> $/^*$ converting the coordinates taken over into a bit string, \> \\
   \> output of the bit string to the AGV $^*/$ \> \\
   \> {\bf WHEN} Ready {\bf ACTIVATE} Supply; \> \\
   \> {\bf AFTER} 30 {\bf SEC} {\bf ACTIVATE} Malfunction; \> \\
   \> ... \> \\
\x \x {\bf END}; \> ! Control \> \\
   \> \> \\
\x Supply:       \> {\bf TASK PRIO} 3; \> \\
   \> {\bf PREVENT} Malfunction; \> \\
   \> ... \> \\
\x \x {\bf END}; \> ! Supply \> \\
   \> \> \\
\x Malfunction:  \> {\bf TASK PRIO} 2; \> \\
   \> {\bf PREVENT} Supply; \> \\
   \> ... \> \\
\x \x {\bf END}; \> ! Malfunction \>
\end{tabbing}

\section{Synchronising Tasks}    % 9.3

Generally, tasks are run independently from one another. However, it may
happen that several tasks work on parts of a more complex, overall
problem and have to use certain resources, particularly data, jointly.

Example:

\begin{figure}[h]
\centering
\setlength{\unitlength}{0.00087500in}%
\begin{picture}(4148,2325)(249,-1705)
\put(1351,344){\line( 0,-1){405}}
\put(1351,-61){\line( 1, 0){900}}
\put(3151,-61){\line( 1, 0){900}}
\put(4051,-61){\line( 0, 1){450}}
\put(3151,-61){\vector( 0,-1){225}}
\put(2251,-61){\vector( 0,-1){225}}
\put(2701,-736){\vector( 0,-1){675}}
\thicklines
\put(2026,-736){\framebox(1350,450){}}
\put(1351,524){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Message}}}
\put(4051,524){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Message}}}
\put(2701,-601){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Buffer}}}
\put(4276,119){\makebox(0,0)[lb]{\smash{\SetFigFont{10}{12.0}{rm}Producer2}}}
\put(1126,119){\makebox(0,0)[rb]{\smash{\SetFigFont{10}{12.0}{rm}Producer1}}}
\put(2926,-1141){\makebox(0,0)[lb]{\smash{\SetFigFont{10}{12.0}{rm}Output}}}
\put(2746,-1681){\makebox(0,0)[b]{\smash{\SetFigFont{10}{12.0}{rm}Protocol printer}}}
\end{picture}

\caption{Example for task co-ordination}
\label{puffer}
\end{figure}

According to Figure~\ref{puffer} the tasks Producer1 and Producer2 produce messages which they want to
store in a common buffer; by the task output, a message is taken from
the buffer and displayed in a formatted way on a protocol printer.

For a correct execution of the operations, they have to be co-ordinated
as follows:
\begin{itemize}
\item The task Output creates only an output, if a message was buffered, which
means that it possibly waits that the buffer is filled by Producer1 or
Producer2.
\item Producer1 and Producer2 can only buffer a message, if no
previous message is being sent out by Output, i.e., they must possibly
be suspended until Output has issued the previous message completely.
\item The tasks Producer1 and Producer2 to buffer a
message have to be mutually exclusive.
\end{itemize}

To control such co-ordination tasks, two types of synchronisation
variables are provided, namely semaphore and bolt variables. If the
access to jointly used resources (e.g., data, procedures, devices) is to
be co-ordinated, one synchronisation variable is associated to each
resource; then the using tasks execute a locking statement on the
associated synchronisation variable before and a release statement
after using a resource.

The association of synchronisation variables to resources does not take
place by PEARL statements; it is only assumed and is realised by using a
certain synchronisation variable always in combination with a certain
resource, only. Such an association is not restricted to data,
procedures, devices, etc., sometimes it must also be done for program
parts (e.g., for executing sub-tasks), which shall all be
terminated until a certain other program part (e.g., the main task) is to be
continued.

\subsection{Semaphore Variables (SEMA) and Statements (REQUEST,
RELEASE, TRY)} % 9.3.1
% Zeilenumbruch mitten im Wort RELEASE

Semaphore variables can have non-negative integers as values. These
numbers represent the states ``free'' or ``locked'': Zero means state
``locked'' (the semaphore variable ``locks''), positive numbers mean the
state ``free''.  These states can only be changed by special request or
release statements.

Semaphore variables are declared as follows:

{\bf DCL} Identifier\_or\_IdentifierList {\bf SEMA};

Example:

{\bf DCL} (On, Off) {\bf SEMA};

After its declaration, a semaphore variable has the state ``locked''.

If a semaphore variable explicitly is to assume the state ``locked'',
the following locking statement is to be executed:

{\bf REQUEST} Name$\S $Sema;

The effect of this statement depends on the actual value of the
indicated semaphore variable:
\begin{itemize}
\item If the value is greater than zero, it is decremented by 1.
\item If the value equals zero, it stays the same; the executing task,
however, is suspended and placed in a queue which is (implicitly)
associated to the semaphore variable (the task is blocked).
\end{itemize}

The execution of the release statement

{\bf RELEASE} Name$\S $Sema;

causes that the value of the indicated semaphore variable is incremented
by 1. Furthermore, the tasks in the queue of the semaphore variable are
released; they repeat their request statement in the order of their
priorities.

Example:

With these means, the problem of buffering messages can be solved as
follows:

For entering messages into the buffer, a semaphore variable
Into\_buffer, for the output out of the buffer, a semaphore variable
Out\_of\_buffer is declared. Upon declaration, Into\_buffer and
Out\_of\_buffer are implicitly initialised with ``locked''. The task
Consumer is started from outside. Before it starts the tasks Producer\_1 and
Producer\_2, Into\_buffer must receive the state ``free''.

{\bf PROBLEM};\\
\x {\bf DCL} (Into\_buffer, Out\_of\_buffer) {\bf SEMA};

\begin{tabbing}
\x Producer\_2: \= \kill

\x Consumer: \> {\bf TASK}; \\
    \> \x {\bf RELEASE} Into\_buffer; \\
    \> \x {\bf ACTIVATE} Producer\_1; \\
    \> \x {\bf ACTIVATE} Producer\_2; \\
    \> \x {\bf REPEAT}\\
    \> \x \x {\bf REQUEST} Out\_of\_buffer;\\
    \> \x \x \x ! Output to the protocol printer\\
    \> \x \x {\bf RELEASE} Into\_buffer;\\
    \> \x {\bf END}; ! Loop\\
    \> {\bf END}; ! Consumer\\
    \> \\
\x Producer\_1: \> {\bf TASK};\\
  \> \x {\bf REPEAT} \\
  \> \x \x \x ! Preparing the message \\
  \> \x \x {\bf REQUEST} Into\_buffer;\\
  \> \x \x \x ! Buffering\\
  \> \x \x {\bf RELEASE} Out\_of\_buffer;\\
  \> \x {\bf END}; ! Loop\\
  \> {\bf END}; ! Producer\_1\\
  \> \\
\x Producer\_2: \> {\bf TASK};\\
  \> \x {\bf REPEAT}\\
  \> \x \x \x ! Preparing the message\\
  \> \x \x {\bf REQUEST} Into\_buffer;\\
  \> \x \x \x ! Buffering\\
  \> \x \x {\bf RELEASE} Out\_of\_buffer;\\
  \> \x {\bf END}; ! Loop\\
  \> {\bf END}; ! Producer\_2
\end{tabbing}

Explanation:\\
Output waits first for the release of Out\_of\_buffer, i.e., the
buffering of a message, because Out\_of\_buffer can only be released by
Producer\_1 or Producer\_2. After the output has taken place, Consumer
releases Into\_buffer, i.e., admits buffering, and waits for a new
request. Producer\_1 and Producer\_2 can only buffer a message, if state
``free'' is defined for Into\_buffer; after buffering a message, they
release Out\_of\_buffer resulting in the continuation of Consumer.

The state of a semaphore variable can be obtained with the monadic
operator

{\bf TRY} Name$\S $Sema;

As result, the operator provides a BIT(1) value to be used in all
logical expressions. If the semaphore variable is ``free'', the operator
executes a REQUEST statement and provides value '1'B as result. If the
semaphore variable has already state ``locked'', no REQUEST statement
is executed, and value '0'B is provided. Therefores a possible blocking 
of the running task can be avoided when using the TRY operator!

Example:

In a dialogue system the function Function1 may not be called twice at the same time, although the
blocking of a task calling Function1 has to be avoided.

\begin{tabbing}
\x Dialogue: \= \x \x {\bf RELEASE} Func1; \x \= \kill

{\bf PROBLEM}; \> \> \\
\x {\bf DCL} Func\_1 {\bf SEMA}; \> \> \\
   \> \> \\
   \x Dialogue: \> {\bf TASK}; \> \\
  \> \x ...      \> \\
  \> \x {\bf IF TRY} Func1 {\bf THEN} \> \\
  \> \x \x ! Semaphore variable Func1 had state ``free'' \> \\
  \> \x \x {\bf CALL} Function1; \> ! execute function \\
  \> \x \x {\bf RELEASE} Func1;  \> ! release semaphore \\
  \> \x {\bf ELSE} \> \\
  \> \x \x ! Semaphore variable func\_1 had state ``locked'' \> \\
  \> \x \x {\bf PUT} 'Function 1 not possible at present' {\bf TO} Terminal; \> \\
  \> \x {\bf FIN}; \> \\
  \> \x ... \> \\
  \> {\bf END}; ! Dialogue \>
\end{tabbing}

Due to erroneous synchronisations, tasks can constantly block one
another; such a deadlock, e.g., could arise due to the following program
organisation:

\begin{tabbing}
\hspace{6cm} \= \kill

\underline{Task T1}  \>       \underline{Task T2}  \\
{\bf REQUEST} S1;    \>       {\bf REQUEST} S2;    \\
\x 1st segment       \>       \x 1st segment       \\
{\bf REQUEST} S2;    \>       {\bf REQUEST} S1;    \\
\x 2nd segment       \>       \x 2nd segment       \\
{\bf RELEASE} S2;    \>       {\bf RELEASE} S1;    \\
{\bf RELEASE} S1;    \>       {\bf RELEASE} S2;
\end{tabbing}

If tasks T1 and T2 are in their first segments at the same time, a
deadlock occurs, for on the one hand, T1 is blocked by the execution of
statement ``REQUEST S2;'', because T2 has already built up the lock
with the semaphore variable S2, and on the other hand, T2 is blocked by
the execution of statement ``REQUEST S1;''. If no other task executes
a release, the blockings remain permanently.

To avoid such situations, lists of semaphore variables can be stated for
locking statements.

By executing the statement

{\bf REQUEST} Name$\S $Sema [ , Name$\S $Sema ]$^{...}$ ;

the running task is suspended, if at least one of the indicated semaphore
variables is in state ``locked''; the task is not continued until none
of the semaphore variables is locking any longer. If none of the
indicated semaphore variables is locking, the executing task is
continued after decrementing the values of each of these semaphore variables by
1.

The statement

{\bf RELEASE} Name$\S $Sema [ , Name$\S $Sema ]$^{...}$;

has the effect, as if a release statement were executed for each of
the indicated semaphore variables without any interruption.

In the last example, the deadlock could be avoided by the following
program organisation:

\begin{tabbing}
\hspace{6cm} \= \kill

\underline{Task T1}   \>       \underline{Task T2}   \\
{\bf REQUEST} S1, S2; \>       {\bf REQUEST} S1, S2; \\
\x 1st segment        \>       \x 1st segment        \\
\x 2nd segment        \>       \x 2nd segment        \\
{\bf RELEASE} S1, S2; \>       {\bf RELEASE} S1, S2;
\end{tabbing}

The order of the semaphore variables in the list is of no significance.

After the TRY operator, only one single semaphore variable may be
given, a list of semaphore variables is not allowed.

The general forms for the declaration of semaphore variables as well as
locking and release statements read:

SemaDeclaration ::= \\
\x \{ {\bf DECLARE $\mid$ DCL} \} Identifier\_or\_IdentifierList [ DimensionAttribute ] {\bf SEMA} [ GlobalAttribute ]\\
\x [ {\bf PRESET} (IntegerWithoutPrecision [ , IntegerWithoutPrecision ] $^{...}$ ) ];

RequestStatement ::=\\
\x {\bf REQUEST} Name$\S $Sema [ , Name$\S $Sema ] $^{...}$;

ReleaseStatement ::=\\
\x {\bf RELEASE} Name$\S $Sema [ , Name$\S $Sema ] $^{...}$;

TRY-Operator ::= \\
\x {\bf TRY} Name$\S $Sema

Thus, also arrays of semaphore variables are possible; the various
elements are addressed by indices in the request and release
statements.

Semaphore variables must be declared at module level. Upon declaration,
semaphore variables can also be initialised explicitly by PRESET
statement; the given values are assigned to the corresponding
semaphore variables according to their order.

Example:

Upon declaration, values 3 and 5 shall be assigned to the semaphore
variables S1 and S2, respectively.

{\bf DCL} (S1, S2) {\bf SEMA PRESET}(3, 5);

The general form for the specification of semaphore variables reads:

SemaSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\_or\_IdentifierList\\
\x \x [ VirtualDimensionAttribute ] {\bf SEMA} \\
\x \x \{ GlobalAttribute $\mid$ IdentificationAttribute \};

\begin{added}
Possible problem situations:

\begin{description}
\item[SemaOverFlowSignal] is induces, if too many release operations
   are executed and the range of a FIXED(32) would exceed.
\end{description}

\end{added}
\begin{tobedone}
\subsection{Bolt Variables (BOLT) and Statements (ENTER, LEAVE,
RESERVE, FREE)} % 9.3.2

We assume that in different tasks the same data are used for
calculation, but not modified (e.g., comparison quantities for
supervision processes); additionally, another task shall re-establish
these data (e.g., establishing new supervision data). It shall be
granted that the processes for modifying and using data mutually exclude
each other; in contrast, the simultaneous use of data (by various tasks)
is desired.

These problems can principally be solved with the described locking and
release statements; the formulation, however, is relatively
complicated, and the run time for the execution considerable. Thus, four
more statements working on variables of data type bolt are provided.

A bolt variable can take on the states ``locked'', ``lock possible'', or
``lock not possible'', depending on whether the associated resource
is used exclusively, is free or is used simultaneously.

Bolt variables, e.g., are declared as follows:

{\bf DCL} Identifier\_or\_IdentifierList {\bf BOLT};

After its declaration, a bolt variable has the state ``lock possible''.

Let the bolt variable B be associated to a resource. When entering a
critical section for the exclusive use of this resource, the access by
other tasks is locked by executing the statement

{\bf RESERVE} B;

When leaving this critical section, the release takes place by the
statement

{\bf FREE} B;

The critical sections for the simultaneous use of the resource are
initiated and terminated, respectively, by executing the statements

{\bf ENTER} B; or {\bf LEAVE} B;

The exact description of the effect of theses statements considers the
state and the modification of the bolt variables:
\begin{description}
\item[Effect of RESERVE B;]
If B has state ``lock possible'', B assumes state ``locked''; otherwise,
the executing task is suspended and placed in a queue associated with B.
\item[Effect of FREE B;]
B assumes state ``lock possible''. Furthermore, all tasks waiting in the
queue of B due to a RESERVE statement are released; the tasks repeat
their locking statements in the order of their priorities. If no task
is waiting due to a RESERVE statement, all other waiting tasks, due to 
their ENTER-instruction, are released, in turn repeating the ENTER 
statement in the order of their priorities.
\item[Effect of ENTER B;]
If B has state ``locked'', or if a task is in the queue of B due to a
RESERVE statement, the executing task is suspended and placed in the
queue of B. Otherwise, B assumes state ``lock not possible'', to prohibit
exclusive access; furthermore, the (internally noted) number Z of
``using'' tasks is incremented by 1.\\
(I.e., tasks executing ``ENTER B'' are continued not before the tasks
requiring exclusive access to the resource.)
\item[Effect of LEAVE B;]
If Z = 1, this statement has the same effect as ``FREE B;''.
Otherwise, Z is decremented by 1, and B keeps the state ``lock not
possible''.
\end{description}

Example:

A task Measurement continuously acquires values of comparison
quantities needed by the tasks Control and Disposition for
calculations from a process to be supervised. It shall be granted that
Measurement changes the comparison quantities only if they are not
used; in contrast, Control and Disposition shall use the
comparison quantities simultaneously.

For this, a bolt variable Vvalue is declared; in the bodies of the three
tasks the critical sections of the modification or the use of the
comparison quantities are initiated or terminated, respectively, as
follows:

In the body of Measurement:

...\\
{\bf RESERVE} Vvalue;\\
\x ! modification\\
{\bf FREE} Vvalue;\\
...

In the bodies of Control and Disposition:

...\\
{\bf ENTER} Vvalue;\\
\x ! use\\
{\bf LEAVE} Vvalue;\\
...

All statements for bolt variables are also defined for lists of bolt
variables --- analogously to the request and release statements for
semaphore variables.

Generally, bolt variables can be declared and used as follows:

BoltDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} Identifier\_or\_IdentifierList 
[ DimensionAttribute ] {\bf BOLT}\\
\x [ GlobalAttribute ] ;

BoltSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\_or\_IdentifierList 
[ VirtualDimensionAttribute ]\\
\x \x {\bf BOLT} \{ GlobalAttribute $\mid$ IdentificationAttribute \} ;

\begin{tabbing}
\x $\mid$ \= {\bf RESERVE} \= \kill
BoltStatement ::= \> \> \\
   \> {\bf RESERVE} \> Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;\\
\x $\mid$ \> {\bf FREE}    \> Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;\\
\x $\mid$ \> {\bf ENTER}   \> Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;\\
\x $\mid$ \> {\bf LEAVE}   \> Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;
\end{tabbing}

Therefore, also arrays of bolt variables can be declared.

Bolt declarations must take place at module level.
\end{tobedone}


\section{Interrupts and Interrupt Statements}   % 9.4
\begin{tobedone}
\subsection{Declarations of Interrupts and Software Interrupts}    % 9.4.1

An interrupt is a message of the controlled process via an interrupt
input line of the interrupt controller to the operating system, which,
after occurrence of the interrupt has to initiate the reaction planned
by the programmer for that case, e.g., ``Upon occurrence of interrupt
Ready, task Supply is to be started''.

The interrupt channels provided in a computer system are described in the
user manual, giving their (system) names. The interrupt channels required
by a PEARL program are declared in the system part, where user names can
be associated to them. Under these user names, they are specified as
interrupts in the problem part, to be able to use them in the task
control statements (see 9.2) and the interrupt statements.

Example:

\begin{tabbing}
Initialisation: \= \kill

{\bf MODULE}; \> \\
{\bf SYSTEM}; \> \\
\x Ready: Hard\_Int(7); ! Hard\_Int is the system name \> \\
   \> \\
{\bf PROBLEM}; \> \\
{\bf SPECIFY} Ready {\bf INTERRUPT}; \> \\
... \> \\
Initialisation: \> {\bf TASK}; \\
  \> ... \\
  \> {\bf WHEN} Ready {\bf ACTIVATE} Supply; \\
  \> ... \\
  \> {\bf END}; ! Initialisation \\
  \> \\
...             \> \\
Supply:         \> {\bf TASK PRIORITY} 2;\\
  \> ! task body \\
  \> {\bf END}; ! Supply \\
...             \>
\end{tabbing}

The general form of an interrupt specification reads:

InterruptSpecification ::=\\
\x \{ {\bf SPECIFY $\mid$ SPC} \} Identifier\_or\_IdentifierList \{ {\bf INTERRUPT $\mid$ IRPT} \}\\
\x [ GlobalAttribute ];

Most modern computers and operating systems, however, do not provide the
possibility to address interrupt channels anymore, because hardware
oriented device control and supervision are taken over by programmable
logic controllers. The possibilities for interrupts provided by PEARL,
however, are also usable for so-called {\em software interrupts}
introduced into the system part under their own system names. The user manual
gives information about the system name and usage possibilities.

\subsection{Interrupt Statements (TRIGGER, ENABLE, DISABLE)}    % 9.4.2

First, interrupts are disabled by their declarations and have to be
enabled by an enable statement.

If the effect of an enabled interrupt, e.g., upon malfunctions in the
technical process, shall be suppressed, i.e., start conditions for task
statements related to it shall stay ineffective although the interrupt
occurs, a disable statement is to be executed for this purpose, which
in turn can be revoked again by executing an enable statement.

DisableStatement ::= \\
\x {\bf DISABLE} Name$\S $Interrupt;

EnableStatement ::=  \\
\x {\bf ENABLE} Name$\S $Interrupt;

The validity range of the disable statement starts with its
execution and ends upon execution of an enable statement.

Example:

{\bf MODULE};\\
{\bf SYSTEM};\\
\x Alarm: INT;\\
\x ...\\
{\bf PROBLEM};

\x {\bf SPC} Alarm {\bf INTERRUPT};\\
\x ...\\
\x Init: {\bf TASK MAIN};\\
\x \x {\bf WHEN} Alarm {\bf ACTIVATE} Recovery;\\
\x \x {\bf ENABLE} Alarm;\\
\x \x ... \\
\x \x {\bf END}; ! Init

\x Recovery: {\bf TASK PRIO} 1;\\
\x \x {\bf DISABLE} Alarm;\\
\x \x \x ! checking the reason\\
\x \x \x ! initiate reaction\\
\x \x {\bf ENABLE} Alarm;\\
\x \x {\bf END}; ! Recovery\\
\x ...\\
{\bf MODEND};

The test of real time programs requires sometimes to simulate the effect
of interrupts, particularly if the technical process has not been
connected to the computer, yet. For such simulations, the trigger
statement is provided:

TriggerStatement := \\
{\bf TRIGGER} Name$\S $Interrupt;

Example:

\begin{tabbing}
\hspace{6cm} \= \kill

{\bf MODULE};                 \> {\bf MODULE}(Test);\\
{\bf SYSTEM};                 \> {\bf PROBLEM};\\
         \> \\
\x Ready: Soft\_Int;          \> \x {\bf SPC} Ready {\bf IRPT GLOBAL};\\
\x ...                        \> \\
{\bf PROBLEM};                \> \x ...\\
\x ...                        \> \\
\x {\bf WHEN} Ready           \> \x $/^*$ e.g., at random times $^*/$ \\
\x \x {\bf ACTIVATE} Control; \> \x {\bf TRIGGER} Ready;\\
\x ...                        \> \x ...\\
{\bf MODEND};                 \> {\bf MODEND};
\end{tabbing}

\chapter{Input and Output}   % 10

The input and output statements enable the transfer of data from the
working memory of the computer to an external data station (output) and
vice versa, the transfer of data from an external data station to the
working memory (input). Primarily, data stations are standard peripheral
devices (printer, console, disk, magnetic tape, keyboard, etc.) or
process peripherals (sensors, actuators, embedded controllers, etc.).

On these {\em system defined} data stations, {\em user defined} data
stations can be created in the program to store data, e.g., on disks,
magnetic tapes, printers, etc.

In the I/O statements of the problem part, the data stations are
addressed under freely selectable, logical user names; the features of
the data stations are to be specified before mentioning these names.

In conventional programming languages, the association of the logical
identifiers (user names) for data stations used in the program to the
devices of a particular computer system is done by additional control
definitions when setting up a compiler program (job control
definitions). In PEARL, these associations take place in standardised
notation by declarations in the system part.
\end{tobedone}

\section{System Part}    % 10.1

The system part serves for describing the used I/O configurations of a
PEARL program. A system name must be associated with all devices of a
computer system which can directly be addressed with PEARL I/O
statements. A list of these devices and their system names can be
found in the PEARL user manual of the corresponding target system. In
the system part, freely selectable user names must be assigned to the
system names of the needed devices. The devices can only be addressed in
I/O statements of the problem part via these user names. If there are
several devices of the same type, they can also be distinguished by an
index added to the system name. Thus, a system name has the following
general form:

SystemName ::=\\
\x Identifier [ (nni$\S $index) ]

nni ::=\\
\x IntegerWithoutPrecision$\S $NonNegative

For most of the process devices, further details are necessary, such as
the channel number, and for digital I/O channels, even the selection of
single bits can be desired. Thus, the following extension after the
system name is possible for process devices:

ExtensionProcessDevice ::=\\
\x $^*$nni$\S $ChannelNumber [ $^*$nni$\S $Position [ , nni$\S $Width ] ]

With ``Position'', e.g., the initial bit position of the device
connection of a digital input/output, with ``Width'', the number of bits
of this device connection can be given.

Thus, a system part consists of a number of device associations of the
following form:

DeviceAssociation ::=\\
\x UserName: SystemName [ ExtensionProcessDevice ]

UserName ::=\\
\x Identifier

For the example of a system part as given below, a fictive computer
system with the following system names is assumed:

\begin{tabular}{l@{\x}l}
SystemName & Device \\ \hline
STDIN      & standard input (console) \\
STDOUT     & standard output (console) \\
SERIAL     & for I/O with serial interfaces \\
DISC       & for reading and writing files (disk, floppy,...)\\
DIGIO      & digital I/O\\
\end{tabular}

PEARL example for the system part:

\begin{tabbing}
\x dateout: \= \kill
{\bf MODULE} (example); \> \\
{\bf SYSTEM}; \> \\
\x termin:  \> STDIN; \\
\x termout: \> STDOUT;\\
\x file:    \> DISC;  \\
\x tty\_1:  \> SERIAL(1);\\
\x tty\_4:  \> SERIAL(4);\\
\x counter: \> DIGIO$^*$0; \\
\x switch:  \> DIGIO$^*$1$^*$16,1; \\
\x motor:   \> DIGIO$^*$1$^*$1,4;  \\
\x ... \> \\
{\bf PROBLEM};\> \\
\x ... \>
\end{tabbing}

The available devices and the associated system names must be taken from
the corresponding user manual of a PEARL implementation. There it is
also described, whether (and, if yes, how) system names can be changed.
For most PEARL systems there is an additional possibility to integrate
device drivers and their system names created by the user into the PEARL
system and to address them with PEARL I/O statements.

\section{Specification and Declaration of Data Stations (DATION) in 
the Problem Part}   % 10.2

\subsection{System Data Stations}   % 10.2.1

Before using system defined data stations, they must be specified in the
problem part, defining their associated user names. For the
declarations from the above example, this can take place as:

\begin{tabular}{llll}
{\bf SPC} & termin  & {\bf DATION IN}    & {\bf ALPHIC},\\
   & termout & {\bf DATION OUT}   & {\bf ALPHIC},\\
   & file    & {\bf DATION INOUT} & {\bf ALL},   \\
   & tty\_1  & {\bf DATION IN}    & {\bf ALPHIC},\\
   & tty\_4  & {\bf DATION INOUT} & {\bf ALL},   \\
   & counter & {\bf DATION IN}    & {\bf BASIC}, \\
   & switch  & {\bf DATION OUT}   & {\bf BASIC}, \\
   & motor   & {\bf DATION OUT}   & {\bf BASIC}; \\
\end{tabular}

The general form reads:

DationSpecification ::= \\
\x \{ {\bf SPECIFY $\mid$ SPC} \} IdentifierDenotation TypeDation [ GlobalAttribute ] ;

The different attributes in a system dation specification describe the
fundamental features of the physical device to be communicated with. The
features of a device and the possible attributes are described for all
devices in the user manual.

\subsection{User Defined Data Stations}    % 10.2.2

By a dation declaration, a logical, so-called user defined data station
(or user dation) is created on a physical device (system dation). The
allocation to a device is determined by the CREATED attribute.

All input/output statements described in the following refer to user
dations --- the direct declaration of system dations leads to run time
errors.

DationDeclaration ::= \\
\x \{{\bf DECLARE $\mid$ DCL}\} IdentifierDenotation TypeDation [GlobalAttribute]\\
\x {\bf CREATED} (Name$\S $SystemDefDation);

Hence, no arrays of data stations may be declared. However, it is
possible to declare arrays of references to data stations to enable also
indexed addressing of data stations.

The various attributes enable the detection of contradictions between
the features of data stations and their way of using in I/O statements
already at compilation time.

TypeDation ::= \\
\x {\bf DATION} SourceSinkAttribute ClassAttribute\\
\x [ Structure ] [ AccessAttribute ]

Each data station is source and/or sink of a data transmission. The
corresponding feature must be given upon declaration:

SourceSinkAttribute ::= \\
\x {\bf IN $\mid$ OUT $\mid$ INOUT}

IN means that this data station is a source for data, i.e., it may only
appear in such data transmission statements which transmit these data
{\em into} the working memory (e.g., digital inputs, keyboard).

Data stations specified with OUT may only be used as sinks for outputs
from the working memory (e.g., printer).

A data station with attribute INOUT allows for data transmissions in
both directions (e.g., disk).

The data transmissions take place with the computer internal format of
the data or by means of conversion between computer internal and
external format. For this, PEARL provides three different kinds of I/O
statements:
\begin{itemize}
\item The READ/WRITE statements for transmission in computer internal
format (e.g., for disk data, see 10.4).
\item The PUT/GET statements for transmission with conversion between
internal format and representation in the character set available on the
data station (e.g., for printer output, see 10.5).
\item The TAKE/SEND statements for transmitting process data (see
10.7).
\end{itemize}

The data transmission to or from a data station can only take place in
one of the given ways.

The selection is made when declaring the data station by means of the
class attribute stating to which of the three classes the data belong:
\begin{itemize}
\item If the READ/WRITE statements are to be used, i.e., if the data
station records data in computer internal form, the type of data to be
transmitted is stated as class attribute, e.g., FIXED, or FLOAT (53),
or BIT (16), or ALL (for various types).
\item If the data are represented alphanumerically on the data stations
(case PUT/GET), the data station gets the class attribute ALPHIC.
\item Data stations for transmissions with the TAKE/SEND statements
have class attribute BASIC.
\end{itemize}

The general form of the class attribute reads:

ClassAttribute ::= \\
\x {\bf ALPHIC $\mid$ BASIC} $\mid$ TypeOfTransmissionData

TypeOfTransmissionData ::=\\
\x {\bf ALL} $\mid$ SimpleType $\mid$ CompoundType

SimpleType ::= \\
\x TypeInteger $\mid$ TypeFloatingPointNumber $\mid$ TypeBitString $\mid$\\
\x TypeCharacterString $\mid$ TypeTime $\mid$ TypeDuration

CompoundType ::= \\
\x IO-Structure $\mid$ Identifier$\S $ForNewTypeFromSimpleTypes

IO-Structure ::=\\
\x {\bf STRUCT} [ IO-StructureComponent [ , IO-StructureComponent ] $^{...}$ ]

IO-StructureComponent := \\
\x IdentifierDenotation\\
\x \{ SimpleType $\mid$ IO-Structure $\mid$ Identifier$\S $ForNewTypeFromSimpleTypes \}

Hence, the type of the transmission data may also be a multiply
structured structure or a newly defined type, but no component being of
type reference.

Example:

\begin{tabbing}
{\bf TYPE} \= \kill

...        \> \\
{\bf TYPE} \> Kind\_Structure {\bf STRUCT} \\
    \> {\bf [} (No, Number) {\bf FIXED},\\
    \> \x Weight {\bf FLOAT}, ...{\bf ]};\\
{\bf DCL}  \> Kind\_File {\bf DATION INOUT} Kind\_Structure ...,\\
    \> Tab {\bf DATION INOUT FIXED} ...;
\end{tabbing}

The attribute ALL includes all other possibilities of type of
transmission data.

Example:

On a disk memory drive with system name PSP31 and user name Disk, a file
File1 for the input of FIXED quantities and a file File2 for the
input/output of FLOAT quantities with computer internal format are to be
created.

{\bf SYSTEM};\\
\x Disk: PSP31;

{\bf PROBLEM};\\
\x {\bf SPC} Disk {\bf DATION INOUT ALL} ...;\\
\x {\bf DCL} File1 {\bf DATION IN FIXED} ... {\bf CREATED} (Disk);\\
\x {\bf DCL} File2 {\bf DATION INOUT FLOAT} ... {\bf CREATED} (Disk);

The source/sink attribute and the class attribute must be defined for
each data station, in contrast to the now described attributes for the
structure and access possibilities of a data stations.

The smallest data set transmitted to or from a data station is called
data element. Its type is determined by the class attribute. Several
data elements can be combined into a record (synonymously, line), and
several records to a segment (syonymously, page), i.e., all elements
make up a 1-, 2-, or 3-dimensional array. For this, the number of data
elements in a line, the number of lines in a page, and the number of
pages must be denoted in the structure attribute:

Typology ::= \\
\x {\bf DIM} ( \{ $^*$ $\mid$ pi \} [ , pi [ , pi ] ] ) [ {\bf TFU} [ {\bf MAX} ] ]

The pi denotation furthest to the right always denotes the number of
elements per line, the next (possibly lacking) pi denotation denotes
the number of lines per page, and the following (possibly lacking) pi
denotation denotes the number of pages. The denotation $^*$ means that
the corresponding number is not limited. E.g., a data station Printer
with 120 characters per line, 60 lines per page, and any number of pages
can obtain the structure ($^*$, 60, 120).

The following combinations are possible:
\begin{itemize}
\item 3-dimensional typology\\
DIM (number of pages, number of lines, number of elements), or\\
DIM ($^*$, number of lines, number of elements)
\item 2-dimensional typology\\
DIM (number of lines, number of elements), or\\
DIM ($^*$, number of elements)
\item 1-dimensional typology\\
DIM (number of elements), or\\
DIM ($^*$)
\end{itemize}

Furthermore, the typology indicates, how many data elements are
transmitted {\em at least} upon the execution of {\em one} data
transmission statement:
\begin{itemize}
\item If the attributes TFU and MAX are lacking, single data elements,
lines or pages can be transmitted.
\item Attribute TFU means that only lines or pages are transferable.\\
If the actual number of data elements in a data transmission statement
is less than the number of data elements of a line or page, this line or
page, respectively, is implicitly padded with spaces (ALPHIC data
stations) or zeros (BASIC data stations).

Example:

{\bf DCL} Printer {\bf DATION OUT ALPHIC DIM}($^*$, 60, 120) {\bf TFU} ...;\\
... \\
{\bf PUT} 'PEARL' {\bf TO} Printer;

This PUT statement has the effect that the five characters P, E, A, R,
L are written out in one (new) line by Printer.
\item TFU MAX corresponds to TFU.
\end{itemize}

The possible ways of accessing a data station are determined by the
access attribute:

AccessAttribute ::= \\
\x {\bf \{ DIRECT $\mid$ FORWARD $\mid$ FORBACK \} [ NOCYCL $\mid$ CYCLIC ]}\\
\x {\bf [ STREAM $\mid$ NOSTREAM ]}

DIRECT means that (based on a transmitted data element) any data element
can directly be accessed, giving the position of the element (see 10.4,
10.5).

The attributes FORWARD and FORBACK mean sequential access; i.e., the
access may (based on a transmitted element) only take place in the order
determined by the structure --- for FORWARD only forward, for FORBACK in
both directions ---, possibly giving the relative position of the wanted
element to the element just transmitted (see 10.4, 10.5).

NOCYCL, CYCLIC, STREAM, and NOSTREAM are treated in the context of the
I/O statements in 10.4 and 10.5.

Example:

On a disk drive with system name PSP31 and user name Disk a file for a
table with 300 lines and 5 columns (elements per line) is to be created.
Let the table elements be floating point numbers; the access takes place
to elements directly and only reading.

{\bf MODULE};\\

{\bf SYSTEM};\\
\x Disk: PSP31;\\
\x ... \\
\label{Example}
{\bf PROBLEM};\\
\x {\bf SPC} Disk {\bf DATION INOUT ALL};\\
\x {\bf DCL} Table {\bf DATION IN FLOAT DIM}(300, 5) {\bf DIRECT}\\
\x \x {\bf GLOBAL CREATED} (Disk);\\
\x ...

Examples for the declaration of data stations for inputs/outputs in
character form are described in 10.4 and 10.5.

\section{Opening and Closing of Data Stations (OPEN, CLOSE)}   % 10.3

Before a data station may be used for the first time in a data
transmission statement, it must be opened by the open statement:

OpenStatement ::=\\
\x {\bf OPEN} Name$\S $Dation [ {\bf BY} OpenParameter [ , OpenParameter ] $^{...}$ ] ;

When executing the open statement, a data station with typology is
positioned at its beginning.

The open parameters serve to handle data stations containing
identifyable files. E.g., a system defined data station Disk can possess
a file TAB1, which is also maintained after terminating the program
under this name. Later on, the same or another program can create a user
defined data station Table on Disk, identified with file TAB1 in the
open statement.

OpenParameter ::=\\
\x {\bf IDF} ( \{Name$\S $CharacterVariable $\mid$ CharacterStringConstant \} ) $\mid$\\
\x {\bf RST} (Name$\S $ErrorVariable-FIXED) $\mid$ \\
\x \{ {\bf OLD $\mid$ NEW $\mid$ ANY} \} $\mid$ \\
\x \{ {\bf CAN $\mid$ PRM} \}

The open parameters of the open statement must belong to different
subsets.

Meaning of the parameters:
\begin{itemize}
\item IDF (Name$\S $CharacterVariable $\mid$ CharacterStringConstant)\\
The value of the specified character variable or the specified character
string constant is the name of the file to be identified with the data
station named Name$\S $Dation.
\item RST (Name$\S $ErrorVariable-FIXED)\\
If an error occurs during the OPEN execution, the specified variable is
assigned an error number unequal to zero; in the error-free case, it is
set to zero (see 10.8).
\item OLD\\
If there is a file with IDF name, it its allocated on the notated data
station. Otherwise, or if IDF is lacking, an error message is given, or
the RST variable is set with the error number.
\item NEW\\
A file with IDF name is created and identified with the notated data
station. If there is already a file with this name, or if IDF is
lacking, an error message is given, or the RST variable is set with the
error number.
\item ANY\\
If there is already a file with IDF name, it is identified with the
notated data station. Otherwise, a new file is created for it. If IDF
is lacking, a new file is created under a name determined by the system
and identified with the denoted data station.
\item CAN (from ``cancel'')\\
The file is no longer to be made accessible after executing the close
statement (see below).
\item PRM (from ``permanent'')\\
The file is still there after executing the close statement, and again
accessible with the same name after re-executing an open statement.
\end{itemize}

If open parameters are lacking, ANY and PRM are assumed.

When executing the close statement, a file is closed; i.e., it is
usable again not before the execution of an open statement.

CloseStatement ::=\\
\x {\bf CLOSE} Name$\S $Dation [ {\bf BY} CloseParameter [ , CloseParameter ] $^{...}$ ] ;

The settings for closing a data station made in the open statement can
be overwritten by a close statement:

CloseParameter ::=\\
\x {\bf CAN $\mid$ PRM $\mid$ RST} (Name$\S $ErrorVariable-FIXED)

Generally, the following rules hold:
\begin{itemize}
\item Not every task executing an access to a data station must execute
an open or close statement.
\item However, at least one open statement must be executed concerning
the access to a data station.
\item The same number of close statements and open statements must
be executed to close the data station.
\item Corresponding open and close statements need not be executed by
the same task.
\item Upon lacking parameters, ANY and PRM are assumed, unless earlier
executed close or open statements have made explicit settings.
\end{itemize}

Example:

{\bf MODULE};\\
{\bf SYSTEM};\\
\x Printer: DRUA;\\
\x Disk: PSP31;\\
\x ... \\
{\bf PROBLEM};\\
\x {\bf SPC} Printer {\bf DATION OUT ALPHIC};\\
\x {\bf DCL} Tab\_Prot {\bf DATION OUT ALPHIC DIM}($^*$, 50, 30) {\bf FORWARD}\\
\x \x {\bf GLOBAL CREATED}(Printer);\\
\x {\bf SPC} Disk {\bf DATION INOUT ALL};\\
\x {\bf DCL} Table {\bf DATION IN FLOAT DIM}(300, 5) {\bf DIRECT}\\
\x \x {\bf GLOBAL CREATED}(Disk);

Start: {\bf TASK MAIN};\\
\x {\bf OPEN} Tab\_Prot;\\
\x {\bf OPEN} Table {\bf BY} IDF('TAB-1'), OLD;\\
\x {\bf ACTIVATE} Prot;\\
\x ...\\
\x {\bf END}; ! Start

Prot: {\bf TASK};\\
\x ! Data transmission statements with Table and Tab\_Prot\\
\x ...\\
\x {\bf CLOSE} Tab\_Prot;\\
\x {\bf CLOSE} Table; \\
\x {\bf END}; ! Prot \\
... \\
{\bf MODEND};

\section{The Read and Write Statements (READ, WRITE)}   % 10.4

The read statement serves for the input, the write statement for the
output of data without converting the computer internal representation
(binary input/output). Data can be transmitted to or from the connected
devices (e.g., a file on disk or magnetic tape). The corresponding data
stations must be declared with the class attribute
``TypeOfTransmissionData''.

Examples:

\begin{enumerate}
\item Columns 4 and 5 in the dation Table (cf. the example on page
\pageref{Example}) are to be replaced by re-calculated values.

...\\
{\bf DCL} (x, y, z) {\bf FLOAT};\\
...\\
{\bf FOR} line {\bf FROM} 1 {\bf TO} 300\\
{\bf REPEAT}\\
\x ! calculation of x, y, z\\
\x {\bf WRITE} x, SIN(y+z) {\bf TO} Table {\bf BY POS}(line, 4);\\
{\bf END};

\item A task Measurement periodically acquires 14 temperature values
(Procedure Get\_Temp), processes them, and writes them sequentially in
blocks with 14 values in a logbook on the disk.

{\bf SYSTEM};\\
\x File: DISC;

{\bf PROBLEM};\\
\x {\bf SPC} Get\_Temp {\bf PROC}(i {\bf FIXED}) {\bf RETURNS} ({\bf FIXED}(15)) {\bf GLOBAL};\\
\x {\bf SPC} File {\bf DATION INOUT ALL};\\
\x {\bf DCL} Logbook {\bf DATION OUT FIXED}(15) {\bf DIM}($^*$, 14) {\bf TFU FORWARD}\\
\x \x {\bf CREATED} (File);\\
\x {\bf DCL} Num\_Temp {\bf INV FIXED}(15) {\bf INIT}(14);

Start: {\bf TASK MAIN};\\
\x {\bf OPEN} Logbook; \x ! Positioning to beginning\\
\x {\bf ALL} 10 {\bf SEC ACTIVATE} Measurement;\\
\x ... \\
\x {\bf END}; ! Start

Measurement: {\bf TASK};\\
\x {\bf DCL} Temperature (Num\_Temp) {\bf FIXED}(15); \\
\x {\bf FOR} i {\bf TO} Num\_Temp\\
\x {\bf REPEAT}\\
\x \x Temperature(i) := Get\_Temp(i);\\
\x {\bf END};\\
\x ! Processing the measured values\\
\x {\bf WRITE} Temperature {\bf TO} Logbook; \\
\x {\bf END}; ! Measurement
\end{enumerate}

The general forms of the read and write statements read:

ReadStatement ::= \\
\x {\bf READ} [ \{ Name$\S $Variable $\mid$ Segment \} [ , \{ Name$\S $Variable $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;

WriteStatement ::=\\
\x {\bf WRITE} [ \{ Expression $\mid$ Segment \} [ , \{ Expression $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;

Segment ::= \\
\x Name$\S $Field ( [ Index , ] $^{...}$ Index : Index)

Index ::=\\
\x Expression$\S $WithIntegerAsValue

Position ::= \\
\x AbsolutePosition $\mid$ RelativePosition $\mid$ {\bf RST} (Name$\S $ErrorVariable-FIXED)

AbsolutePosition ::=\\
\x \{ {\bf COL $\mid$ LINE} \} (Expression) $\mid$\\
\x {\bf POS} ( [ [ Expression , ] Expression , ] Expression) $\mid$ \\
\x {\bf SOP} ( [ [ Name , ] Name , ] Name)

RelativePosition ::=\\
\x \{ {\bf X $\mid$ SKIP $\mid$ PAGE} \} [ (Expression) ] $\mid$ \\
\x {\bf ADV} ( [ [ Expression , ] Expression , ] Expression )

Upon entry with the read statement, the addressed data elements are
read one after the other and correspondingly assigned to the variables
in the variable list. The variables are assigned according to the
general rules for assignments. If an element of the variable list is an
array, the addressed data are assigned by rows; if it is a structure, the
data are assigned to the structure components in the order determined by
the structure declaration.

For simplicity in writing, the elements (of the last dimension) of an
array following one another in the variable list can be declared in form
of a segment. Let list be an array with ten elements list(1), ... ,
list(10); then the two following statements are equivalent:

{\bf READ} list(2), list(3), list(4) ... ;\\
{\bf READ} list (2 : 4), ... ;

All position expressions are completely evaluated, before values are
assigned to the data elements.

Example:

Read X from position 3 and Y from position 5 from the dation file:

{\bf READ} X {\bf FROM} File {\bf BY POS}(3) ;\\
{\bf READ} Y {\bf FROM} File {\bf BY POS}(5) ;

The execution of the statement

{\bf READ} X, Y {\bf FROM} File {\bf BY POS}(3), {\bf POS}(5) ;

however, results in that X being read from position 5 and Y from the
subsequent position.

The RST attribute (cf. 10.8) can occur anywhere in the position list.
However, it does not become effective until it is evaluated. A position
list is elaborated one after the other, starting from the left. If an
error occurs, the elaboration of the I/O statement is aborted in this
position, and the error reaction valid at this moment (error assignment
to an RST variable or system reaction) is executed.

These statements analogously hold for the write statement.

The type of the variables in the variable list of the read statement
must be compatible with the class attribute of the given data station;
this holds analogously for the results of the expressions in the
expression list of the write statement.

The variable or expression list of the read or write statement may be
lacking, if these statements shall only be used for positioning in the
denoted data stations. In this case, however, a position must be
given.

The values in the position list refer to the structure of the data
station and determine the data elements to be transmitted. Thus, the
values of the expressions must be of type FIXED and must be compatible
with the structure.

When using an absolute position, i.e., a position independent from the
actual data element, the data station must have the access attribute
DIRECT. A relative position denotes the distance of the data element to
be transmitted from the current data element; in this case, the data
station must have the access attribute FORWARD, FORBACK or DIRECT.

In detail, the possible position attributes have the following
meanings:
\begin{itemize}
\item COL (Expression)\\
refers to the first dimension (from the right) of the structure and
determines the i-th element in the current line of the data station, if
i equals the value of the expression.
\item LINE (Expression)\\
refers to the second dimension of the structure and determines the i-th
line of the current page of the data station, if i equals the value of
the expression.

Example:

A 2-dimensional array corresponds to the structure (5,10):

\setlength{\unitlength}{0.00087500in}%
\begin{picture}(5627,2781)(179,-2206)
\thicklines
\put(451,-1861){\framebox(4500,2250){}}
\thinlines
%\multiput(1891,-61)(-5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(1891,-61){\line(-1,-1){90}}
\put(1981,-61){\line(-1,-1){180}}
\put(2071,-61){\line(-1,-1){270}}
\put(2161,-61){\line(-1,-1){360}}
\put(2251,-61){\line(-1,-1){450}}
\put(2251,-151){\line(-1,-1){360}}
\put(2251,-241){\line(-1,-1){270}}
\put(2251,-331){\line(-1,-1){180}}
%\multiput(2251,-421)(-5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(2251,-421){\line(-1,-1){90}}
\put(1801,-61){\line( 1,-1){450}}
\put(1891,-61){\line( 1,-1){360}}
\put(1981,-61){\line( 1,-1){270}}
\put(2071,-61){\line( 1,-1){180}}
%\multiput(2161,-61)(5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(2161,-61){\line( 1,-1){90}}
\put(1801,-421){\line( 1,-1){90}}
\put(1801,-151){\line( 1,-1){360}}
\put(1801,-241){\line( 1,-1){270}}
\put(1801,-331){\line( 1,-1){180}}
%\multiput(1801,-421)(5.62500,-5.62500){17}{\makebox(6.3500,9.5250){\SetFigFont{7}{8.4}{rm}.}}
\put(1801,389){\line( 0,-1){2250}}
\put(2251,389){\line( 0,-1){2250}}
\put(451,-61){\line( 1, 0){4500}}
\put(451,-511){\line( 1, 0){4500}}
\put(676,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}1}}}
\put(1126,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}2}}}
\put(1576,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}3}}}
\put(2026,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}4}}}
\put(2476,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}5}}}
\put(2926,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}6}}}
\put(3376,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}7}}}
\put(3826,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}8}}}
\put(4276,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}9}}}
\put(4726,479){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}10}}}
\put(226,-1726){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}5}}}
\put(2026,-2176){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}COL(4)}}}
\put(5491,-376){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}LINE(2)}}}
\put(226,-331){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}2}}}
\put(226,119){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}1}}}
\put(226,-781){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}3}}}
\put(226,-1231){\makebox(0,0)[b]{\smash{\SetFigFont{12}{14.4}{rm}4}}}
\end{picture}

\item POS ( [ [ Expression$\S $Page , ] Expression$\S $Row , ] Expression$\S $Column )\\
gives the position of a data element in the n-dimensional structure
(n = 1, 2, 3) of a data station. Lacking expressions are replaced by the
respective current value.

Example:

With the statement

{\bf READ} x {\bf FROM} File1 {\bf BY POS}(3,2,8);

the eighth data element of the second row of the third page of File1 is
read into x. If this is followed by the statement

{\bf READ} x {\bf FROM} File1 {\bf BY POS}(4,5);

the fifth data element of the fourth row of the third page of File1 is
read into x.
\item SOP ( [ [ Name$\S $Page , ] Name$\S $Row , ] Name$\S $Column )\\
is the counterpart to POS. With SOP, the current positions of a dation
can be assigned to the given program variables. The number of names in
SOP may not exceed the number of dimensions in the addressed dation.
\end{itemize}

In the following, let i be the value of the respective expression.
\begin{itemize}
\item X [ (Expression) ]\\
refers to the first dimension of the structure and determines the i-th
element behind (i positive) or before (i negative), respectively, the
current element in the current row of the data station; i = 0 denotes
the current element.
\item SKIP [ (Expression) ]\\
refers to the second dimension of the structure and determines the start
(the first element) of the i-th row behind (i positive) or before (i
negative), respectively, the current row of the current page of the data
station; i = 0 denotes the current row.
\item PAGE [ (Expression) ]\\
refers to the third dimension of the structure and determines the start
of the i-th page behind (i positive) or before (i negative),
respectively, the current page of the data station; i = 0 denotes the
current page.
\end{itemize}

If the Expression denotation is not present for X, SKIP, or PAGE, respectively,
value 1 is assumed. The value of a given expression must be positive, if
the data station has the attribute FORWARD.
\begin{itemize}
\item ADV ( [ [ Expression$\S $Page , ] Expression$\S $Row , ] Expression$\S $Column )\\
gives the distance of the data element to be transmitted from the
current data element. Missing expressions are replaced by the value
zero. If the data station has the attribute FORWARD, the value for the
expression furthest to the left must be positive or zero.
\end{itemize}

Examples:

Let the corresponding data station File1 have the structure (10, 10,
10), let the actual position be (5,3,8).

\begin{tabular}{l@{\x}l@{\x}l}
position statement   & new position &     \\ \hline
X                    & (5,3,9)      &     \\
X (-5)               & (5,3,3)      &     \\
X (4)                & (5,4,2)      & (1) \\
SKIP (2)             & (5,5,1)      &     \\
SKIP (-1)            & (5,2,1)      &     \\
PAGE                 & (6,1,1)      &     \\
PAGE (6)             & (1,1,1)      & (2) \\
PAGE (-4)            & (1,1,1)      &     \\
ADV (2,5,1)          & (7,8,9)      &     \\
ADV (1,0)            & (5,4,8)      &     \\
ADV (-3,-2,1)        & (2,1,9)      &     \\
ADV (1,8,0)          & (7,1,8)      & (3)
\end{tabular}

With a relative positioning, dimension boundaries may not be exceeded
(cf. the marked examples), unless the data station possesses the access
attribute STREAM or CYCLIC, respectively. STREAM allows to exceed the
internal dimension boundary (examples (1) and (3)), but not to exceed
the boundary of the highest dimension (example (2)). For this, a data
station must possess the attribute CYCLIC. If error reactions shall
occur upon exceeding the corresponding boundaries, the attributes
NOSTREAM or NOCYCL, respectively, must be given. By default, STREAM and
NOCYCL are assumed.

Example:

{\bf DCL} File1 {\bf DATION INOUT FIXED DIM}(10,10,10) {\bf FORWARD CYCLIC}\\
\x {\bf GLOBAL CREATED}(Disk);

Let each time the current position be (5,3,8). Then it holds:

\begin{tabular}{l@{\x}l}
position statement   & new position \\ \hline
X (6)                & (5,4,4)      \\
SKIP (8)             & (6,1,1)      \\
PAGE (7)             & (2,1,1)      \\
ADV (9,0,3)          & (4,4,1)
\end{tabular}

\section{The Get and Put Statements (GET, PUT)}    % 10.5

The get statement serves for the input, the put statement for the
output of data with conversion between computer internal and external,
character oriented representations on ALPHIC data stations. To control
this conversion, formats can be declared.

Examples:

\begin{enumerate}
\item The following text is to appear on the monitor of a storekeeper:

\begin{verbatim}
___article no:__4711
___stock:_______1281
\end{verbatim}

Program steps required:

...\\
{\bf SPC} monitor {\bf DATION INOUT ALPHIC};\\
{\bf DCL} stock\_monitor {\bf DATION INOUT ALPHIC DIM}($^*$,20,80)\\
\x {\bf FORWARD GLOBAL CREATED} (monitor);\\
{\bf DCL} (artno, stock) {\bf FIXED};\\
...\\
{\bf PUT} 'article no:', artno, 'stock:', stock {\bf TO} stock\_monitor\\
\x {\bf BY X}(3), {\bf A}(13), {\bf F}(4), {\bf SKIP}, {\bf X}(3), {\bf A}(13), {\bf F}(4);\\
...

\item Output of two values in standard format on a new page of the
printer.

...\\
{\bf SPC} thermo\_print {\bf DATION OUT ALPHIC};\\
{\bf DCL} printer {\bf DATION OUT ALPHIC DIM}($^*$,50,120) {\bf FORWARD}\\
\x {\bf GLOBAL CREATED} (thermo\_print);\\
{\bf DCL} a {\bf FIXED}(15), x {\bf FLOAT}(31);\\
...\\
a := 5;\\
x := 2.33;\\
...\\
{\bf PUT TO} printer {\bf BY PAGE};\\
{\bf PUT} a, x {\bf TO} printer {\bf BY LIST};

The execution results in the following printer layout:

\begin{verbatim}
_____5___2.33000E+00
\end{verbatim}
\item Let data be stored in an input file on floppy disk in the
following form:

\begin{tabular}{l@{:}l}
column  1 -- 10 & article identifier (CHARACTER)\\
column 12 -- 20 & quantity (FIXED)\\
column 22 -- 30 & price per unit right-justified (e.g., \_\_\_124.57)
\end{tabular}

They are to be read into the variables article\_id, quantity, price:

...\\
{\bf SPC} floppy\_disk {\bf DATION INOUT ALL};\\
{\bf DCL} input\_file {\bf DATION IN ALPHIC DIM}($^*$,80) {\bf TFU FORWARD}\\
\x \x {\bf GLOBAL CREATED} (floppy\_disk),\\
\x article\_id {\bf CHAR}(10),\\
\x quantity {\bf FIXED},\\
\x price {\bf FLOAT};\\
...\\
{\bf GET} article\_id, quantity, price {\bf FROM} input\_file {\bf BY}\\
\x {\bf A}(10), {\bf X}, {\bf F}(9), {\bf X}, {\bf E}(9), {\bf SKIP};
\end{enumerate}

The general forms of the get and put statements read:

GetStatement ::=\\
\x {\bf GET} [ \{ Name$\S $Variable $\mid$ Segment \} [ , \{ Name$\S $Variable $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} FormatPosition [ , FormatPosition ] $^{...}$ ] ;

PutStatement ::=\\
\x {\bf PUT} [ \{ Expression $\mid$ Segment \} [ , \{ Expression $\mid$ Segment \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} FormatPosition [ , FormatPosition ] $^{...}$ ] ;

FormatPosition ::=\\
\x [ Factor ] \{ Format $\mid$ Position \} $\mid$\\
\x Factor ( FormatPosition [ , FormatPosition ] $^{...}$ )

Factor ::=\\
\x ( Expression$\S $IntegerGreaterZero ) $\mid$ IntegerWithoutPrecision$\S $GreaterZero

Format ::=\\
\x FixedFormat $\mid$ FloatFormat $\mid$ CharacterStringFormats $\mid$ BitFormat $\mid$\\
\x TimeFormat $\mid$ DurationFormat $\mid$ ListFormat $\mid$ R-Format $\mid$ {\bf RST} (Name)

Upon input with the get statement, the addressed data elements are
read one after the other and correspondingly assigned to the variables
in the variable list (analogously to the read statement). The
assignment to the variables takes place according to the general
assignment rules.

The input is terminated, when the the variable list is worked off. If
there still are list elements, but no data elements, an error message is
displayed.

When executing the put statement, the values of the expressions
following PUT in the list are written out in the given order.

In the order of notation, a format in the format position list is
associated with each variable in the variable list of the get
statement, describing the external representation of the data on the
named data station and used for converting into computer internal
representation. The kind of format is determined by the type of the
variable. Besides formats, the list of the format positions can also
contain position statements (cf. 10.4) for positioning in the data
station. If the variable list is not exhausted, yet, the further
positionings are executed and the just mentioned association is
continued with the next following format. If, on the contrary, the
variable list is already exhausted, the following position attributes
are elaborated, until a format is encountered or the list is worked off.

If the variable list contains an array or a segment, the following
formats are associated with the array elements one after the other.

The number of the transmitted data elements is only determined by the
variable list, not by the format position list. If there are more
formats than variables, the surplus formats are neglected. If there are
still variables left, when the format position list is worked off, it is
re-started with the first element of the format position list. In each
case, the transmission is terminated, when the variable list is
exhausted.

The above analogously holds for the put statement with ``variable''
replaced by ``expression''.

The data station must possess the class attribute ALPHIC, a structure,
and an access attribute. The selection of the access attribute possibly
limits the positioning possibilities (cf. 10.4).

The format position list consists of format and position statements.
To simplify notation, repetition factors may be used in the list. For
instance, the format position list

X(2), F(12,3), X(2), F(12,3), X(2), F(12,3)

can be written in an easier way:

(3) (X(2), F(12,3))

The following table shows the permitted associations between formats and
types of the data elements to be transferred:

\begin{tabular}{ll}
format                  & data type \\ \hline
fixed format            & FIXED, FLOAT \\
float format            & FIXED, FLOAT \\
bit format              & BIT          \\
character string format & CHARACTER    \\
time format             & CLOCK        \\
duration format         & DURATION     \\
list format             & all given data types
\end{tabular}

In detail, the formats have the following forms and meanings (the
position statements were explained in 10.4).

\subsection{The Fixed Format (F)}   % 10.5.1

FixedFormat ::=\\
\x {\bf F} (FieldWidth [ , DecimalPositions [ , ScaleFactor ] ] )

FieldWidth ::=\\
\x Expression$\S $WithPositiveIntegerAsValue

DecimalPositions ::=\\
\x Expression$\S $WithNonNegativeIntegerAsValue

ScaleFactor ::=\\
\x Expression$\S $WithIntegerAsValue

The fixed format describes the external representation of decimal fixed
point numbers. The field width w is the complete number of characters
available for the decimal number; decimal positions d denote the number
of digits behind the decimal point. The scale factor p can be both
positive or negative; it causes that not the number itself, but its
value multiplied by 10$^{**}$p is transferred.

It is important that only integers can be transferred with the fixed
format, but also the processing of fractional fixed point numbers is
possible by scaling. These are converted to integers upon input and to
fractional numbers again upon output.

\begin{enumerate}
\item {\bf Output}
\begin{enumerate}
\item The decimal number is stored right-justified in a field of length
w in the form

[ - ] pi [ . pi ]

where pi means positive integer. If the number does not occupy the
entire field, the left part is padded with spaces.
\item If 0 $>$ d or w $<$ d, the character $^*$ is stored w times.
\item In case w $\leq$ 0, no character is stored; an error is reported.
\item If d = 0 or is not given, only the integer part of the decimal
number rounded without decimal point is written out.
\item Except for the zero immediately in front of the decimal point,
leading zeros are suppressed.
\end{enumerate}
\item {\bf Input}
\begin{enumerate}
\item A field of length w is read, containing a decimal fixed point
number in the following representation:

[ [ + $\mid$ - ] pi [ . [ pi ] ] ]

\item Spaces preceding or following the number are ignored.
\item If the entire field is empty, value 0 is read in.
\item If no decimal point occurs in the representation, the last d
digits are interpreted as positions following a decimal point. It must
be p $\geq$ d.
\item If a decimal point occurs in front of the last b digits in the
representation, then it has priority over the specification by d. In
this case, the statement of d has no meaning. It must be p$\geq$ b.
\item If w $\leq$ 0, no assignment takes place; an error is reported.
\end{enumerate}
\end{enumerate}

Example:

\begin{tabular}{lll}
value  & format   & output \\ \hline
13.5   & F(7,2)   & \_\_13.50  \\
275.2  & F(4,1)   & $^{****}$ \x \x error message! \\
22.8   & F(5)     & \_\_\_23 \\
212.73 & F(9,2,2) & \_21273.00 \\
212.73 & F(9,2)   & \_\_\_212.73
\end{tabular}

\subsection{The Float Format (E)}   % 10.5.2

FloatFormat ::=\\
\x {\bf E} (FieldWidth [ , DecimalPositions [ , Significance ] ] )

Significance ::= \\
\x Expression$\S $WithIntegerAsValue

The float format describes the external representation of decimal
floating point numbers of the form

[ + $\mid$ - ] FloatingPointNumber

where the exponent consists of two digits. Field width and decimal
positions have the same meaning as in the fixed format; significance s
denotes the number of significant digits; i.e., the length of the
mantissa.

E(w,d) is of equivalent to E(w,d,d+1), and E(w) to E(w,0).

\begin{enumerate}
\item {\bf Output}\\
The floating point number is stored right-justified in a field of length
w. Otherwise, 1(a) in 10.5.1 holds.

If 0 $<$ w $<$ d, an error reaction takes place.

In case 0 $<$ w $>$ d $>$ s, the mantissa is chosen so that it holds:

\hspace*{1cm}$10^{s-d-1} \leq \mid$ mantissa $\mid < 10^{s-d}$

For w = 0, no character is stored; the respective expression in the
expression list is skipped.

If d $>$ 0, the number has the form

\hspace*{1cm}[ - ] s-d digits . d digits E \{ + $\mid$ - \} exponent.

The exponent is determined in such a way that the leading digit of the
mantissa does not equal zero, if the number is different from zero.

If d = 0, the number has the form

\hspace*{1cm}[ - ] s digits E \{ + $\mid$ - \} exponent

If w is too small to mention a digit of the mantissa, the character $^*$
is written out w times, followed by an error reaction.
\item {\bf Input}\\
A field of length w is read, containing a decimal floating point number
in one of the possible representations (cf. 5.3).

The statements 2(b) to 2(f) in 10.5.1 hold analogously.
\end{enumerate}

\begin{tabular}{lll}
value  & format    & output \\ \hline
-0.07  & E(9,1)    & \_-7.0E-02 \\
2713.5 & E(11,2,4) & \_\_27.13E+02 \\
2721   & E(8)      & \_\_\_2E+03
\end{tabular}

\subsection{The Character String Formats (A) and (S)}  % 10.5.3

CharacterStringFormat ::=\\
\x {\bf A} [ (Expression$\S $NumberCharacters) ] $\mid$ {\bf S} (Name$\S $NumberCharactersVariableFixed)

The character formats describe the external representation of character
strings (character quantities) of the form

Character$^{...}$

\subsubsection{Character String Format (A)}

The value of the expression in character string format means the total
number w of the character positions available for the representation.
\begin{enumerate}
\item {\bf Output}\\
If the format has form ``A (Expression)'', the character string is
written out left-justified in the above presented form in a field of
length w. If the character string consists of more than w characters, it
is truncated on the right; if it consists of less than w characters, the
field is padded with spaces on the right. If w = 0, no characters are
written out, and the expression in the expression list of the put
statement is skipped.

If the expression is not given in the format, i.e., the format has the
form ``A'', the string is written out in a field, whose length equals
the string length.
\item {\bf Input}\\
Characters up to the maximum of w or until encountering the next record
delimiter (e.g., CR) are read in. A record delimiter is not transferred
into the character string variable.

If w is smaller than length lg of the associated character string
variable, the right part is padded with spaces; in case w $>$ lg, the
right part is truncated. If w = 0, a string of lg spaces is assigned to
the variable.
\end{enumerate}

Examples:

The output of the character string 'PEARL' in format

\begin{itemize}
\item A    results in PEARL 
\item A(5) results in PEARL 
\item A(7) results in PEARL\_\_ 
\item A(2) results in PE
\end{itemize}

The input of the character string 'PEARL\_\_' to a CHAR(5) variable text in
format

\begin{itemize}
\item A is equivalent to text := 'PEARL';
\item A(5) is equivalent to text := 'PEARL';
\item A(7) is equivalent to text := 'PEARL';
\item A(2) is equivalent to text := 'PE\_\_\_';
\end{itemize}

\subsubsection{Character String Format (S)}

The variable in character string format must be of type FIXED.
\begin{enumerate}
\item {\bf Output}\\
Identical with A format: the value of the given variable determines the
width of the output field.
\item{\bf Input}\\
Characters up to the maximum lg (length of the associated character
string variables) or until encountering the next record delimiter are
read in; otherwise, the same rules like for the A format hold.
Additionally, the number of characters (without record delimiter) read
is assigned to the variable of the S format. Which record delimiters are
defined for which devices is to be found in the respective PEARL user
manual.
\end{enumerate}

Example:

Command lines are to be read in from the terminal.

{\bf DCL} buffer {\bf CHAR}(80);\\
{\bf DCL} length {\bf FIXED};\\
...\\
{\bf GET} buffer {\bf FROM} terminal {\bf BY S}(length);\\
...

After the entry ``abc$<$RETURN$>$'' on the keyboard (the key
$<$RETURN$>$ creates a record delimiter), the variable ``buffer''
contains the characters ``abc'' and the variable ``length'' the value 3.

\subsection{The Bit Format (B)}    % 10.5.4

BitFormat ::=\\
\x \{ {\bf B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4} \} [ ( Expression$\S $NumberCharacters) ]

The bit format describes the external representation of bit strings (bit
quantities), namely (cf. 5.4)
\begin{itemize}
\item in binary form by the format: \{ B $\mid$ B1 \} [ ( Expression ) ] ,
\item in form of tetrades by the format: B2 [ ( Expression ) ] ,
\item in form of octades by the format: B3 [ ( Expression ) ] ,
\item in hexadecimal form by the format: B4 [ ( Expression ) ] .
\end{itemize}

The value of the expression in bit format means the total number w of
the character positions available for the representation.
\begin{enumerate}
\item {\bf Output}\\
If the expression is declared in the format, the bit string is written
out left-justified in the above represented form in a field of length
w. If the bit string consists of more than w characters, it is truncated
on the right; if it consists of less than w characters, the field is
padded with zeros on the right. If w is not given, and if the bit format
thus has the form B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4, the string
is written out in a field, whose length equals the length of the
string.
\item {\bf Input}\\
The expression must be given.

A field of length w is read in, which must contain a bit string of the
above described form. The field must not exclusively consist of spaces.
Spaces preceding or following the string are ignored. The statements on
the input with the A format hold likewise.
\end{enumerate}

Example:

The output of the bit string '0101110' in the format

\begin{itemize}
\item B(5) results in 01011 
\item B2(3) results in 113 
\item B3(3) results in 270 
\item B4(2) results in 5C
\end{itemize}

Let the variable bit string be of type BIT(8); the input, there are the
following possibilities:

\begin{tabular}{lll}
data element to be entered & format & value of bit string \\ \hline
11111                      & B(5)   &         11111000    \\
201                        & B2(3)  &         10000100    \\
235                        & B3(3)  &         01001110    \\
AB                         & B4(2)  &         10101011
\end{tabular}

\subsection{The Time Format (T)}   % 10.5.5

TimeFormat ::= \\
\x {\bf T} ( FieldWidth [ , DecimalPosition ] )

The time format describes the external representation of time data. The
field width means the total number w of the character positions
available for the representation; decimal positions stands for the
number d of the digits for the fractional parts of seconds of the clock
time.
\begin{enumerate}
\item {\bf Output}\\
The time is written out rigth-justified in a field of length w in the
form

[ Digit ] Digit : Digit Digit : Digit Digit [ . pi ]

If the first digit is zero, it is replaced by spaces. In case d = 0,
decimal point and fractional parts of seconds are not written out.

If the output value does not occupy the entire field, the left part is
padded up with spaces.
\item {\bf Input}\\
A field of length w is read in, which must contain a time in a permitted
representation (see 1). Preceding and following spaces are ignored.
\end{enumerate}

Examples:

\begin{tabular}{lll}
value               & format  & output \\ \hline
12.30 hours 5.2 sec & T(12,1) & \_\_12:30:05.2 \\
8 hours             & T(8)    & \_8:00:00
\end{tabular}

\subsection{The Duration Format (D)}   % 10.5.6

DurationFormat ::=\\
\x {\bf D} ( FieldWidth [ , DecimalPosition ] )

The duration format describes the external representation of durations.
The value of the field width means the total number w of the character
positions available for representation, the value of decimal positions
means the number d of the digits for the fractional parts of seconds of
the duration.
\begin{enumerate}
\item {\bf Output}\\
The duration is written out right-justified in a field of length w in
the form

[ Digit ] Digit\_HRS\_Digit Digit\_MIN\_Digit Digit [ . pi ]\_SEC

The rules from 10.5.5 (1) are valid.
\item {\bf Input}\\
A field of length w is read in, which must contain a duration in a
permitted representation (see 1). Preceding and following spaces are
ignored.
\end{enumerate}

Examples:

\begin{tabular}{lll}
value               & format  & output \\ \hline
11 hours 15 minutes & D(20)   & 11\_HRS\_15\_MIN\_00\_SEC \\
100 milliseconds    & D(24,3) & \_0\_HRS\_00\_MIN\_00.100\_SEC
\end{tabular}

The character \_ means a space.

\subsection{The List Format (LIST)}    % 10.5.7

ListFormat ::=\\
\x {\bf LIST}

The list format serves for the input/output of fixed, float, bit, char,
clock, and dur quantities.
\begin{enumerate}
\item {\bf Output}\\
Subsequent output data are separated by two spaces, each. The data are
written out in such a way, as if for a quantity of type

\begin{tabular}{lll}
CHAR(k)  & format & A(k)\\
BIT(k)   & format & B(k)\\
FIXED(k) & format & F(n)\\
FLOAT(k) & format & E(m,m-7,m-6)\\
CLOCK    & format & T(8)\\
DUR      & format & D(20)
\end{tabular}

with n = ENTIER(k/3.32) + 2, m = ENTIER (k/3.32) + 3 were
declared.
\item {\bf Input}\\
The input data can have any form permitted for the representation of
constants. They are separated by a comma or at least two spaces. If no
constant is between two commas, the corresponding element of the
variable list remains unchanged.
\end{enumerate}

Examples:

\begin{tabular}{llll}
data type & value    & implicit format & output \\ \hline
FIXED(15) & 127      & F(6)            & \_\_\_127 \\
FLOAT(31) & 3.28E+28 & E(12,5,6)       & \_3.28000E+28\\
BIT(8)    & 'EF'B4   & B(8)            & 11101111
\end{tabular}

\subsection{The R Format (R)}   % 10.5.8

Sometimes, the same format position lists are used in more than one get
or put statement. The R format serves to describe these lists only
once. For this, a list with the so-called format declaration is
introduced.

FormatDeclaration ::=\\
\x Identifier : {\bf FORMAT} ( FormatPosition [ , FormatPosition ] $^{...}$ ) ;

Example:

Ftab : {\bf FORMAT} ( {\bf X}(2), {\bf F}(8,3), (3) ( {\bf X}(2), {\bf E}(10,3) ) ) ;

A format declared in such a way can be used in a get or put statement,
stating its identifier:

R-Format ::=\\
\x {\bf R} ( Identifier$\S $Format )

When transmitting data, the R format is replaced by the format position
list contained in the indicated format declaration.

Example:

{\bf PUT} a, x, y, z {\bf TO} printer {\bf BY }(Ftab) ;

The format position list in the format declaration must not contain any
R format referring directly or indirectly (via another format
declaration) to its own format declaration.

\section{The Convert Statement (CONVERT)}   % 10.6

The comfortable conversion of number values in character strings and
vice versa is very important for many applications, e.g., for the
creation of display masks or for data exchange via communication
interfaces which cannot transfer binary data. The PUT and GET
statements enable that in connection with data stations. Following
that, the CONVERT statement is defined, performing formatted data
exchange with a character string or character string variable,
respectively, instead of a data station.

The general forms of the convert statement are:

ConvertToStatement ::=\\
\x {\bf CONVERT} Expression [ , Expression ] $^{...}$ {\bf TO} Name$\S $CharacterString\\
\x [ {\bf BY} FormatPositionConvert [ FormatPositionConvert ] $^{...}$ ] ;

ConvertFromStatement ::=\\
\x {\bf CONVERT} Name$\S $Variable [ , Name$\S $Variable ] $^{...}$ {\bf FROM}\\
Expression$\S $CharacterString\\
\x [ {\bf BY} FormatPositionConvert [ , FormatPositionConvert ] $^{...}$ ] ;

FormatPositionConvert ::=\\
\x [ Factor ] \{ Format $\mid$ PositionConvert \} $\mid$\\
\x Factor ( FormatPositionConvert [ , FormatPositionConvert ] $^{...}$ )

PositionConvert ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED ) $\mid$ {\bf X} ( Expression ) $\mid$ {\bf ADV} ( Expression ) $\mid$\\
\x {\bf POS} ( Expression ) $\mid$ {\bf SOP} ( Name$\S $PositionVariable-FIXED )

All permitted formats have the same meaning as for the PUT and GET
statements. The only exception is the S format. In the convert
statement, the number of characters, which at this point in time was
read from Expression$\S $CharacterString or written into
Name$\S $CharacterString, respectively, is assigned to the variable in S
format.

Example:

\begin{tabbing}
{\bf DCL} (index, conv\_error, number\_of\_bytes) \= {\bf FIXED},\\
\x        value                                   \> {\bf FLOAT};\\
\end{tabbing}

{\bf DCL} string\_out {\bf CHAR}(40),\\
\x string\_in {\bf CHAR}(20);\\
...\\
{\bf CONVERT} 'Index =', index {\bf TO} string\_out {\bf BY A}, {\bf F}(4), {\bf S}(number\_of\_bytes);\\
{\bf CONVERT} index, value {\bf FROM} string\_in {\bf BY RST}(conv\_error), {\bf F}(4), {\bf E}(10,2);

\section{The Take and Send Statements}    % 10.7

The take statement serves for the input, the send statement for the
output of data. These statements are provided for the transmission of
process data, and for the data exchange with user specific drivers,
respectively. The data station must possess the class attribute BASIC.

TakeStatement ::=\\
\x {\bf TAKE} [ Name$\S $Variable ] {\bf FROM} Name$\S $Dation\\
\x \x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;

SendStatement ::=\\
\x {\bf SEND} [ Expression ] {\bf TO} Name$\S $Dation\\
\x \x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;

RST-S-CTRL-Format ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf S} ( Name$\S $Variable-FIXED )\\
\x $\mid$ {\bf CONTROL} ( Expression [ , Expression [ , Expression ] ] )

The types of the ``variable'' in the take statement or the
``expression'' in the send statement, respectively, are implementation
dependent.

The attribute definitions RST, S and CONTROL may be stated in any
order, but only once, each. The meanings of the CONTROL and S formats
are implementation dependent and, thus, to be found in the respective
user manual of a PEARL implementation.

Example:

{\bf SYSTEM};\\
\x motor: DIGEA $^*$1$^*$1,4;

{\bf PROBLEM};\\
\x {\bf SPC} motor {\bf DATION OUT BASIC};\\
\x {\bf DCL} on {\bf INV BIT}(4) {\bf INIT}('1010'B1);

\x {\bf SEND} on {\bf TO} motor;

\section{Error Handling in I/O Statements (RST)}    % 10.8

Usually, errors are recognised when the execution of I/O statements lead to the
termination of the responsible task, and an error message is written
out. This standard reaction of the PEARL system is suppressed by
defining

{\bf RST} ( Name$\S $ErrorVariable-FIXED )

in the parameter list of the OPEN/CLOSE statement, or as format or
position element in the other data transmission statements,
respectively.

``Name'' must denote a variable of type FIXED, in which an error number
not equal to zero is written in the case of error. Upon error free
execution of the I/O statement, the variable is set to zero. Possible
errors and their identification are to be found in the PEARL user manual
of the respective computer system.

The RST definition can be located in any position of the format or
position list of PUT, GET, WRITE, READ and CONVERT statements; also
multiple definitions with different variables are permitted. The RST
definition does not change the error reaction before the RST element is
evaluated in the format or position list. Upon recognition of an error,
the I/O statement is immediately aborted, and the error reaction valid
at this point in time (assignment of an error number to an RST variable
or the system reaction) is carried out.

\section{Interface for Additional Drivers}   % 10.9

The diversity of --- particularly in the world of PCs --- existing I/O
controllers and devices does not allow the compiler supplier to account
for all I/O devices in the system part and create system names for them.
To be able to address special I/O devices from PEARL in spite of that
fact, a driver interface can be provided for certain operating systems,
to which the PEARL programmer himself can connect drivers. This
interface is described in the respective user manual (in the chapter
``Open Driver Interfaces'').

\chapter{Signals}   % 11

When executing certain statements, internal events, so-called signals,
can occur, leading to an interruption of the running task; such signals
may, e.g., be an overflow in course of an arithmetic operation, a
division by zero, or reaching the end of a file.

A program abortion can be avoided by enabling a corresponding error
handling upon the occurrence of a signal.

The signals needed for a program are declared in the system part, where
freely selectable user names can be assigned to them. Additionally, an
error list can be defined to limit the signal scheduling to one or
several particular error numbers.

UserNameDeclaration$\S $For-SIGNAL ::= \\
\x Identifier$\S $UserName : Identifier$\S $SIGNAL-SystemName\\
\x \x [ ( Identifier$\S $ErrorNumber [ , Identifier$\S $ErrorNumber ] $^{...}$ ) ]

The signals and their associated error numbers possible on a certain
computer are described in the respective user manual, giving their
system names and meanings.

Before signals are used, they must be specified under their user names
in the problem part at module level.

Example:

\begin{removed}
IO\_SIGNAL and ENDF are system names; c\_error\_open is a pre-defined
constant.

{\bf MODULE};\\
\x {\bf SYSTEM};\\
\x \x OPEN\_ERR : IO\_SIGNAL (c\_error\_open);\\
\x \x EOF : ENDF;\\
\x \x ...\\
\x {\bf PROBLEM};\\
\x \x {\bf SPC} ( OPEN\_ERR, EOF ) {\bf SIGNAL};\\
\x \x ... \\
{\bf MODEND};
\end{removed}
\begin{added}
FixedOverflowSignal and DationEOFSignal are system names.

{\bf MODULE};\\
\x {\bf SYSTEM};\\
\x \x overflow : FixedOverfowSignal;\\
\x \x eof : DationEOFSignal;
\x \x ...\\
\x {\bf PROBLEM};\\
\x \x {\bf SPC} ( overflow,eof ) {\bf SIGNAL};\\
\x \x ... \\
{\bf MODEND};
\end{added}

The general form of the specification of signals reads:

SIGNAL-Specification ::=\\
\x \{ {\bf SPECIFY  $\mid$  SPC} \} Identifier\_or\_IdentifierList 
{\bf SIGNAL} [ GlobalAttribute ] ;

The reaction planned for the occurrence of a signal is scheduled with
the following statement:

\begin{removed}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal \{ [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction $\mid$ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) \};

SignalReaction ::=\\
\x UnlabeledStatement
\end{removed}
\begin{added}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction ;

SignalFinalStatement ::= \\
\x ReturnStatement $\mid$ \\
\x GoToStatement $\mid$ \\
\x InduceStatement $\mid$ \\
\x {\bf TERMINATE} ;

SignalReaction ::=\\
\x SignalFinalStatement $\mid$ \\
\x Block$\S $terminatedWithSignalFinalStatement ;
\end{added}

Instead of UnlabeledStatement, all Statements besides the
Statement SchedulingSignalReaction are permitted, particularly
\removedtext{blocks or procedure calls}\addedtext{blocks,  which  end with a
SignalFinalStatement}.

The statement SchedulingSignalReaction is not permitted within BEGIN
and REPEAT blocks, or as SignalReaction.

\begin{itemize}
\item Validity range of scheduling a signal reaction:\\
The validity range of scheduling a signal reaction reaches from the
execution of the corresponding ON statement to the end of the
scheduling task or procedure, respectively.\\
If another scheduling for the same signal (e.g., in a procedure called
by the scheduling task) is run, it hides the preceding scheduling until
the end of the validity range of the new schedule (in the example until
the end of the scheduling procedure).
\item Leaving a procedure (task) after the execution of a signal
reaction:\\
If a signal occurs within the validity range of scheduling a signal
reaction, the procedure (task) in which the signal reaction is scheduled
is left by \removedtext{an implicit RETURN(TERMINATE)} \addedtext{the explicit INDUCE, RETURN or TERMINATE} after having executed the 
corresponding signal reaction, unless the signal reaction is left by a 
GOTO statement.
\item Validitiy of signal schedulings during the execution of a signal
reaction:\\
If a signal reaction is scheduled at procedure level, only those ON
schedulings are valid during the execution of this signal reaction which
were already executed before calling this procedure.\\
If the signal reaction is scheduled at task level, no ON schedulings are
valid during the execution of this signal reaction.
\item Validity of signal schedulings after leaving a signal reaction by
GOTO:\\
If the execution of a signal reaction scheduled at procedure or task
level is left by GOTO, the signal schedulings which were already
executed before triggering the signal, particularly those of the
triggered signal, are valid again.
\end{itemize}

To test the reaction scheduled for a signal, the occurrence of a signal
can be simulated analogously to the occurrence of an interrupt:

\begin{removed}
InduceStatement ::=\\
\x {\bf INDUCE} Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber ) ];
\end{removed}
\begin{added}
InduceStatement ::=\\
\x {\bf INDUCE} [ Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber ) ] ] ;

The variant of the {\bf INDUCE} statement without a specified signal is 
only allowed inside a signal reaction. This will trigger the signal handler
of the superior function or task with the identical signal.
\end{added}


Whereas it is possible to react to asynchronous exception situations
(i.e., influences effecting from outside) by interrupts, the signal
treatment serves exclusively for reacting to synchronous error states
(i.e., cause and treatment of the error state originate from the same
task).

Example:

The procedure Analysis shall sequentially analyse a logbook created
in the course of a day; the single data elements of the LogBook are of
type Event.

...\\
{\bf PROBLEM};\\
\x {\bf SPC} \removedtext{EOF} \addedtext{eof} {\bf SIGNAL},\\
\x \x Tape {\bf DATION INOUT ALL};\\
\x {\bf TYPE} Event ...;\\
\x {\bf DCL} LogBook {\bf DATION IN} event {\bf DIM}($^*$) {\bf FORWARD CREATED}(tape);

Analysis: {\bf PROC};\\
\x {\bf DCL} Input Event;\\
\x ...\\
\x {\bf OPEN} LogBook;\\
\x {\bf ON} \removedtext{EOF}\addedtext{eof}:\\
\x \x {\bf BEGIN}\\
\x \x \x {\bf CLOSE} LogBook;\\
\x \x {\bf END}; ! ON \removedtext{EOF}\addedtext{eof}\\
\x ...\\
\x {\bf REPEAT}\\
\x \x {\bf READ} Input {\bf FROM} LogBook;\\
\x \x ...\\
\x {\bf END};\\
\x {\bf END}; ! Analysis

For testing, the statement

{\bf INDUCE} \removedtext{EOF}\addedtext{eof};

could be executed sporadically instead of the read statement.

If a signal is induced, whether by an error state or an induce
statement, and no signal reaction is scheduled for it, the system
reaction is triggered (i.e., generally an error message of the run time
system and termination of the causing task).

By stating a variable after RST in the signal scheduling, the programmer
gets access to the error number (error cause). In this case, the signal
SignalName can be induced for the error with the number ErrorNumber by

{\bf INDUCE} SignalName {\bf RST} ( ErrorNumber ) ;

Example:

The signal TaskSignal shall be simulated with the error number
``1010'', and the causing task shall react by writing out the error
number on the console:

{\bf PROBLEM};\\
\x {\bf SPC} TaskSignal {\bf SIGNAL};\\
\x {\bf DCL} ErrorNummer {\bf FIXED};

Regulator: {\bf TASK PRIO} 20;\\
\x {\bf ON} TaskSignal {\bf RST} (ErrorNumber):\\
\x \x {\bf PUT} ErrorNumber {\bf TO} Console;\\
\x \x ...\\
\x Test;\\
\x \x ...\\
\x {\bf END}; ! Regulator

Start: {\bf TASK MAIN};\\
\x {\bf ALL} Ta {\bf ACTIVATE} Regulator;\\   % ??? Ta ???
\x {\bf END}; ! Start

Test: {\bf PROC};\\
\x {\bf INDUCE} TaskSignal {\bf RST} (1010);\\
\x ...\\
\x {\bf END}; ! Test


\chapter{Appendix}

\section{Data Types and their usability}    % A1

The following overview shows for each of the available data types, whether
objects of this type may

\begin{itemize}
\item be summarised to arrays,
\item occur as structure components,
\item be formal procedure parameters,
\item be results of a function procedure,
\item be values of a reference variable,
\item be transmitted to or from data stations,
\item be provided with allocation protection,
\item be global, or
\item be provided with the initialisation attribute.
\end{itemize}

\begin{table}[htb]
\begin{tabular}{lccccccccc}
{\bf type}     & \multicolumn{9}{c}{{\bf usage}} \\ 
               & array & struct. & para- & result & ref.  & dation & INV & GLOBAL & INIT \\ 
               &       &         & meter & type   & value & class  &     &        &      \\ \hline
FIXED          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
FLOAT          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
BIT            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CHAR           & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
CLOCK          & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
DUR            & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
SEMA           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
BOLT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
IRPT           & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
SIGNAL         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
DATION         & x     &  --     & x     &  --    &  x    &   --   &  -- &    x   &  --  \\
array          & --    &  x      & x     &  --    &  x    &   --   &  x  &    x   &  x   \\
STRUCT         & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
new type       & x     &  x      & x     &  x     &  x    &   x    &  x  &    x   &  x   \\
REF            & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
procedure      & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
TASK           & --    &  --     & --    &  --    &  x    &   --   &  -- &    x   &  --  \\
FORMAT         & --    &  --     & --    &  --    &  --   &   --   &  -- &    --  &  --  \\
REF CHAR ( )   & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF PROC       & x     &  x      & x     &  --    &  --   &   --   &  x  &    x   &  x   \\
REF TASK       & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
REF STRUCT [ ] & x     &  x      & x     &  x     &  --   &   --   &  x  &    x   &  x   \\
\end{tabular}
\end{table}
                                                                                 
Objects of type SEMA, BOLT, IRPT, SIGNAL, DATION or array may only be 
passed on by means of identification (IDENT) as procedure parameters.

\newpage
\section{Predefined Functions}   % A 2

This appendix describes the functions known to the PEARL compiler. They
can be used in the single modules without specifying them before. If one
of the functions is specified in a module, no object may exist with the
functions' name at module level.

\begin{tobedone}
\subsection{The Function NOW}    % A 2.1

The function procedure NOW passes back the actual time or system time, resp., 
as value of type CLOCK. A specification of the function looks like this:\\

{\bf SPC} NOW {\bf PROC RETURNS ( CLOCK ) GLOBAL} ; 


\subsection{The Function DATE}    % A 2.2

The actual date can be received by invoking the function procedure DATE.
The function result is a character string constant of length 10, containing
the date in the form ``year--month--day''. Here an example for December 5,
1991: ``1991--12-05''. The function can be specified like this:\\

{\bf SPC} DATE {\bf PROC RETURNS ( CHAR(10) ) GLOBAL} ;
\end{tobedone}

\newpage
\section{Syntax}    % A 3

Following meta characters are used in the syntax description:\\ 

\begin{tabular}{ll}
meta character & meaning \\ \hline
::=            & introduction of a Name (nonterminal symbol) for a language form\\
$[\ ]$         & bracketing of optional parts of a language form \\ 
$\mid$         & separation of alternative parts of a language form\\
\{ \}          & putting together several elements to a new element\\
$^{...}$       & one or multiple repetition of the preceding element\\
               & (or of several elements bracketed by \{ \} or [ ] ) \\
$\S $          & separates an explaining comment from a language form Name\\
$/^*$ $^*/$    & comment brackets: 
                 includes an explaining text, possibly explaining the\\
               & language form in detail instead of a formal description\\
\end{tabular}

All other elements occurring in the syntax rules are either Names of language
forms or terminal symbols. Examples for terminal symbols are the PEARL
keywords (printed boldly) or the characters semicolon ``;'', opening round
bracket ``('' and closing round bracket ``)'', 
% Klammer auf und zu ???
or the apostrophe `` ' ''; the terminal symbols opening square bracket ``[''
and closing square bracket ``]'' are printed boldly to distinguish them
from the meta symbols for optional parts. Attention: the round brackets are
no meta characters and have thus no grouping effect!\\

The symbol PEARL-Program is the initial symbol of the following syntax
description.

\subsection{Program}    % A 3.1

PEARL-Program ::=\\
\x Module $^{...}$\\

Module ::=\\
\x {\bf MODULE} [ [ ( ] Identifier$\S $OfTheModule [ ) ] ] ;\\
\x \{ SystemPart [ ProblemPart ] $\mid$ ProblemPart \} \\
\x {\bf MODEND} ;

\subsection{System Part}   % A 3.2

SystemPart ::= \\
\x {\bf SYSTEM} ;\\
\x \x [ UserNameDeclaration$\S $ForDationInterruptOrSignal ] $^{...}$\\

UserNameDeclaration ::=\\
\x Identifier$\S $UserName: Identifier$\S $SystemName [ ( nngz$\S $Index ) ]\\
\x \x [ $^*$ nngz$\S $Channel [ $^*$ nngz$\S $Position [ , nngz$\S $Width ] ] ];\\
\x $\mid$ Identifier$\S $UserName: Identifier$\S $SIGNAL-SystemName\\
\x \x [ ( Identifier$\S $ErrorNumber [ , Identifier$\S $ErrorNumber ] $^{...}$ ) ] ;\\

nngz ::= \\
\x IntegerWithoutPrecision$\S $NonNegative

\subsection{Basic Elements}    % A 3.3 

Digit ::=\\
\x 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9\\

Letter ::= \\
A $\mid$ B $\mid$ C $\mid$ ... $\mid$ Z $\mid$ a $\mid$ b $\mid$ c $\mid$ ... $\mid$ z\\

Identifier ::=\\
Letter [ Letter $\mid$ Digit $\mid$ \_ ] $^{...}$\\

\begin{tabbing}
\x $\mid$ \= BitStringConstant \= $\mid$ \= \kill
Constant ::= \> \> \> \\
          \> Integer           \> $\mid$ \> FloatingPointNumber\\
\x $\mid$ \> BitStringConstant \> $\mid$ \> CharacterStringConstant\\
\x $\mid$ \> TimeConstant      \> $\mid$ \> DurationConstant\\
\x $\mid$ \> {\bf NIL}         \> \> 
\end{tabbing}

Integer ::=\\
\x IntegerWithoutPrecision [ ( Precision ) ]\\

IntegerWithoutPrecision ::=\\
\x Digit $^{...}$ $\mid$ \{ 0 $\mid$ 1 \} $^{...}$ {\bf B}\\

Precision ::=\\
\x IntegerWithoutPrecision\\

FloatingPointNumber ::=\\
\x FloatingPointNumberWithoutPrecision [ ( Precision ) ]\\

FloatingPointNumberWithoutPrecision ::=\\
\x \{ Digit $^{...}$ . [ Digit $^{...}$ ] $\mid$ . Digit $^{...}$ \} [ Exponent ]\\
\x $\mid$ Digit $^{...}$ Exponent\\

Exponent ::=\\
E [ + $\mid$ - ] Digit $^{...}$\\

BitStringConstant ::=\\
\x ' B1-Digit $^{...}$ ' \{ {\bf B} $\mid$ {\bf B}1 \} $\mid$ ' B2-Digit $^{...}$ ' {\bf B}2 $\mid$ ' B3-Digit $^{...}$ ' {\bf B}3 $\mid$ ' B4-Digit$^{...}$ ' {\bf B4}\\

B1-Digit ::= 0 $\mid$ 1\\

B2-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3\\

B3-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7\\

B4-Digit ::= 0 $\mid$ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 $\mid$ 8 $\mid$ 9 $\mid$ A $\mid$ B $\mid$ C $\mid$ D $\mid$ E $\mid$ F\\

CharacterStringConstant ::=\\
\x ' \{ CharacterBesidesApostrophe $\mid$ '' $\mid$ ControlCharacterSequence \} $^{...}$ '\\

CharacterBesidesApostrophe ::=\\
\x Digit $\mid$ Letter $\mid$ \x $\mid$ \_ $\mid$ + $\mid$ - $\mid$ $^*$ $\mid$ / $\mid$ $\backslash$ $\mid$ ( $\mid$ ) $\mid$ {\bf [} $\mid$ {\bf ]} $\mid$ : $\mid$ . $\mid$ ; $\mid$ , $\mid$ = $\mid$ $<$ $\mid$ $>$ $\mid$ !\\
\x $\mid$ $/^*$ more printable characters of the machine character set $*/$ \\

ControlCharacterSequence ::= \\
\x '$\backslash$ \{ B4-Digit B4-Digit \} $^{...}$ $\backslash$'\\

TimeConstant ::=\\
\x Digit $^{...}$ : Digit $^{...}$ : Digit $^{...}$ [ . Digit $^{...}$ ] \\

DurationConstant ::=\\
\x Hours [ Minutes ] [ Seconds ]\\
\x $\mid$ Minutes [ Seconds ]\\
\x $\mid$ Seconds\\

Hours ::=\\
\x IntegerWithoutPrecision {\bf HRS}\\

Minutes ::=\\
\x IntegerWithoutPrecision {\bf MIN}\\

Seconds ::=\\
\x \{ IntegerWithoutPrecision $\mid$ FloatingPointNumberWithoutPrecision \} {\bf SEC}

ConstantExpression ::=\\
\{ + $\mid$ - \}  FloatingPointNumber\\
\x $\mid$ \{ + $\mid$ - \} DurationConstant\\
\x $\mid$ Constant-FIXED-Expression\\

Constant-FIXED-Expression ::=\\
\x Term [ \{ + $\mid$ - \} Term ] $^{...}$\\
        
Term ::= \\
\x Factor [ \{ $^*$ $\mid$ // $\mid$ {\bf REM} \} Factor ] $^{...}$\\

Factor ::= \\
\x [ + $\mid$ - ] \\
\x \{ Integer\\
\x \x $\mid$ ( Constant-FIXED-Expression )\\
\x \x $\mid$ {\bf TOFIXED} \{ CharacterStringConstant$\S $OfLength1 $\mid$ BitStringConstant \}\\
\x \x $\mid$ Identifier$\S $Named-FIXED-Constant\\
\x \} \\
\x [ {\bf FIT} Constant-FIXED-Expression ]

\subsection{Problem Part}   % A 3.4

ProblemPart ::=\\
\x {\bf PROBLEM}; [\{ Declaration $\mid$ Specification $\mid$ Identification \} $^{...}$ ]\\

\subsubsection{Declaration}    % A 3.4.1

Declaration ::=\\
\x LengthDefinition \\
\x $\mid$ TypeDefinition\\
\x $\mid$ VariableDeclaration\\
\x $\mid$ FormatDeclaration\\
\x $\mid$ ProcedureDeclaration\\
\x $\mid$ TaskDeclaration\\
\x $\mid$ OperatorDefinition\\
\x $\mid$ PredenceDefinition\\

LengthDefinition ::=\\
\x {\bf LENGTH} \{ {\bf FIXED $\mid$ FLOAT $\mid$ BIT $\mid$ CHARACTER $\mid$ CHAR} \} ( Precision ) ;\\

TypeDefinition ::=\\
\x {\bf TYPE} Identifier$\S $ForType \{ SimpleType $\mid$ TypeStructure \} ;\\

VariableDeclaration ::=\\
\x \{ {\bf DECLARE $\mid$ DCL} \} DeclareSentence [ , DeclareSentence ] $^{...}$ ;\\
% wie ist "Satz" hier gemeint ???

DeclareSentence ::=\\
\x OneIdentifierOrList [ DimensionAttribute ]\\
\x \{ ProblemDataAttribute $\mid$ SemaAttribute $\mid$ BoltAttribute $\mid$ DationAttribute \}\\ 

OneIdentifierOrList ::= \\
\x Identifier $\mid$ ( Identifier [ , Identifier ] $^{...}$ ) \\

DimensionAttribute ::=\\
\x ( DimensionBoundaries [ , DimensionBoundaries ] $^{...}$ )\\

DimensionBoundaries ::=\\
\x [ Constant-FIXED-Expression$\S $ForLowerBoundary : ]\\
\x Constant-FIXED-Expression$\S $ForUpperBoundary\\
        
ProblemDataAttribute ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \}\\
\x [ GlobalAttribute ] [ InitialisationAttribute ]\\

SimpleType ::=\\
\x \{ {\bf FIXED $\mid$ FLOAT $\mid$ BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\
\x \x [ ( Constant-FIXED-Expression$\S $PrecisionResp.Length ) ]\\
\x $\mid$ {\bf CLOCK}\\
\x $\mid$ \{ {\bf DUR $\mid$ DURATION} \}\\

StructuredType ::=\\
\x TypeStructure $\mid$ Identifier$\S $ForNewDefinedType\\

TypeStructure ::=\\
\x {\bf STRUCT [} StructureComponent [ , StructureComponent ] $^{...}$ {\bf ]} \\

StructureComponent ::=\\
\x OneIdentifierOrList$\S $ForStructureComponent [ DimensionAttribute ]\\
\x TypeAttributeInStructuremComponent\\

TypeAttributeInStructureComponent ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \}\\

TypeReference ::=\\
\x {\bf REF} \\
\x \{ [ VirtualDimensionList ] [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType \}\\
\x \x $\mid$ [ VirtualDimensionList ] \{ TypeDation $\mid$ {\bf SEMA $\mid$ BOLT} \}\\
\x \x $\mid$ TypeProcedure $\mid$ {\bf TASK $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL}\\
\x \x $\mid$ Type-VOID $\mid$ {\bf CHAR}( )\\
\x \}\\

VirtualDimensionList ::=\\
\x ( [ , $^{...}$ ] )\\

Type-VOID ::=\\
\x {\bf STRUCT [ ]} \x $/^*$ only allowed in combination with REF $*/$\\

SemaAttribute ::=\\
\x {\bf SEMA} [ GlobalAttribute ]\\
\x [ {\bf PRESET} ( Constant-FIXED-Expression [ , Constant-FIXED-Expression ] $^{...}$ ) ]\\

BoltAttribute ::=\\
\x {\bf BOLT} [ GlobalAttribute ]\\

GlobalAttribute ::=\\
\x {\bf GLOBAL} [ ( Indicator$\S $Module ) ]\\

InitialisationAttribute ::=\\
\x \{ {\bf INITIAL $\mid$ INIT} \} ( InitElement [ , InitElement ] $^{...}$ )\\

InitElement ::=\\
\x Constant\\
\x $\mid$ Identifier$\S $NamedConstant\\
\x $\mid$ ConstantExpression\\

DationAttribute ::=\\
\x TypeDation\\
\x [ GlobalAttribute ]\\
\x {\bf CREATED} ( Indicator$\S $UserNameForSytemDation )\\

TypeDation ::=\\
\x {\bf DATION} SourceSinkAttribute  ClassAttribute\\
\x [ Topology ] [ AccessAttribute ]\\

SourceSinkAttribute ::=\\
\x {\bf IN $\mid$ OUT $\mid$ INOUT}\\

ClassAttribute ::= \\
\x {\bf ALPHIC $\mid$ BASIC} $\mid$ TypeOfTransmissionData\\

TypeOfTransmissionData ::=\\
\x {\bf ALL} $\mid$ SimpleType $\mid$ Indicator$\S $ForRedeclaredType $\mid$ TypeStructure\\
\x $/^*$ A Structure as transfer type may not contain any reference variable $*/$\\

Topology ::=\\
\x {\bf DIM} ( \{ $^*$ $\mid$ Constant-FIXED-Expression \}\\
\x \x [ , \{ $^*$ $\mid$ Constant-FIXED-Expression \}\\
\x \x \x [ , \{ $^*$ $\mid$ Constant-FIXED-Expression \} ] ] ) [ {\bf TFU} [ {\bf MAX} ] ]\\
\x $\mid$ {\bf DIM} ( [ , [ , ] ] ) $/^*$ Virtual dimension declaration only permitted for SPC $*/$\\

AccessAttribute ::=\\
\x \{ {\bf DIRECT $\mid$ FORWARD $\mid$ FORBACK} \}\\
\x [ {\bf NOCYCL $\mid$ CYCLIC} ]\\
\x [ {\bf STREAM $\mid$ NOSTREAM} ]\\

FormatDeclaration ::= \\
\x Identifier : {\bf FORMAT} ( FormatOrPosition [ , FormatOrPosition ] $^{...}$ ) ;\\

ProcedureDeclaration ::=\\
\x Identifier : \{ {\bf PROC $\mid$ PROCEDURE} \} [ ListOfFormalParameters ] \\
\x [ ResultAttribute ] [ GlobalAttribute ] ;\\

\x \x ProcedureBody\\

\x {\bf END};\\

ProcedureBody ::=\\
\x [\{ Declaration $\mid$ Identification \} $^{...}$ ] [ Statement $^{...}$ ] \\

ListOfFormalParameters ::=\\
\x ( FormalParameter [ , FormalParameter ] $^{...}$ )\\
        
FormalParameter ::=\\
\x OneIdentifierOrList [ VirtualDimensionList ]\\
\x \x ParameterType [ {\bf IDENT $\mid$ IDENTICAL} ]\\

ParameterType ::=\\
\x [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \} $\mid$\\   
\x \x TypeRealTimeObject $\mid$ TypeDation\\

TypeRealTimeObject ::=\\   
\x {\bf SEMA $\mid$ BOLT} $\mid$ \{ {\bf INTERRUPT $\mid$ IRPT} \} $\mid$ {\bf SIGNAL}\\   

ResultAttribute ::=\\
\x {\bf RETURNS} ( ResultType )\\

ResultType ::=\\
\x SimpleType $\mid$ StructuredType $\mid$ TypeReference\\

TaskDeclaration ::=\\
\x Identifier : {\bf TASK} [ PriorityAttribute ] [ {\bf MAIN} ]\\
\x [ GlobalAttribute ]  ;\\

\x \x TaskBody\\

\x {\bf END} ;\\

TaskBody ::=\\
\x [\{ Declaration $\mid$ Identification \}$^{...}$] [Statement$^{...}$]
        
PriorityAttribute ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} Constant-FIXED-Expression$\S $GreaterZero\\

OperatorDefinition ::= \\
\x {\bf OPERATOR} OpName ( OpParameter [ , OpParameter ] ) ResultAttribute ;\\

\x \x ProcedureBody\\

\x {\bf END} ; \\

OpName ::=\\
\x Identifier $\mid + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid == \mid /= \mid <= \mid >= \mid < \mid > \mid <> \mid ><$\\

OpParameter ::=\\
\x Identifier [ VirtualDimensionList ] ParameterType [ {\bf IDENT $\mid$ IDENTICAL} ] \\

PrecedenceDefinition ::= \\
\x {\bf PRECEDENCE} OpName ( \{ 1 $\mid$ 2 $\mid$ 3 $\mid$ 4 $\mid$ 5 $\mid$ 6 $\mid$ 7 \} ) ;

\subsection{Specification and Identification}    % A 3.4.2

Specification ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY} \} SpecificationDefinition [ , SpecificationDefinition ] $^{...}$ ;\\

SpecificationDefinition ::=\\
\x OneIdentifierOrList\\
\x \{ SpecificationAttribute $\mid$ ProcedureUsageAttribute $\mid$ TaskUsageAttribute \}\\

SpecificationAttribute ::=\\
\x [ VirtualDimensionList ] \\
\x \{ [ {\bf INV} ] \{ SimpleType $\mid$ StructuredType $\mid$ TypeReference \} \\
\x \x $\mid$ {\bf SEMA $\mid$ BOLT $\mid$ INTERRUPT $\mid$ IRPT $\mid$ SIGNAL} $\mid$ TypeDation\\
\x \}\\
\x [ GlobalAttribute ]\\

ProcedureUsageAttribute ::=\\
\x \{ {\bf ENTRY} $\mid$ [ : ] {\bf PROC} \} [ ParameterListFor-SPC ] [ ResultAttribute ] \\
\x \x GlobalAttribute\\

ParameterListFor-SPC ::=\\
\x ( FormalParameterFor-SPC [ , FormalParameterFor-SPC ] $^{...}$ )\\
        
FormalParameterFor-SPC ::=\\
\x [ Identifier$\S $OnlyForDocumentation ] [ VirtualDimensionList ]\\
\x ParameterType [ {\bf IDENTICAL $\mid$ IDENT} ]\\

TypeProcedure ::=\\
\x {\bf PROC} [ ParameterListFor-SPC ] [ ResultAttribute ] $/^*$ for REF PROC $*/$\\

TaskUsageAttribute ::=\\
\x {\bf TASK} GlobalAttribute\\

Identification ::=\\
\x \{ {\bf SPC $\mid$ SPECIFY}\} Identifier [ {\bf INV} ] Type IdentificationAttribute ;\\

IdentificationAttribute ::= \\
\x {\bf IDENT} ( Name$\S $Object )\\

\subsection{Expressions}    % A 3.4.3

Expression ::=\\
\x [ MonadicOperator ] Operand [ DyadicOperator   Expression ] $^{...}$\\

MonadicOperator ::=\\
\x + $\mid$ - $\mid$ Identifier$\S $MonadicOperator\\

DyadicOperator ::=\\
\x $ + \mid - \mid ^* \mid / \mid // \mid ^{**} \mid < \mid > \mid <= \mid >= \mid == \mid /= \mid >< \mid <> \mid$\\
\x Identifier$\S $DyadicOperator\\

Operand ::= \\
\x Constant $\mid$ Name $\mid$ FunctionCall $\mid$ ConditionalExpression\\
\x $\mid$ Dereferentiation $\mid$ StringSelection $\mid$ ( Expression ) $\mid$ ( Assignment ) \\
\x $\mid$ {\bf PRIO} [ ( Name$\S $Task ) ] $\mid$ {\bf TASK} [ ( Name$\S $Task ) ] $\mid$ {\bf TRY} Name$\S $Sema\\

Name ::=\\
\x Identifier [ ( Index [ , Index ] $^{...}$ ) ] [ . Name ]\\

Index ::=\\
\x Expression$\S $WithIntegerAsValue\\

FunctionCall ::=\\
\x Identifier$\S $FunctionProcedure [ ListOfActualParameters ]\\

ListOfActualParameters ::= \\
\x ( Expression [ , Expression ] $^{...}$ )\\

ConditionalExpression ::=\\
\x {\bf IF} Expression$\S $OfType-BIT(1) {\bf THEN} Expression {\bf ELSE} Expression {\bf FIN}\\

Dereferentiation ::=\\
\x {\bf CONT} \{ Name$\S $Reference $\mid$ FunctionCall \}\\

StringSelection ::=\\
\x Name$\S $String . \{ {\bf BIT $\mid$ CHAR $\mid$ CHARACTER} \}\\ 
\x ( \{ Constant-FIXED-Expression [ : Constant-FIXED-Expression ]\\
\x \x $\mid$ Expression [ : Expression + Constant-FIXED-Expression ]\\
\x \x $\mid$ Expression [ : Expression ] \} )\\

\subsection{Statements}    % A 3.4.4

Statement ::=\\
\x [ Identifier$\S $Label : ] $^{...}$ UnlabelledStatement\\

UnlabelledStatement ::=\\
\x EmptyStatement $\mid$ Assignment $\mid$ Block $\mid$ SequentialControlStatement\\
\x $\mid$ RealTimeStatement $\mid$ ConvertStatement $\mid$ I/O-Statement\\

EmptyStatement ::=\\
\x ;\\

Assignment ::=\\
\x \{ \{ Name$\S $Variable $\mid$ Dereferentiation $\mid$ StringSelection $\mid$ 
Name$\S $Structure \}\\   
\x \{ := $\mid$ = \} \} $^{...}$ Expression ;\\

Block ::= \\
\x {\bf BEGIN}\\
\x \x [\{ Declaration $\mid$ Identification \}$^{...}$ ]\\ 
\x \x [ Statement $^{...}$ ] \\
\x {\bf END} [ Identifier$\S $Block ] ;\\

SequentialControlStatement ::=\\
\x IfStatement $\mid$ CaseStatement $\mid$ LoopStatement $\mid$ ExitStatement\\
\x $\mid$ ProcedureCall $\mid$ ReturnStatement $\mid$ GoToStatement\\

IfStatement ::=\\
\x {\bf IF} Expression$\S $OfType-BIT(1)\\
\x \x {\bf THEN} [ Statement $^{...}$ ]\\ 
\x \x [ {\bf ELSE} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseStatement ::=\\
\x StatementSelection1 $\mid$ StatementSelection2\\

CaseStatement1 ::=\\
\x {\bf CASE} Expression$\S $WithIntegerAsValue\\
\x \x \{ {\bf ALT} [ Statement $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseStatement2 ::=\\
\x {\bf CASE} CaseIndex\\
\x \x \{ {\bf ALT} ( CaseList ) [ Statement $^{...}$ ] \} $^{...}$\\
\x \x [ {\bf OUT} [ Statement $^{...}$ ] ]\\
\x {\bf FIN} ;\\

CaseIndex ::=\\
\x Expression$\S $WithValueOfType-FIXED-Or-CHAR(1)\\

CaseList ::=\\
\x IndexSection [ , IndexSection ] $^{...}$\\

IndexSection::=\\
\x Constant-FIXED-Expression [ : Constant-FIXED-Expression ]\\
\x $\mid$ CharacterStringConstant$\S $OfLength1 [ : CharacterStringConstant$\S $OfLength1 ]\\

LoopStatement ::=\\
\x [ {\bf FOR} Indicator$\S $ControlVariable ]\\
\x [ {\bf FROM} Expression$\S $InitialValue ]\\
\x [ {\bf BY} Expression$\S $StepLength ]\\
\x [ {\bf TO} Expression$\S $EndValue ]\\
\x [ {\bf WHILE} Expression$\S $Condition ]\\
\x {\bf REPEAT}\\
\x \x [\{ Declaration $\mid$ Identification \}$^{...}$ ]\\ 
\x \x [ Statement $^{...}$ ] \\
\x {\bf END} [ Identifier$\S $Loop ] ;\\
        
ExitStatement ::=\\
\x {\bf EXIT} [ Identifier$\S $BlockOrLoop ] ;\\

ProcedureCall ::= \\
\x [ {\bf CALL} ] Name$\S $SubprogramProcedure [ ListOfActualParameter ] ;\\

ReturnStatement ::= \\
\x {\bf RETURN} [ ( Expression ) ] ;\\

GoToStatement ::= \\
\x {\bf GOTO} Identifier$\S $Label ; \\

RealTimeStatement ::=\\
\x TaskControlStatement $\mid$ TaskCoordination\\
\x $\mid$ InterruptStatement $\mid$ SignalStatement\\

TaskControlStatement ::=\\
\x TaskStarting $\mid$ TaskTerminating\\             
\x $\mid$ TaskSuspending $\mid$ TaskContinuing\\   
\x $\mid$ TaskResuming $\mid$ TaskPreventing\\

TaskStarting ::=\\
\x [ StartCondition ] {\bf ACTIVATE} Name$\S $Task [ PriorityExpression ] ;\\

PriorityExpression ::=\\
\x \{ {\bf PRIORITY $\mid$ PRIO} \} Expression$\S $PositiveInteger\\

StartCondition ::=\\
\x {\bf AT} Expression$\S $Time [ Frequency ]\\
\x $\mid$ {\bf AFTER} Expression$\S $Duration [ Frequency ]\\
\x $\mid$ {\bf WHEN} Name$\S $Interrupt [ {\bf AFTER} Expression$\S $Duration ] [ Frequency ] \\
\x $\mid$ Frequency\\

Frequency ::=\\
\x {\bf ALL} Expression$\S $Duration\\
\x [ \{ {\bf UNTIL} Expression$\S $Time \} $\mid$ \{ {\bf DURING} Expression$\S $Duration \} ]\\

TaskTerminating ::=\\
\x {\bf TERMINATE} [ Name$\S $Task ] ; \\

TaskSuspending ::=\\
\x {\bf SUSPEND} [ Name$\S $Task ] ;\\

TaskContinuing ::=\\
\x [ {\bf AT} Expression$\S $Time $\mid$ {\bf AFTER} Expression$\S $Duration $\mid$ {\bf WHEN} Name$\S $Interrupt ]\\
\x {\bf CONTINUE} [ Name$\S $Task ] [ PriorityAttribute ] ;\\

TaskResuming ::=\\
\x \{ {\bf AT} Expression$\S $Time $\mid$ {\bf AFTER} Expression$\S $Duration $\mid$ {\bf WHEN} Name$\S $Interrupt \}\\
\x {\bf RESUME;}\\        

TaskPreventing ::=\\
\x {\bf PREVENT} [ Name$\S $Task ] ;\\

TaskCoordiniationStatement ::=\\
\x \{ {\bf REQUEST $\mid$ RELEASE}\} Name$\S $Sema [ , Name$\S $Sema ] $^{...}$ ;\\
\x $\mid$ \{ {\bf RESERVE $\mid$ FREE $\mid$ ENTER $\mid$ LEAVE} \} Name$\S $Bolt [ , Name$\S $Bolt ] $^{...}$ ;\\


InterruptStatement ::=\\
\x \{ {\bf ENABLE $\mid$ DISABLE $\mid$ TRIGGER} \} Name$\S $Interrupt ;\\

\begin{removed}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal \{ [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction $\mid$ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) \};\\

SignalReaction::= UnlabeledStatement\\

InduceStatement ::=\\
\x {\bf INDUCE} Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber-FIXED ) ] ;\\
\end{removed}
\begin{added}
SchedulingSignalReaction ::=\\
\x {\bf ON} Name$\S $Signal [ {\bf RST} ( Name$\S $ErrorVariable-FIXED ) ] :\\
\x \x SignalReaction ;

SignalFinalStatement ::= \\
\x ReturnStatement $\mid$ \\
\x GoToStatement $\mid$ \\
\x InduceStatement $\mid$ \\
\x {\bf TERMINATE} ;

SignalReaction ::=\\
\x SignalFinalStatement $\mid$ \\
\x Block$\S $terminatedWithSignalFinalStatement ;

InduceStatement ::=\\
\x {\bf INDUCE} [ Name$\S $Signal [ {\bf RST} ( Expression$\S $ErrorNumber-FIXED ) ] ] ;\\
\end{added}

ConvertStatement ::=\\
\x ConvertToStatement $\mid$ ConvertFromStatement\\

ConvertToStatement ::= \\
\x {\bf CONVERT} Expression [ , Expression ] $^{...}$ {\bf TO} Name$\S $CharacterStringVariable\\
\x [ {\bf BY} FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ ] ;\\

ConvertFromStatement ::=\\
\x {\bf CONVERT} Name$\S $Variable [ , Name$\S $Variable ] $^{...}$ {\bf FROM} Expression$\S $CharacterString\\
\x [ {\bf BY} FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ ] ;\\

FormatOrPositionConvert ::= \\
\x [ Factor ] \{ Format $\mid$ PositionConvert \}\\
\x $\mid$ Factor ( FormatOrPositionConvert [ , FormatOrPositionConvert ] $^{...}$ )\\

PositionConvert ::= \\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf X} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( Expression )\\
\x $\mid$ {\bf SOP} ( Name$\S $PositionVariable-FIXED )\\

I/O-Statement ::=\\
\x OpenStatement $\mid$ CloseStatement\\
\x $\mid$ PutStatement $\mid$ GetStatement\\
\x $\mid$ WriteStatement $\mid$ ReadStatement\\
\x $\mid$ SendStatement $\mid$ TakeStatement\\
         
OpenStatement ::=\\
\x {\bf OPEN} Name$\S $Dation [ {\bf BY} OpenParameter [ , OpenParameter ] $^{...}$ ] ;\\

OpenParameter ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf IDF} ( \{ Name$\S $CharacterStringVariable $\mid$ CharacterStringConstant \} )\\
\x $\mid$ \{ {\bf OLD $\mid$ NEW $\mid$ ANY} \}\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

CloseStatement ::=\\ 
\x {\bf CLOSE} Name$\S $Dation [ {\bf BY} CloseParameter [ , CloseParameter ] $^{...}$ ] ;\\

CloseParameter ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf CAN $\mid$ PRM} \}\\

PutStatement ::=\\
\x {\bf PUT} [ \{ Expression $\mid$ Slice \} [ , \{ Expression $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} FormatOrPosition [ , FormatOrPosition ] $^{...}$ ] ;\\

GetStatement ::=\\
\x {\bf GET} [ \{ Name $\mid$ Slice \} [ , \{ Name $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} FormatOrPosition [ , FormatOrPosition ] $^{...}$ ] ;\\

WriteStatement ::=\\
\x {\bf WRITE} [ \{ Expression $\mid$ Slice \} [ , \{ Expression $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf TO} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ; \\
        
ReadStatement ::=\\
\x {\bf READ} [ \{ Name $\mid$ Slice \} [ , \{ Name $\mid$ Slice \} ] $^{...}$ ]\\
\x {\bf FROM} Name$\S $Dation [ {\bf BY} Position [ , Position ] $^{...}$ ] ;\\
        
SendStatement ::=\\
\x {\bf SEND} [ Expression ] {\bf TO} Name$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

TakeStatement ::=\\
\x {\bf TAKE} [ Name ] {\bf FROM} Name$\S $Dation\\
\x [ {\bf BY} RST-S-CTRL-Format [ , RST-S-CTRL-Format ] $^{...}$ ] ;\\

RST-S-CTRL-Format ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ {\bf S} ( Name$\S $Variable-FIXED )\\
\x $\mid$ {\bf CONTROL} ( Expression [ , Expression [ , Expression ] ] )\\

Slice ::=\\
\x Name$\S $Array ( [ Index , ] $^{...}$ Index : Index )\\
\x $/^*$ Instead of the last array-index an index-slice is given to address 
the respective one-dimensional array-slice which is processed by the I/O 
in bottom-up order. $*/$\\

FormatOrPosition ::=\\
\x [ Factor ] \{ Format $\mid$ Position \}\\
\x $\mid$ Factor ( FormatOrPosition [ , FormatOrPosition ] $^{...}$ )\\
        
Factor ::=\\
\x ( Expression$\S $IntegerGreaterZero ) $\mid$ IntegerWithoutPrecision$\S $GreaterZero\\

Format ::=\\
\x \{ {\bf F $\mid$ E}\} ( Expression [ , Expression [ , Expression ] ] ) \\
\x $\mid$ \{ {\bf B $\mid$ B1 $\mid$ B2 $\mid$ B3 $\mid$ B4 $\mid$ A} \} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf T $\mid$ D} \} ( Expression [ , Expression ] )\\
\x $\mid$ {\bf LIST}\\
\x $\mid$ {\bf R} ( Identifier$\S $Format )\\
\x $\mid$ {\bf S} ( Name$\S $LengthVariable-FIXED )\\

Position ::=\\
\x {\bf RST} ( Name$\S $ErrorVariable-FIXED )\\
\x $\mid$ \{ {\bf X $\mid$ SKIP $\mid$ PAGE} \} [ ( Expression ) ]\\
\x $\mid$ \{ {\bf POS $\mid$ ADV} \} ( Expression [ , Expression [ , Expression ] ] )\\
\x $\mid$ \{ {\bf COL $\mid$ LINE} \} ( Expression )\\
\x $\mid$ {\bf SOP} ( Name [ , Name [ , Name ] ]  $/^*$ PositionVariables-FIXED $^*/$ )\\

\twocolumn[\section{List of Keywords with Shortforms}   % A 4

The denotation behind the keyword refers to the paragraph where it
is introduced.\\]

{
{\bf ACTIVATE} 9.2.2\\
{\bf AFTER} 9.2.1\\
{\bf ALL} 9.2.1\\
{\bf ALPHIC} 10.2\\
{\bf ALT} 7.2\\
{\bf AT} 9.2.1\\

{\bf BASIC} 10.2\\
{\bf BEGIN} 4.4 \\
{\bf BIT} 5.4\\
{\bf BOLT} 9.3.2\\
{\bf BY} 7.3, 10.3\\

{\bf CALL} 8.2\\
{\bf CASE} 7.2\\
{\bf CHARACTER}, {\bf CHAR} 5.5\\
{\bf CLOCK} 5.7\\
{\bf CLOSE} 10.3\\
{\bf CONT} 5.9\\
{\bf CONTINUE} 9.2.5\\
{\bf CONTROL} 10.2\\
{\bf CONVERT} 10.2\\
{\bf CREATED} 10.2\\
{\bf CYCLIC} 10.2\\
 
{\bf DATION} 10.2\\
{\bf DECLARE}, {\bf DCL} 4.1\\
{\bf DIM} 10.2\\
{\bf DIRECT} 10.2\\
{\bf DISABLE} 9.4.2\\
{\bf DURATION}, {\bf DUR} 5.8\\
{\bf DURING} 9.2.1\\

{\bf ELSE} 7.1\\
{\bf ENABLE} 9.4.2\\
{\bf END} 4.4, 8.1, 9.1\\
{\bf ENTER} 9.3.2\\
{\bf ENTRY} 8.1\\
{\bf EXIT} 7.5\\

{\bf FIN} 7.1\\
{\bf FIXED} 5.2\\
{\bf FLOAT} 5.3\\
{\bf FOR} 7.3\\
{\bf FORBACK} 10.2\\
{\bf FORMAT} 10.5.8\\
{\bf FORWARD} 10.2\\
{\bf FREE} 9.3.2\\
{\bf FROM} 7.3, 10.4\\
 
{\bf GET} 10.5\\
{\bf GLOBAL} 4.1\\
{\bf GOTO} 7.4\\
 
{\bf HRS} 5.8\\
 
{\bf IDENTICAL}, {\bf IDENT} 4.1, 8.1\\
{\bf IF} 7.1\\                           
{\bf IN} 10.2\\
{\bf INDUCE} 11\\
{\bf INITIAL}, {\bf INIT} 5.14\\
{\bf INOUT} 10.2\\
{\bf INTERRUPT}, {\bf IRPT} 9.4.1\\
{\bf INV} 5.15\\
 
{\bf LEAVE} 9.3.2\\
{\bf LENGTH} 5.6\\
 
{\bf MAIN} 9.1\\
{\bf MAX} 10.2\\
{\bf MIN} 5.8\\
{\bf MODEND} 4.1\\
{\bf MODULE} 4.1\\
 
{\bf NIL} 5.9\\
{\bf NOCYCL} 10.2\\
{\bf NOSTREAM} 10.2\\

{\bf ON} 11\\
{\bf OPEN} 10.3\\
{\bf OPERATOR} 6.2\\
{\bf OUT} 7.2, 10.2\\
 
{\bf PRECEDENCE} 7.2\\
{\bf PRESET} 9.3.1\\
{\bf PREVENT} 9.2.7\\
{\bf PRIORITY}, {\bf PRIO} 9.1\\
{\bf PROBLEM} 4.3\\
{\bf PROCEDURE}, {\bf PROC} 8.1\\
{\bf PUT} 10.5\\

{\bf READ} 10.4\\
{\bf REF} 5.9\\
{\bf RELEASE} 9.3.1\\
{\bf REPEAT} 7.3\\
{\bf REQUEST} 9.3.1\\
{\bf RESERVE} 9.3.2\\
{\bf RESUME} 9.2.6\\
{\bf RETURN} 8.2\\
{\bf RETURNS} 8.1\\
 
{\bf SEC} 5.8\\
{\bf SEMA} 9.3.1\\
{\bf SEND} 10.6\\
{\bf SIGNAL} 11\\
{\bf SPECIFY}, {\bf SPC} 4.1\\
{\bf STREAM} 10.2\\
{\bf STRUCT} 5.11\\
{\bf SUSPEND} 9.2.4\\
{\bf SYSTEM} 4.2\\
 
{\bf TAKE} 10.6\\
{\bf TASK} 9.1\\
{\bf TERMINATE} 9.2.3\\
{\bf TFU} 10.2\\
{\bf THEN} 7.1\\
{\bf TO} 7.3, 10.4\\
{\bf TRIGGER} 9.4.2\\
{\bf TYPE} 5.12\\
 
{\bf UNTIL} 9.2.1\\
 
{\bf WHEN} 9.2.1\\
{\bf WHILE} 7.3\\
{\bf WRITE} 10.4
}
\onecolumn

\twocolumn[\section{Other Word Symbols in PEARL}    % A 5

The denotation behind the word symbol refers to the paragraph where it
is introduced.\\]

{
{\bf A} 10.5.2\\
{\bf ABS} 6.1.1\\
{\bf ADV} 10.4\\
{\bf AND} 6.1.2\\
{\bf ANY} 10.3\\
{\bf ATAN} 6.1.1\\

{\bf B} 10.5.4\\
{\bf B1} 10.5.4\\
{\bf B2} 10.5.4\\
{\bf B3} 10.5.4\\
{\bf B4} 10.5.4\\

{\bf CAN} 10.3\\
{\bf CAT} 6.1.2\\
{\bf COL} 10.4\\
{\bf CONT} 5.9\\
{\bf COS} 6.1.1\\
{\bf CSHIFT} 6.1.2\\
 
{\bf D} 10.5.6\\
{\bf DATE} A2.2\\
 
{\bf E} 10.5.2\\
{\bf ENTIER} 6.1.1\\
{\bf EQ} 6.1.2\\
{\bf EXOR} 6.1.2\\
{\bf EXP} 6.1.1\\
 
{\bf F} 10.5.1\\
{\bf FIT} 6.1.2\\
 
{\bf GE} 6.1.2\\
{\bf GT} 6.1.2\\
 
{\bf IDF} 10.3\\
{\bf IS} 5.9\\
{\bf ISNT} 5.9\\

 
{\bf LE} 6.1.2\\
{\bf LINE} 10.4\\
{\bf LIST} 10.5.7\\
{\bf LN} 6.1.1\\
{\bf LT} 6.1.2\\
{\bf LWB} 6.1.1, 6.1.2\\
 
{\bf NE} 6.1.2\\
{\bf NEW} 10.3\\
{\bf NOT} 6.1.1\\
{\bf NOW} A2.1\\
 
{\bf OLD} 10.3\\
{\bf OR} 6.1.2\\
 
{\bf PAGE} 10.4\\
{\bf POS} 10.4\\
{\bf PRM} 10.3\\
 
{\bf R} 10.5.8\\
{\bf REM} 6.1.2\\
{\bf ROUND} 6.1.1\\
{\bf RST} 10.3, 10.8\\
 
{\bf S} 10.5.3\\
{\bf SHIFT} 6.1\\
{\bf SIGN} 6.1.1\\
{\bf SIN} 6.1.1\\
{\bf SIZEOF} 6.1\\
{\bf SKIP} 10.4\\
{\bf SOP} 10.4\\
{\bf SQRT} 6.1.1\\
 
{\bf T} 10.5.5\\
{\bf TAN} 6.1.1\\
{\bf TANH} 6.1.1\\
{\bf TOBIT} 6.1.1\\
{\bf TOCHAR} 6.1.1\\
{\bf TOFIXED} 6.1.1\\
{\bf TOFLOAT} 6.1.1\\
{\bf TRY} 9.3.1\\
 
{\bf UPB} 6.1.1, 6.1.2\\

{\bf X} 10.4
}

\end{document}


